<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>编译器 on 办公AI智能小助手</title>
        <link>http://localhost:1313/tags/%E7%BC%96%E8%AF%91%E5%99%A8/</link>
        <description>Recent content in 编译器 on 办公AI智能小助手</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>qife</copyright>
        <lastBuildDate>Wed, 06 Aug 2025 13:09:01 +0800</lastBuildDate><atom:link href="http://localhost:1313/tags/%E7%BC%96%E8%AF%91%E5%99%A8/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>快速准确的C/C&#43;&#43;语法搜索工具Syntex解析</title>
        <link>http://localhost:1313/p/%E5%BF%AB%E9%80%9F%E5%87%86%E7%A1%AE%E7%9A%84c/c-%E8%AF%AD%E6%B3%95%E6%90%9C%E7%B4%A2%E5%B7%A5%E5%85%B7syntex%E8%A7%A3%E6%9E%90/</link>
        <pubDate>Wed, 06 Aug 2025 13:09:01 +0800</pubDate>
        
        <guid>http://localhost:1313/p/%E5%BF%AB%E9%80%9F%E5%87%86%E7%A1%AE%E7%9A%84c/c-%E8%AF%AD%E6%B3%95%E6%90%9C%E7%B4%A2%E5%B7%A5%E5%85%B7syntex%E8%A7%A3%E6%9E%90/</guid>
        <description>&lt;h2 id=&#34;基于上下文的智能搜索&#34;&gt;基于上下文的智能搜索
&lt;/h2&gt;&lt;p&gt;Syntex解决了传统模式搜索工具的两大核心问题：&lt;/p&gt;
&lt;p&gt;首先，现有工具容易产生假阴性结果。这些工具通常使用自建解析器处理不同语言代码库，对于C/C++代码往往不进行宏扩展处理。这意味着它们无法像Clang等真实编译器那样提供准确结果，用户无法确信&amp;quot;这是该模式的所有出现&amp;quot;或&amp;quot;该模式从未出现&amp;quot;。&lt;/p&gt;
&lt;p&gt;其次，这些工具的内部解析器不使用真实编译器的代码表示方式，也不理解源代码语义。它们只能输出纯文本结果，无法提供结果出现的语义上下文，这严重限制了作为分析基础工具的实用性。&lt;/p&gt;
&lt;h2 id=&#34;基于clang-ast的语法匹配&#34;&gt;基于Clang AST的语法匹配
&lt;/h2&gt;&lt;p&gt;Syntex通过操作真实的Clang AST解决了这些问题。由于使用与编译器相同的AST表示，它消除了传统工具的准确性缺陷，并能提供包含AST节点引用的结果，支持后续语义分析。&lt;/p&gt;
&lt;h2 id=&#34;语法合成技术&#34;&gt;语法合成技术
&lt;/h2&gt;&lt;p&gt;在代码构建和索引阶段，Syntex通过递归遍历Clang AST生成上下文无关文法。子节点对应非终结符，每个节点出现都会添加形如parent -&amp;gt; child_0&amp;hellip;child_n的产生式规则。无子节点则成为文法中的终结符号。&lt;/p&gt;
&lt;h2 id=&#34;查询解析机制&#34;&gt;查询解析机制
&lt;/h2&gt;&lt;p&gt;Syntex使用记忆化图表解析器（memoizing chart parser）解析查询语句。记忆化技术防止了解析过程的指数级复杂度，结果记忆表作为查询解析森林的内存表示。匹配器利用该表确定哪些索引AST与查询匹配。&lt;/p&gt;
&lt;h2 id=&#34;高级功能特性&#34;&gt;高级功能特性
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;元变量支持&lt;/strong&gt;：如&amp;quot;++$x&amp;quot;可匹配任何递增表达式，并可通过名称x获取匹配子表达式&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通配运算符&lt;/strong&gt;：&amp;ldquo;printf($&amp;hellip;)&amp;ldquo;可匹配任意数量参数的printf调用&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类型约束&lt;/strong&gt;：&amp;quot;++$x:DECL_REF_EXPR&amp;quot;仅匹配对声明引用的递增操作&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;未来发展方向&#34;&gt;未来发展方向
&lt;/h2&gt;&lt;p&gt;Syntex计划支持C++模板实例化的语法搜索，利用Clang将AST节点还原为源代码的能力。该项目已超越Semgrep等开源替代方案，展现了在语法搜索领域的独特优势。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>用C语言构建你自己的Lisp解释器</title>
        <link>http://localhost:1313/p/%E7%94%A8c%E8%AF%AD%E8%A8%80%E6%9E%84%E5%BB%BA%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84lisp%E8%A7%A3%E9%87%8A%E5%99%A8/</link>
        <pubDate>Wed, 06 Aug 2025 06:16:48 +0800</pubDate>
        
        <guid>http://localhost:1313/p/%E7%94%A8c%E8%AF%AD%E8%A8%80%E6%9E%84%E5%BB%BA%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84lisp%E8%A7%A3%E9%87%8A%E5%99%A8/</guid>
        <description>&lt;img src="https://i.imgs.ovh/2025/08/06/oFJa0.png" alt="Featured image of post 用C语言构建你自己的Lisp解释器" /&gt;&lt;h1 id=&#34;构建你自己的lisp&#34;&gt;构建你自己的Lisp
&lt;/h1&gt;&lt;h2 id=&#34;用c语言在1000行代码内打造专属编程语言&#34;&gt;用C语言在1000行代码内打造专属编程语言！
&lt;/h2&gt;&lt;p&gt;如果你想学习C语言，或者曾好奇如何构建自己的编程语言，这本书就是为你准备的。仅用少量代码，我将教你如何使用C语言，并共同构建属于你自己的编程语言。&lt;/p&gt;
&lt;p&gt;在实践过程中，我们将学习：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Lisp语言奇妙而独特的本质&lt;/li&gt;
&lt;li&gt;如何开发真实世界项目&lt;/li&gt;
&lt;li&gt;简洁高效地解决问题&lt;/li&gt;
&lt;li&gt;编写优雅的代码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本书可免费在线阅读，立即开始你的编程之旅！如需最佳阅读体验或想支持作者，本书也提供印刷版和主要电子书格式的平价版本。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;&#34; &gt;立即购买&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;&#34; &gt;在线阅读&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;读者评价&#34;&gt;读者评价
&lt;/h3&gt;&lt;p&gt;&amp;ldquo;通过实现自己的Lisp，我终于感觉自己成为了真正的C程序员。&amp;rdquo;
&amp;ldquo;每个程序员至少应该尝试一次这样的项目。&amp;rdquo;
&amp;ldquo;这是我在互联网上发现的最棒的东西之一&amp;hellip;&amp;rdquo;&lt;/p&gt;
&lt;p&gt;@hirojin
@mattcaldwell
@euryadam&lt;/p&gt;
</description>
        </item>
        <item>
        <title>部署安全缓解措施面临的挑战：ClangCFI与CFGuard的实践对比</title>
        <link>http://localhost:1313/p/%E9%83%A8%E7%BD%B2%E5%AE%89%E5%85%A8%E7%BC%93%E8%A7%A3%E6%8E%AA%E6%96%BD%E9%9D%A2%E4%B8%B4%E7%9A%84%E6%8C%91%E6%88%98clangcfi%E4%B8%8Ecfguard%E7%9A%84%E5%AE%9E%E8%B7%B5%E5%AF%B9%E6%AF%94/</link>
        <pubDate>Mon, 04 Aug 2025 03:19:48 +0800</pubDate>
        
        <guid>http://localhost:1313/p/%E9%83%A8%E7%BD%B2%E5%AE%89%E5%85%A8%E7%BC%93%E8%A7%A3%E6%8E%AA%E6%96%BD%E9%9D%A2%E4%B8%B4%E7%9A%84%E6%8C%91%E6%88%98clangcfi%E4%B8%8Ecfguard%E7%9A%84%E5%AE%9E%E8%B7%B5%E5%AF%B9%E6%AF%94/</guid>
        <description>&lt;h3 id=&#34;计划实施&#34;&gt;计划实施
&lt;/h3&gt;&lt;p&gt;我们原计划简单明了：为Windows版osquery启用CFGuard，为Linux版启用ClangCFI。通过对比测试套件结果进行量化评估，最终将补丁贡献给osquery代码库，实现双赢——既产出技术博客又增强安全性。&lt;/p&gt;
&lt;h3 id=&#34;严格性对比&#34;&gt;严格性对比
&lt;/h3&gt;&lt;p&gt;ClangCFI在安全性上更为严格：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对每个间接调用，ClangCFI允许的目标地址更少（图1示例）&lt;/li&gt;
&lt;li&gt;执行更全面的错误检测（如类型转换检查、虚方法调用目标验证等）&lt;/li&gt;
&lt;li&gt;要求全程序分析，因此必须满足：
&lt;ol&gt;
&lt;li&gt;所有链接对象和静态库都需启用CFI&lt;/li&gt;
&lt;li&gt;必须启用链接时优化(LTO)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CFGuard则采用更宽松的验证标准：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;仅需验证间接调用目标是否为合法函数入口点&lt;/li&gt;
&lt;li&gt;支持渐进式部署，允许混合使用受保护和未受保护的代码模块&lt;/li&gt;
&lt;li&gt;动态链接库(DSO/DLL)完全兼容&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;工程实践挑战&#34;&gt;工程实践挑战
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;ClangCFI的全有或全无特性&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;必须为整个依赖树启用CFI（包括libc++等深层依赖）&lt;/li&gt;
&lt;li&gt;链接器不会检查CFI一致性，但运行时可能失败（表1展示合法链接组合）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;代码兼容性问题&lt;/strong&gt;：
尝试为strongSwan启用ClangCFI时，其C语言OOP系统因类型签名不匹配触发严格检查。虽然技术上ClangCFI正确，但实际代码中存在大量不符合标准的模式。CFI黑名单功能在此场景下几乎需禁用所有检查点，失去安全意义。&lt;/p&gt;
&lt;h3 id=&#34;结论&#34;&gt;结论
&lt;/h3&gt;&lt;p&gt;从安全角度看，ClangCFI确实优于CFGuard——更严格的检查、全程序保护、更多运行时验证。Google Chrome团队已成功实践该方案。但增强安全的代价是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要大量开发时间投入&lt;/li&gt;
&lt;li&gt;必须进行严格测试&lt;/li&gt;
&lt;li&gt;对现有代码库改造难度大&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而CFGuard的灵活性使其能快速应用于现有项目。最终我们的Windows版osquery已实装CFGuard，Linux版ClangCFI仍在攻坚中。这种对比深刻揭示了安全措施在理想与现实之间的关键权衡。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;[1] 技术细节补充：CFGuard实际也存在例外情况，如某些被抑制的函数入口点仍属非法目标&lt;br&gt;
[2] 根据Evgeniy Stepanov的解释，非CFI代码中的函数若仅被直接调用仍可混合链接&lt;br&gt;
[3] 官方文档明确允许混合CFG/非CFG代码共存&lt;/p&gt;
</description>
        </item>
        <item>
        <title>深入iOS安全与编译器理论：MAST移动应用安全工具包解析</title>
        <link>http://localhost:1313/p/%E6%B7%B1%E5%85%A5ios%E5%AE%89%E5%85%A8%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E7%90%86%E8%AE%BAmast%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E5%8C%85%E8%A7%A3%E6%9E%90/</link>
        <pubDate>Sun, 03 Aug 2025 21:58:16 +0800</pubDate>
        
        <guid>http://localhost:1313/p/%E6%B7%B1%E5%85%A5ios%E5%AE%89%E5%85%A8%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E7%90%86%E8%AE%BAmast%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E5%8C%85%E8%A7%A3%E6%9E%90/</guid>
        <description>&lt;h3 id=&#34;什么是code-as-craft&#34;&gt;什么是Code as Craft？
&lt;/h3&gt;&lt;p&gt;Etsy的Code as Craft活动是每月两次的嘉宾演讲系列，聚焦技术主题或计算趋势，既分享概念性思想也提供实用建议。所有讲座将在布鲁克林华盛顿街55号7楼的Etsy实验室（712室）举行。&lt;/p&gt;
&lt;h3 id=&#34;演讲内容是什么&#34;&gt;演讲内容是什么？
&lt;/h3&gt;&lt;p&gt;Sophia将探讨iOS安全最新进展及其与编译器理论的交叉点。重点介绍移动应用安全工具包MAST——该项目已从DARPA概念验证发展为完整的移动应用防护套件，集成以下关键技术：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;越狱检测&lt;/strong&gt;：识别设备安全环境&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;反调试&lt;/strong&gt;：阻止动态分析攻击&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基于LLVM的反逆向&lt;/strong&gt;：在编译器层面实现保护机制&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;演讲将分析当前iOS攻击态势，指出苹果原生API的防御不足，并演示MAST如何为高风险应用提供超越系统原生的保护方案。该工具现已开放测试，参与者可联系获取试用。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
