<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>内存管理 on 办公AI智能小助手</title>
        <link>http://localhost:1313/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
        <description>Recent content in 内存管理 on 办公AI智能小助手</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>qife</copyright>
        <lastBuildDate>Thu, 07 Aug 2025 23:12:26 +0800</lastBuildDate><atom:link href="http://localhost:1313/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Intel EPT技术实现MMU虚拟化详解</title>
        <link>http://localhost:1313/p/intel-ept%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0mmu%E8%99%9A%E6%8B%9F%E5%8C%96%E8%AF%A6%E8%A7%A3/</link>
        <pubDate>Thu, 07 Aug 2025 23:12:26 +0800</pubDate>
        
        <guid>http://localhost:1313/p/intel-ept%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0mmu%E8%99%9A%E6%8B%9F%E5%8C%96%E8%AF%A6%E8%A7%A3/</guid>
        <description>&lt;h1 id=&#34;mmu-virtualization-via-intel-ept---index&#34;&gt;MMU Virtualization via Intel EPT - Index
&lt;/h1&gt;&lt;h2 id=&#34;概述&#34;&gt;概述
&lt;/h2&gt;&lt;p&gt;在收到大量请求后，我决定完成这个关于使用Intel EPT实现MMU虚拟化的5部分系列文章。本系列既可用于自主hypervisor开发，也可与之前发布的CPU虚拟化系列配套使用。文章将频繁引用先前项目内容（因多数读者会同步跟进），但实现方案在所有Type-2型hypervisor项目中都较为相似。本系列仅适用于支持虚拟化技术特性的Intel处理器用户，目标是让读者掌握分页机制、扩展页表(EPT)、多种地址转换机制的技术细节，并学会在虚拟化项目中实际应用。&lt;/p&gt;
&lt;p&gt;完成本系列后，读者将拥有可工作的EPT基础框架，并能在未来项目中自主设计实现EPT基础设施。每篇文章都会像往常一样提供相关概念解析、重要性说明、详细参考资料链接，并在文末设置&amp;quot;推荐阅读&amp;quot;章节。部分VMX地址转换机制还会标注&amp;quot;必读&amp;quot;要求。&lt;/p&gt;
&lt;h2 id=&#34;章节规划&#34;&gt;章节规划
&lt;/h2&gt;&lt;h3 id=&#34;part-0---技术基础&#34;&gt;Part 0 - 技术基础
&lt;/h3&gt;&lt;p&gt;介绍扩展页表相关子课题，包括Intel EPT的设计动机、地址转换辅助机制、性能考量，以及分页结构中常见的缓存组件入门。&lt;/p&gt;
&lt;h3 id=&#34;part-1---实现篇---结构体定义与初始化&#34;&gt;Part 1 - 实现篇 - 结构体定义与初始化
&lt;/h3&gt;&lt;p&gt;提供预制结构体及其功能详解，这些结构将用于本系列主要EPT实现。同时详述VMX环境下EPT初始化与直通(passthrough)流程。完成本章后将具备可运行的EPT框架。&lt;/p&gt;
&lt;h3 id=&#34;part-2---实现篇---ept辅助函数页遍历ept违规与销毁&#34;&gt;Part 2 - 实现篇 - EPT辅助函数/页遍历/EPT违规与销毁
&lt;/h3&gt;&lt;p&gt;解析各类EPT引发的VM-exit及其处理方法，实现销毁函数集和Guest-Host地址转换辅助例程。读者将编写处理程序，学习EPT相关的配置错误、违规和异常类型。&lt;/p&gt;
&lt;h3 id=&#34;part-3---集成测试&#34;&gt;Part 3 - 集成测试
&lt;/h3&gt;&lt;p&gt;将EPT初始化函数集成到现有CPU虚拟化项目中，通过测试运行验证EPT正常工作，并主动触发违规来测试处理程序。&lt;/p&gt;
&lt;h3 id=&#34;part-4---eptp切换与页钩子附加章节&#34;&gt;Part 4 - EPTP切换与页钩子（附加章节）
&lt;/h3&gt;&lt;p&gt;作为安全研究特别内容，演示如何通过EPTP切换和页钩子来隐藏信息、挂钩受保护函数，或防止敏感信息被读取。案例包括：挂钩Windows内核函数以伪造代码完整性校验结果，以及防止应用程序读取受保护进程的内存空间。&lt;/p&gt;
&lt;h2 id=&#34;特别说明&#34;&gt;特别说明
&lt;/h2&gt;&lt;p&gt;在阅读本系列前，强烈建议通读所有推荐资料并实践——如果你想真正精通虚拟化技术和微架构的话。这个提醒会在每篇文章重复出现，因为细节决定成败。各章节还会根据内容补充推特、博客等第三方资料（均会标明出处）。&lt;/p&gt;
&lt;p&gt;特别感谢Aidan Khoury在合作项目中提供的深刻见解，他传授的诸多技巧将在本系列与读者分享。欢迎在评论区留下反馈、问题或建议。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;版权声明：本文采用Read Only许可协议，禁止未经授权的复制或使用&lt;/em&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Arm64架构内存页大小配置指南：提升性能的关键技巧</title>
        <link>http://localhost:1313/p/arm64%E6%9E%B6%E6%9E%84%E5%86%85%E5%AD%98%E9%A1%B5%E5%A4%A7%E5%B0%8F%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD%E7%9A%84%E5%85%B3%E9%94%AE%E6%8A%80%E5%B7%A7/</link>
        <pubDate>Wed, 06 Aug 2025 22:20:09 +0800</pubDate>
        
        <guid>http://localhost:1313/p/arm64%E6%9E%B6%E6%9E%84%E5%86%85%E5%AD%98%E9%A1%B5%E5%A4%A7%E5%B0%8F%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD%E7%9A%84%E5%85%B3%E9%94%AE%E6%8A%80%E5%B7%A7/</guid>
        <description>&lt;h1 id=&#34;理解arm64架构的内存页大小&#34;&gt;理解Arm64架构的内存页大小
&lt;/h1&gt;&lt;p&gt;Arm64架构与x86的主要区别之一，是可以在CPU的内存管理单元(MMU)中配置4K、16K或64K的内存页大小。本文总结了内存页大小的概念、在Linux系统上的配置方法，以及何时应该为应用程序使用不同的页大小。&lt;/p&gt;
&lt;h2 id=&#34;内存页大小介绍&#34;&gt;内存页大小介绍
&lt;/h2&gt;&lt;p&gt;正如我们在&lt;a class=&#34;link&#34; href=&#34;%e5%8e%9f%e9%93%be%e6%8e%a5&#34; &gt;诊断和修复Arm64原子操作的页错误性能问题&lt;/a&gt;中讨论过的，操作系统为应用程序提供虚拟内存地址空间，并通过页表将物理内存页映射到虚拟内存地址。CPU随后提供名为转译后备缓冲器(TLB)的机制，确保最近访问的内存页可以通过L1或L2 CPU缓存更快地被识别和读取。&lt;/p&gt;
&lt;p&gt;x86架构的物理内存页(称为granules)大小固定为4KB。而在Ampere Altra®或AmpereOne®等ARM64系统上，开发者可以配置物理内存页大小为4KB、16KB或64KB。&lt;/p&gt;
&lt;h2 id=&#34;何时使用更大的页大小&#34;&gt;何时使用更大的页大小？
&lt;/h2&gt;&lt;p&gt;由于改变页大小会影响系统的内存效率和性能，理解何时使用更大的页大小以及涉及的权衡非常重要。更大的页大小可能导致内存使用效率降低，因为页面可能未被完全利用。&lt;/p&gt;
&lt;p&gt;例如，如果我们在内存中存储7KB数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在4KB页系统中会使用两个4KB页面(共8KB)，效率为87.5%&lt;/li&gt;
&lt;li&gt;在64KB页系统中会使用一个64KB页面，效率仅为11%&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但MMU和操作系统内核足够智能，会利用之前分配但未满的连续内存块进行后续分配。如果同一进程后续分配32KB内存：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;64KB页系统仍只使用一个页面(共39KB占用)&lt;/li&gt;
&lt;li&gt;4KB页系统则需要管理10个4KB页面&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第二个权衡是页表查找缓存未命中导致的性能问题。每级缓存(L1、L2、系统级缓存)的TLB中只存储相对少量的页表项。更大的页大小意味着这些TLB项能覆盖更大的物理内存范围。&lt;/p&gt;
&lt;p&gt;以Ampere Altra和Altra Max处理器为例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;L1数据TLB有48个条目&lt;/li&gt;
&lt;li&gt;L2 TLB有1280个条目&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这意味着：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;4KB粒度时：L1 TLB可缓存192KB物理内存地址，L2 TLB可覆盖5MB&lt;/li&gt;
&lt;li&gt;64KB页大小时：L1数据TLB增至3MB，L2 TLB增至80MB&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每次TLB缓存未命中都会增加页遍历时间，导致CPU流水线停顿。更大的页大小意味着更少的缓存未命中，从而提升内存密集型工作负载的性能。同时，更大的连续内存区域也能改善I/O性能。&lt;/p&gt;
&lt;p&gt;适合使用大内存页的应用包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;数据库系统&lt;/strong&gt;：大量内存缓存和磁盘I/O&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;虚拟化基础设施&lt;/strong&gt;：虚拟机镜像通常占用数百MB到数百GB内存&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;持续集成构建服务器&lt;/strong&gt;：如Linux内核编译等高吞吐量工作负载&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络/I/O密集型应用&lt;/strong&gt;：对象缓存、负载均衡器、防火墙等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AI推理&lt;/strong&gt;：执行训练模型时的内存和CPU密集型工作负载&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;建议通过&amp;quot;perf&amp;quot;工具测量TLB停顿(stall_backend_tlb和stall_frontend_tlb)来评估大页面的潜在收益。计算公式：(stall_frontend_tlb + stall_backend_tlb)/cycles可作为可能节省时间的上限估计。&lt;/p&gt;
&lt;h2 id=&#34;在ampere-cpu上配置大页大小&#34;&gt;在Ampere CPU上配置大页大小
&lt;/h2&gt;&lt;p&gt;更改内存页大小需要运行支持所需大小的内核。主流云操作系统(如RHEL、Oracle Linux、SUSE、Ubuntu)都提供预编译的4KB和64KB页大小内核。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RHEL 9配置步骤&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装64K内核包：&lt;code&gt;dnf –y install kernel-64k&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;设置为默认启动内核：
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; /boot/vmlinuz*64k&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;grubby --set-default&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$k&lt;/span&gt; --update-kernel&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$k&lt;/span&gt; --args&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;crashkernel=2G-:640M&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Ubuntu 22.04配置&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装arm64+largemem ISO或&lt;code&gt;sudo apt install linux-generic-64K&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;设置64K内核为默认：
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;GRUB_FLAVOUR_ORDER=generic-64k&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; sudo tee /etc/default/grub.d/local-order.cfg
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Oracle Linux配置&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装内核包：&lt;code&gt;sudo dnf install -y kernel-uek64k&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;设置为默认：&lt;code&gt;sudo grubby --set-default=$(echo /boot/vmlinuz*64k)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;自定义编译内核时，可通过&lt;code&gt;make menuconfig&lt;/code&gt;在&amp;quot;Processor type and features&amp;quot;子菜单中修改ARM64 CPU特性寄存器配置，或直接修改.config文件中的&lt;code&gt;CONFIG_ARM_PAGE_SHIFT&lt;/code&gt;值(12对应4K，14对应16K，16对应64K)。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;getconf PAGESIZE&lt;/code&gt;命令可验证当前内核的页大小设置，64K系统将显示65536。&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论
&lt;/h2&gt;&lt;p&gt;调整云系统的内核内存页大小可显著提升许多常见云工作负载的应用性能。对于包含大量磁盘、内存或网络I/O的应用程序，在ARM主机上使用16K或64K页内核可能带来显著改进。&lt;/p&gt;
&lt;p&gt;但这不是万能方案，实际效果可能因应用而异。建议同时使用合成基准测试和真实场景测试来验证页大小改变的影响。多数支持Arm64的Linux发行版已在其仓库中包含多种内核，安装这些内核包并启动测试的成本相对较低。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Linux内核v4.17安全特性解析：从内存保护到系统调用加固</title>
        <link>http://localhost:1313/p/linux%E5%86%85%E6%A0%B8v4.17%E5%AE%89%E5%85%A8%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90%E4%BB%8E%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4%E5%88%B0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8A%A0%E5%9B%BA/</link>
        <pubDate>Tue, 05 Aug 2025 01:15:44 +0800</pubDate>
        
        <guid>http://localhost:1313/p/linux%E5%86%85%E6%A0%B8v4.17%E5%AE%89%E5%85%A8%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90%E4%BB%8E%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4%E5%88%B0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8A%A0%E5%9B%BA/</guid>
        <description>&lt;h3 id=&#34;linux内核v417的安全特性&#34;&gt;Linux内核v4.17的安全特性
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;先前版本&lt;/strong&gt;：v4.16&lt;br&gt;
Linux内核v4.17于上周发布，以下是我认为值得关注的安全改进：&lt;/p&gt;
&lt;h4 id=&#34;jailhouse管理程序&#34;&gt;Jailhouse管理程序
&lt;/h4&gt;&lt;p&gt;Jan Kiszka引入了Jailhouse管理程序支持，采用静态分区技术（即不进行资源超分配）。根&amp;quot;单元&amp;quot;通过缩减自身的CPU/内存等资源来创建新隔离区，并将资源移交给新隔离区。LWN在2014年对该管理程序有详细报道。&lt;/p&gt;
&lt;h4 id=&#34;sparc-adi支持&#34;&gt;SPARC ADI支持
&lt;/h4&gt;&lt;p&gt;Khalid Aziz实现了SPARC应用数据完整性（ADI或称SSM：硅安全内存）的用户空间支持，这是SPARC M7处理器的硬件内存着色（标记）功能。该技术能有效防御线性溢出攻击，因为基指针被标记为仅属于特定内存分配区域（大小与缓存行对齐）。任何尝试越界访问不同标记内存的操作都会触发异常。Enrico Perla撰写了关于ADI在分配器中的应用及其与Intel MPX的对比分析。&lt;/p&gt;
&lt;h4 id=&#34;fork时清零新内核栈&#34;&gt;fork时清零新内核栈
&lt;/h4&gt;&lt;p&gt;此前新进程的内核栈可能残留旧内存内容。虽然通常不可见，但&amp;quot;未初始化&amp;quot;内存读取缺陷或读取溢出可能暴露这些内容（尤其是栈深处可能永远不被覆盖的数据）。为此我确保新栈始终被清零。有趣的是，这种缓存&amp;quot;预热&amp;quot;反而提升了性能，尽管差异微小。&lt;/p&gt;
&lt;h4 id=&#34;map_fixed_noreplace&#34;&gt;MAP_FIXED_NOREPLACE
&lt;/h4&gt;&lt;p&gt;为防御Stack Clash等攻击，Michal Hocko创建了MAP_FIXED_NOREPLACE。常规MAP_FIXED存在一个易被忽视的危险行为：它会替换任何重叠的现有映射。这意味着内核可能悄无声息地将栈重叠到mmap或代码区域。而MAP_FIXED_NOREPLACE在保留MAP_FIXED功能的同时移除了替换行为：当新请求的映射与现有映射重叠时会失败。ELF加载器已改用此新标志，用户空间也可用于类似场景。&lt;/p&gt;
&lt;h4 id=&#34;exec期间固定栈限制&#34;&gt;exec期间固定栈限制
&lt;/h4&gt;&lt;p&gt;我通过锁定exec期间的RLIMIT_STACK值来彻底解决问题。由于存在多种修改限制的方法（至少包括setrlimit()和prlimit()），以及多个决策点会使用该限制值，最稳妥的方案是在exec生命周期内固定这些值。这应该是exec期间栈限制与内存布局不良交互的最后修复（均为防御Stack Clash类漏洞的举措）。&lt;/p&gt;
&lt;h4 id=&#34;开始移除可变长数组vla&#34;&gt;开始移除可变长数组(VLA)
&lt;/h4&gt;&lt;p&gt;经过对Alexander Popov移植stackleak GCC插件的讨论，Linus Torvalds决定彻底消除内核中的可变长数组。此举能防御多种栈耗尽攻击，包括通过巨型栈分配跨越保护页的奇特攻击。但内核中有数百处VLA使用实例，清理工作艰巨。幸有多位开发者参与贡献，v4.17已解决约1/3的VLA实例，预计v4.19前完全清除。&lt;/p&gt;
&lt;h4 id=&#34;x86系统调用寄存器清零补充说明&#34;&gt;x86系统调用寄存器清零（补充说明）
&lt;/h4&gt;&lt;p&gt;为防范推测执行漏洞，攻击者可能通过&amp;quot;未使用&amp;quot;的寄存器内容向内核泄露信息。由于多数系统调用只需少量参数，Dominik Brodowski将Linus的概念验证扩展为完整的x86系统调用寄存器清零封装。事实证明寄存器清零操作速度极快。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;结语&lt;/strong&gt;&lt;br&gt;
以上为v4.17主要安全更新。如有遗漏欢迎指正。敬请期待v4.18，合并窗口现已开启！&lt;br&gt;
© 2018, Kees Cook. 本文采用CC BY-SA 4.0许可。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
