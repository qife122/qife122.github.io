<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>访问控制 on 办公AI智能小助手</title>
        <link>http://localhost:1313/tags/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</link>
        <description>Recent content in 访问控制 on 办公AI智能小助手</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>qife</copyright>
        <lastBuildDate>Wed, 06 Aug 2025 11:12:50 +0800</lastBuildDate><atom:link href="http://localhost:1313/tags/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>企业安全中的隐形威胁：流氓访问及其治理策略</title>
        <link>http://localhost:1313/p/%E4%BC%81%E4%B8%9A%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E9%9A%90%E5%BD%A2%E5%A8%81%E8%83%81%E6%B5%81%E6%B0%93%E8%AE%BF%E9%97%AE%E5%8F%8A%E5%85%B6%E6%B2%BB%E7%90%86%E7%AD%96%E7%95%A5/</link>
        <pubDate>Wed, 06 Aug 2025 11:12:50 +0800</pubDate>
        
        <guid>http://localhost:1313/p/%E4%BC%81%E4%B8%9A%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E9%9A%90%E5%BD%A2%E5%A8%81%E8%83%81%E6%B5%81%E6%B0%93%E8%AE%BF%E9%97%AE%E5%8F%8A%E5%85%B6%E6%B2%BB%E7%90%86%E7%AD%96%E7%95%A5/</guid>
        <description>&lt;h1 id=&#34;企业安全中的隐形威胁流氓访问&#34;&gt;企业安全中的隐形威胁：流氓访问
&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;流氓访问&lt;/strong&gt;如同企业安全领域的暗物质：通常不可见且被忽视，但若放任不管则蕴含爆炸性风险。该术语指任何绕过正式审批渠道配置的访问权限，或在合法需求终止后仍保留的访问权限。与孤儿账户不同，流氓访问可能仍处于活跃状态甚至关联已知用户，但缺乏适当的所有权归属、合理性证明或追踪机制——这是脱离治理框架的访问行为。&lt;/p&gt;
&lt;p&gt;随着组织完善其身份治理与管理（IGA）策略，解决流氓访问已成为优先事项，尤其在审计、合规审查和零信任架构实施过程中至关重要。&lt;/p&gt;
&lt;h2 id=&#34;访问请求流程与流氓访问的产生节点&#34;&gt;访问请求流程与流氓访问的产生节点
&lt;/h2&gt;&lt;p&gt;在治理完善的企业中，标准访问流程包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;访问请求（通过自助门户或工单）&lt;/li&gt;
&lt;li&gt;审批流程（由管理者、应用/权限所有者或双方共同完成）&lt;/li&gt;
&lt;li&gt;权限配置（自动或手动）&lt;/li&gt;
&lt;li&gt;认证/重新验证（定期确认或权限移除）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;任何偏离该标准流程、缺乏审计追踪或违反策略的访问行为均被标记为流氓访问。其常见产生节点包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;绕过审批流程（管理员手动添加或影子IT操作）&lt;/li&gt;
&lt;li&gt;岗位变动后未及时撤销的遗留权限&lt;/li&gt;
&lt;li&gt;应急访问或项目期间的过度授权&lt;/li&gt;
&lt;li&gt;离职或工作交接时的权限回收失败&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;流氓访问的识别标准&#34;&gt;流氓访问的识别标准
&lt;/h2&gt;&lt;p&gt;通过静态指标与行为特征的组合进行判定：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无关联的访问请求或审批记录&lt;/li&gt;
&lt;li&gt;所有权不匹配（如权限所有者已不在系统内）&lt;/li&gt;
&lt;li&gt;与同岗位/部门成员相比存在异常访问模式&lt;/li&gt;
&lt;li&gt;高权限账户长期无活动（如休眠的root权限）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现代IGA工具（如SailPoint）内置变更工作流，可识别流氓访问并立即启动修复。这些工具还能利用身份图谱和行为分析进行风险评分，自动标记待审项目或执行修复。&lt;/p&gt;
&lt;h2 id=&#34;流氓访问与孤儿账户的共生关系&#34;&gt;流氓访问与孤儿账户的共生关系
&lt;/h2&gt;&lt;p&gt;这两类问题往往相互交织：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;孤儿账户&lt;/strong&gt;：无明确所有者的账户（如承包商遗留的服务账户）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;流氓访问&lt;/strong&gt;：有效用户持有但脱离治理规范的权限（如未经审批手动授予的遗留数据库访问权限）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;二者均违反最小权限和零信任原则。主流IGA平台（SailPoint/Saviynt/Microsoft Entra ID）通过机器学习检测异常访问，实现自动化修复/认证循环。&lt;/p&gt;
&lt;h2 id=&#34;基于风险的层级化治理方案&#34;&gt;基于风险的层级化治理方案
&lt;/h2&gt;&lt;p&gt;识别后应按系统关键性分级处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;高危系统&lt;/strong&gt;（如AD、ERP、云平台）：24-48小时内撤销访问&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中危系统&lt;/strong&gt;（含敏感数据的内部应用）：7-10天处理周期&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;低危系统&lt;/strong&gt;（非关键内容的只读访问）：30天处理周期&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;权限优先级应综合考量特权等级、数据分类和角色关键性。已连接应用可通过SCIM/API触发即时修复，未连接系统则需ITSM工单配合升级机制。&lt;/p&gt;
&lt;h2 id=&#34;合规审计的刚性要求&#34;&gt;合规审计的刚性要求
&lt;/h2&gt;&lt;p&gt;所有主流审计框架均将流氓访问视为危险信号：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;SOX&lt;/strong&gt;：要求金融系统具备明确的审批和基于角色的访问控制&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PCI DSS 4.0&lt;/strong&gt;：强制实施支付环境的最小权限原则&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NIST 800-53&lt;/strong&gt;：强调访问审查、用户问责和权限限制&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ISO 27001&lt;/strong&gt;：关注生命周期访问治理和异常检测&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;现实世界中的典型案例&#34;&gt;现实世界中的典型案例
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Snowflake事件（2024）&lt;/strong&gt;：攻击者利用承包商未受监管的高权限凭证窃取客户数据，这些凭证在治理系统中无记录且长期闲置&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Twitter事件（2020）&lt;/strong&gt;：社会工程攻击利用数十名员工角色变更后遗留的管理权限，暴露生命周期治理的失效&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;结论看见不可见守护企业安全&#34;&gt;结论：看见不可见，守护企业安全
&lt;/h2&gt;&lt;p&gt;流氓访问未必出于恶意，但必然带来风险。它滋生于配置错误、人为失误和流程漏洞的灰色地带，在延迟访问审查或依赖单点认证的环境中尤为猖獗。通过合适的IGA工具、治理策略和风险阈值，企业能在攻击者之前持续检测并处置流氓访问。当今安全领域，忽视不可见威胁绝非选项——那些你看不见的，恰恰可能造成致命伤害。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于作者&lt;/strong&gt;&lt;br&gt;
Durgaprasad Balakrishnan&lt;br&gt;
拥有16年IT治理、风险与合规经验的信息安全经理，曾领导跨国企业的身份与访问管理项目，擅长制定与业务目标协同的安全战略。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Go语言访问控制指南：Java开发者必读</title>
        <link>http://localhost:1313/p/go%E8%AF%AD%E8%A8%80%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%8C%87%E5%8D%97java%E5%BC%80%E5%8F%91%E8%80%85%E5%BF%85%E8%AF%BB/</link>
        <pubDate>Sun, 03 Aug 2025 21:41:56 +0800</pubDate>
        
        <guid>http://localhost:1313/p/go%E8%AF%AD%E8%A8%80%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%8C%87%E5%8D%97java%E5%BC%80%E5%8F%91%E8%80%85%E5%BF%85%E8%AF%BB/</guid>
        <description>&lt;h1 id=&#34;go语言访问控制指南java开发者必读&#34;&gt;Go语言访问控制指南：Java开发者必读
&lt;/h1&gt;&lt;p&gt;Go支持多种编程范式，包括面向对象编程。但如果你从Java转向Go，可能会感到些许&amp;hellip;呃&amp;hellip;不适应。最明显的差异之一是Go完全没有访问修饰符。你可能会疑惑：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我的&lt;code&gt;public&lt;/code&gt;、&lt;code&gt;protected&lt;/code&gt;和&lt;code&gt;private&lt;/code&gt;关键字去哪了？&lt;/li&gt;
&lt;li&gt;Go提供了哪些访问控制机制？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;别担心！Go的访问控制比Java更简单。完全不需要访问修饰符！&lt;/p&gt;
&lt;h2 id=&#34;为什么go只需要两种访问级别&#34;&gt;为什么Go只需要两种访问级别
&lt;/h2&gt;&lt;p&gt;Java提供了四种访问级别，从最严格到最宽松依次是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;private&lt;/code&gt;：仅限同一类内访问&lt;/li&gt;
&lt;li&gt;&lt;code&gt;package-private&lt;/code&gt;：仅限同一包内访问&lt;/li&gt;
&lt;li&gt;&lt;code&gt;protected&lt;/code&gt;：允许同一包及(直接或间接)子类访问&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public&lt;/code&gt;：完全开放访问&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;现在让我们砍掉其中两个！&lt;/p&gt;
&lt;h3 id=&#34;以包为封装单元&#34;&gt;以包为封装单元
&lt;/h3&gt;&lt;p&gt;Go允许定义具体类型（相当于Java的类），但：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;封装的基本单位是包，而不是像其他语言中的类型。
（来源：《Go编程语言》，Donovan &amp;amp; Kernighan，第6.6节）&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;结构体类型的字段对同一包内的所有代码可见。
（同上）&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;因此Go不需要区分&lt;code&gt;private&lt;/code&gt;和&lt;code&gt;package-private&lt;/code&gt;。现在剩下三种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;private&lt;/code&gt;：仅限同一类内访问&lt;/li&gt;
&lt;li&gt;&lt;code&gt;package-private&lt;/code&gt;：仅限同一包内访问&lt;/li&gt;
&lt;li&gt;&lt;code&gt;protected&lt;/code&gt;：允许同一包及子类访问&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public&lt;/code&gt;：完全开放访问&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;没有继承机制&#34;&gt;没有继承机制
&lt;/h3&gt;&lt;p&gt;最重要的是，Go不提供继承机制。因此Go不需要区分&lt;code&gt;package-private&lt;/code&gt;和&lt;code&gt;protected&lt;/code&gt;。最终只剩下两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;private&lt;/code&gt;：仅限同一类内访问&lt;/li&gt;
&lt;li&gt;&lt;code&gt;package-private&lt;/code&gt;：仅限同一包内访问&lt;/li&gt;
&lt;li&gt;&lt;code&gt;protected&lt;/code&gt;：允许同一包及子类访问&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public&lt;/code&gt;：完全开放访问&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;go的访问控制机制&#34;&gt;Go的访问控制机制
&lt;/h2&gt;&lt;p&gt;最终Go只需要两种访问级别：公开和包私有。不过Go的术语与Java不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;导出(exported)：相当于public&lt;/li&gt;
&lt;li&gt;非导出(non-exported)：相当于package-private&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（&amp;ldquo;unexported&amp;quot;是非正式的同义词，但建议使用更正式的&amp;quot;non-exported&amp;rdquo;）&lt;/p&gt;
&lt;p&gt;Go设计者选择用命名约定而非冗长的关键字来控制访问：&lt;/p&gt;
&lt;p&gt;标识符被导出的条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;标识符名称首字母是大写的Unicode字符（Unicode类别&amp;quot;Lu&amp;quot;）&lt;/li&gt;
&lt;li&gt;标识符在包块中声明，或是字段名/方法名&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;（强调部分）&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;foo&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;Bar&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Bar&amp;#34;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 导出&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;baz&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;baz&amp;#34;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 不导出&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;结论&#34;&gt;结论
&lt;/h2&gt;&lt;p&gt;Go的设计追求易读性，其访问控制设计显著提升了代码可读性：不仅摆脱了繁琐的访问修饰符，通过标识符首字母大小写就能判断是否导出。这是阅读Go代码比Java更轻松的原因之一——当然这只是我的个人观点。你怎么看？&lt;/p&gt;
</description>
        </item>
        <item>
        <title>超越私钥风险：智能合约安全成熟度进阶指南</title>
        <link>http://localhost:1313/p/%E8%B6%85%E8%B6%8A%E7%A7%81%E9%92%A5%E9%A3%8E%E9%99%A9%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8%E6%88%90%E7%86%9F%E5%BA%A6%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/</link>
        <pubDate>Sat, 02 Aug 2025 20:14:41 +0800</pubDate>
        
        <guid>http://localhost:1313/p/%E8%B6%85%E8%B6%8A%E7%A7%81%E9%92%A5%E9%A3%8E%E9%99%A9%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8%E6%88%90%E7%86%9F%E5%BA%A6%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/</guid>
        <description>&lt;h1 id=&#34;超越私钥风险智能合约安全成熟度进阶&#34;&gt;超越私钥风险：智能合约安全成熟度进阶
&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&amp;ldquo;找出所有漏洞！&amp;rdquo;&lt;/strong&gt;&lt;br&gt;
这是大多数协议在部署智能合约前的安全口号。团队投入巨资进行审计、竞赛、模糊测试和形式化验证，试图发现每个潜在漏洞。但去年加密货币被盗的最大原因并非智能合约漏洞——而是私钥泄露！&lt;/p&gt;
&lt;h2 id=&#34;私钥攻击已成头号威胁&#34;&gt;私钥攻击已成头号威胁
&lt;/h2&gt;&lt;p&gt;根据Chainalysis 2024年报告，43.8%的被盗资金源于私钥泄露，是其他攻击类型的五倍之多。私钥泄露已成为每个工程师设计新智能合约时必须考虑的新兴威胁。&lt;/p&gt;
&lt;p&gt;传统区块链安全审计往往忽视架构层面的访问控制风险。与其他行业不同，区块链安全评估很少将权限升级和访问控制设计作为核心关注点。Trail of Bits通过代码库成熟度评估标记架构问题，但多数协议直到开发生命周期末期才寻求外部审查。&lt;/p&gt;
&lt;h2 id=&#34;案例研究超额抵押借贷平台&#34;&gt;案例研究：超额抵押借贷平台
&lt;/h2&gt;&lt;p&gt;我们以理论上的超额抵押借贷平台为例，展示不同成熟度的访问控制设计：&lt;/p&gt;
&lt;h3 id=&#34;等级1高风险暴露---单一eoa控制器&#34;&gt;等级1：高风险暴露 - 单一EOA控制器
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;单个外部账户(EOA)控制所有管理功能&lt;/li&gt;
&lt;li&gt;私钥可能存储在联网的软件钱包中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;成熟度等级1&lt;/strong&gt;：单点故障，一旦私钥泄露即导致协议完全沦陷&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;等级2基础缓解---中心化多签&#34;&gt;等级2：基础缓解 - 中心化多签
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;管理权转移至多签钱包（如M-of-N Safe Wallet）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;成熟度等级2&lt;/strong&gt;：需要多个签名，但仍存在单一控制点&lt;/li&gt;
&lt;li&gt;改进：单个签名者密钥泄露不足以致命&lt;/li&gt;
&lt;li&gt;风险：足够多签名者被攻陷仍可立即执行恶意操作&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;等级3增强控制---时间锁与角色分离&#34;&gt;等级3：增强控制 - 时间锁与角色分离
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;实施时间锁合约（执行延迟）和最小权限原则(PoLP)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;成熟度等级3&lt;/strong&gt;：深度防御体系&lt;/li&gt;
&lt;li&gt;典型协议：Aave、Compound Finance、Lido&lt;/li&gt;
&lt;li&gt;关键角色：
&lt;ul&gt;
&lt;li&gt;核心系统角色（合约升级）：高门槛多签+长时间锁&lt;/li&gt;
&lt;li&gt;运营角色（日常配置）：中等时间锁和签名门槛&lt;/li&gt;
&lt;li&gt;暂停监护角色（紧急暂停）：无时间锁+低门槛&lt;/li&gt;
&lt;li&gt;取消监护角色（中止交易）：安全团队控制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;等级4终极形态---彻底不可变与用户主权&#34;&gt;等级4：终极形态 - 彻底不可变与用户主权
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;完全消除管理操作需求&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;成熟度等级4&lt;/strong&gt;：近乎无控制点的不可变系统&lt;/li&gt;
&lt;li&gt;典型协议：Uniswap、Liquity&lt;/li&gt;
&lt;li&gt;设计挑战：
&lt;ul&gt;
&lt;li&gt;合约完全不可升级（需部署新系统）&lt;/li&gt;
&lt;li&gt;资产上架需独立部署新市场&lt;/li&gt;
&lt;li&gt;风险参数永久固定或算法决定&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;优势：彻底消除访问控制风险&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;设计韧性而非被动应对&#34;&gt;设计韧性而非被动应对
&lt;/h2&gt;&lt;p&gt;2024年43.8%的被盗资金证明，忽视架构级访问控制已不可接受。建议立即行动：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对照成熟度框架评估当前协议&lt;/li&gt;
&lt;li&gt;为高风险功能实施时间锁并确保监控&lt;/li&gt;
&lt;li&gt;按最小权限原则划分特权功能&lt;/li&gt;
&lt;li&gt;考虑部分组件采用等级4不可变模式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在Trail of Bits，我们提倡这种安全整体观。通过设计审查和早期咨询等服务，帮助团队主动解决这些基础问题。构建安全的去中心化系统不仅需要漏洞狩猎，更需从第一天就开始设计运营韧性。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>ServiceNow管理员注意：立即修复访问控制列表漏洞</title>
        <link>http://localhost:1313/p/servicenow%E7%AE%A1%E7%90%86%E5%91%98%E6%B3%A8%E6%84%8F%E7%AB%8B%E5%8D%B3%E4%BF%AE%E5%A4%8D%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%88%97%E8%A1%A8%E6%BC%8F%E6%B4%9E/</link>
        <pubDate>Sat, 02 Aug 2025 05:44:03 +0800</pubDate>
        
        <guid>http://localhost:1313/p/servicenow%E7%AE%A1%E7%90%86%E5%91%98%E6%B3%A8%E6%84%8F%E7%AB%8B%E5%8D%B3%E4%BF%AE%E5%A4%8D%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%88%97%E8%A1%A8%E6%BC%8F%E6%B4%9E/</guid>
        <description>&lt;h1 id=&#34;warning-to-servicenow-admins-fix-your-access-control-lists-now&#34;&gt;Warning to ServiceNow admins: Fix your access control lists now
&lt;/h1&gt;&lt;p&gt;安全厂商警告称，ServiceNow管理用户访问控制列表(ACL)的方式存在漏洞，攻击者可轻松窃取敏感数据。研究人员敦促管理员立即检查自定义和标准数据配置表以加强安全防护。&lt;/p&gt;
&lt;p&gt;Varonis研究人员一年前就向ServiceNow报告了这个漏洞，使其能够悄悄修补平台并在5月向客户发布安全更新。随着ServiceNow本周发布通用漏洞披露(CVE-2025-3648)，Varonis公开了漏洞细节。&lt;/p&gt;
&lt;p&gt;IDC总裁Crawford Del Prete表示：&amp;ldquo;ServiceNow的更新修复了可能允许低权限用户访问受限数据的漏洞。考虑到ServiceNow处理的数据类型，这种情况总是可能很严重。&amp;rdquo;&lt;/p&gt;
&lt;p&gt;Forrester Research企业架构首席分析师Charles Betz称这是&amp;quot;相当严重的漏洞&amp;quot;，敦促管理员&amp;quot;立即采取行动&amp;quot;。他指出：&amp;ldquo;随着CVE公开，攻击者很可能开始针对这些数据。&amp;rdquo;&lt;/p&gt;
&lt;h2 id=&#34;漏洞技术细节&#34;&gt;漏洞技术细节
&lt;/h2&gt;&lt;p&gt;该访问控制漏洞允许未经认证或已认证用户在某些条件下通过查询请求访问未授权数据。Varonis安全研究经理Yogev Madar指出，攻击者可以利用以下方式实施攻击：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;仅依赖数据或脚本条件的ACL可能被滥用&lt;/li&gt;
&lt;li&gt;未使用新的&amp;quot;Deny else&amp;quot;ACL机制&lt;/li&gt;
&lt;li&gt;未应用Query ACL规则限制查询操作符&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ServiceNow已在Xanadu和Yokohama平台版本中引入额外的访问控制列表框架。Varonis在博客中表示：&amp;ldquo;该漏洞相对容易利用，只需要最小的表访问权限，如实例中的弱用户账户甚至自注册匿名用户。&amp;rdquo;&lt;/p&gt;
&lt;h2 id=&#34;数据存储架构风险&#34;&gt;数据存储架构风险
&lt;/h2&gt;&lt;p&gt;ServiceNow将所有信息组织到表中，包括事件、请求、实例属性、用户数据、应用凭证等。这些表通过引用字段相互关联，而访问主要通过ACL规则控制。一个ServiceNow实例可能包含数万个ACL规则。&lt;/p&gt;
&lt;p&gt;ACL规则包含四个访问条件，按以下顺序评估：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;必需角色&lt;/li&gt;
&lt;li&gt;安全属性条件&lt;/li&gt;
&lt;li&gt;数据条件&lt;/li&gt;
&lt;li&gt;脚本条件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Varonis发现，如果访问因前两个条件被拒绝，系统会完全拒绝访问；但如果因数据或脚本条件被拒，用户仍能看到查询返回的记录总数，攻击者可利用查询参数通过枚举推断详细数据。&lt;/p&gt;
&lt;h2 id=&#34;修复建议&#34;&gt;修复建议
&lt;/h2&gt;&lt;p&gt;ServiceNow提供了新的ACL规则供管理员实施：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Query ACL：限制用户可执行的查询&lt;/li&gt;
&lt;li&gt;新的安全数据过滤器：基于角色或安全属性限制记录访问&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Reco首席产品官Gal Nakash强调：&amp;ldquo;这提醒我们即使成熟平台在访问控制方面也可能存在危险盲点。组织必须采用&amp;rsquo;最小权限&amp;rsquo;原则配置ACL，绝不能让角色和安全属性留空或过于宽泛。&amp;rdquo;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
