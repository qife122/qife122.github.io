<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Linux内核 on 办公AI智能小助手</title>
        <link>http://localhost:1313/tags/linux%E5%86%85%E6%A0%B8/</link>
        <description>Recent content in Linux内核 on 办公AI智能小助手</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>qife</copyright>
        <lastBuildDate>Tue, 05 Aug 2025 20:38:24 +0800</lastBuildDate><atom:link href="http://localhost:1313/tags/linux%E5%86%85%E6%A0%B8/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Linux内核Cgroup BPF Use-After-Free漏洞分析：CVE-2020-14356与CVE-2020-25220</title>
        <link>http://localhost:1313/p/linux%E5%86%85%E6%A0%B8cgroup-bpf-use-after-free%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90cve-2020-14356%E4%B8%8Ecve-2020-25220/</link>
        <pubDate>Tue, 05 Aug 2025 20:38:24 +0800</pubDate>
        
        <guid>http://localhost:1313/p/linux%E5%86%85%E6%A0%B8cgroup-bpf-use-after-free%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90cve-2020-14356%E4%B8%8Ecve-2020-25220/</guid>
        <description>&lt;h2 id=&#34;漏洞背景&#34;&gt;漏洞背景
&lt;/h2&gt;&lt;p&gt;2019年Tejun Heo发现cgroup_bpf生命周期存在的竞态条件问题（可能导致双重释放）。该漏洞在5.3内核中被修复。随后Roman Gushchin发现修复代码存在新的Use-After-Free问题。&lt;/p&gt;
&lt;h2 id=&#34;漏洞细节&#34;&gt;漏洞细节
&lt;/h2&gt;&lt;p&gt;在LKRG开发测试期间发现内核崩溃，回溯显示问题出现在&lt;code&gt;__cgroup_bpf_run_filter_skb&lt;/code&gt;函数中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;mh&#34;&gt;0xffffffff9423e801&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;__cgroup_bpf_run_filter_skb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;401&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;mh&#34;&gt;0x10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rax&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rdi&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;此时RAX寄存器可能为NULL或已释放内存（0x6b6b6b6b6b6b6b6b）。崩溃触发路径为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;do_exit -&amp;gt; sock_close -&amp;gt; __sock_release -&amp;gt; inet_release -&amp;gt; tcp_close 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-&amp;gt; __tcp_push_pending_frames -&amp;gt; tcp_write_xmit -&amp;gt; __tcp_transmit_skb 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-&amp;gt; __ip_queue_xmit -&amp;gt; ip_finish_output -&amp;gt; __cgroup_bpf_run_filter_skb
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;关键问题在于：当net_prio/net_cls被激活时，cgroup2 socket匹配会被禁用，但已存在的socket仍保留对已销毁cgroup的引用。&lt;/p&gt;
&lt;h2 id=&#34;漏洞验证&#34;&gt;漏洞验证
&lt;/h2&gt;&lt;p&gt;通过内核日志可观察到以下关键事件序列：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;cgroup: disabling cgroup2 socket matching due to net_prio or net_cls activation&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;percpu ref (cgroup_bpf_release_fn) &amp;lt;= 0 after switching to atomic&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;最终触发UAF崩溃&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;cve-2020-14356&#34;&gt;CVE-2020-14356
&lt;/h2&gt;&lt;p&gt;原始漏洞修复补丁&lt;code&gt;ad0f75e5f57c&lt;/code&gt;（需配合&lt;code&gt;14b032b8f8fc&lt;/code&gt;）主要修改了：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;cgroup_sk_clone&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sock_cgroup_data&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;skcd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;skcd&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;skcd&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;no_refcnt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 新增检查
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;cgroup_get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;sock_cgroup_ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;skcd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;cgroup_bpf_get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;sock_cgroup_ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;skcd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;cve-2020-25220&#34;&gt;CVE-2020-25220
&lt;/h2&gt;&lt;p&gt;在LTS内核（4.14/4.19/4.9）的补丁中遗漏了关键检查：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;skcd&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;no_refcnt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;导致引用计数错误，可能再次引发UAF。该问题后续由华为工程师提交正确修复。&lt;/p&gt;
&lt;h2 id=&#34;影响范围&#34;&gt;影响范围
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;CVE-2020-14356：影响Linux内核4.5+至5.7.10&lt;/li&gt;
&lt;li&gt;CVE-2020-25220：影响特定LTS版本：
&lt;ul&gt;
&lt;li&gt;4.19 &amp;lt; 4.19.140&lt;/li&gt;
&lt;li&gt;4.14 &amp;lt; 4.14.194&lt;/li&gt;
&lt;li&gt;4.9 &amp;lt; 4.9.233&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Linux内核v4.17安全特性解析：从内存保护到系统调用加固</title>
        <link>http://localhost:1313/p/linux%E5%86%85%E6%A0%B8v4.17%E5%AE%89%E5%85%A8%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90%E4%BB%8E%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4%E5%88%B0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8A%A0%E5%9B%BA/</link>
        <pubDate>Tue, 05 Aug 2025 01:15:44 +0800</pubDate>
        
        <guid>http://localhost:1313/p/linux%E5%86%85%E6%A0%B8v4.17%E5%AE%89%E5%85%A8%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90%E4%BB%8E%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4%E5%88%B0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8A%A0%E5%9B%BA/</guid>
        <description>&lt;h3 id=&#34;linux内核v417的安全特性&#34;&gt;Linux内核v4.17的安全特性
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;先前版本&lt;/strong&gt;：v4.16&lt;br&gt;
Linux内核v4.17于上周发布，以下是我认为值得关注的安全改进：&lt;/p&gt;
&lt;h4 id=&#34;jailhouse管理程序&#34;&gt;Jailhouse管理程序
&lt;/h4&gt;&lt;p&gt;Jan Kiszka引入了Jailhouse管理程序支持，采用静态分区技术（即不进行资源超分配）。根&amp;quot;单元&amp;quot;通过缩减自身的CPU/内存等资源来创建新隔离区，并将资源移交给新隔离区。LWN在2014年对该管理程序有详细报道。&lt;/p&gt;
&lt;h4 id=&#34;sparc-adi支持&#34;&gt;SPARC ADI支持
&lt;/h4&gt;&lt;p&gt;Khalid Aziz实现了SPARC应用数据完整性（ADI或称SSM：硅安全内存）的用户空间支持，这是SPARC M7处理器的硬件内存着色（标记）功能。该技术能有效防御线性溢出攻击，因为基指针被标记为仅属于特定内存分配区域（大小与缓存行对齐）。任何尝试越界访问不同标记内存的操作都会触发异常。Enrico Perla撰写了关于ADI在分配器中的应用及其与Intel MPX的对比分析。&lt;/p&gt;
&lt;h4 id=&#34;fork时清零新内核栈&#34;&gt;fork时清零新内核栈
&lt;/h4&gt;&lt;p&gt;此前新进程的内核栈可能残留旧内存内容。虽然通常不可见，但&amp;quot;未初始化&amp;quot;内存读取缺陷或读取溢出可能暴露这些内容（尤其是栈深处可能永远不被覆盖的数据）。为此我确保新栈始终被清零。有趣的是，这种缓存&amp;quot;预热&amp;quot;反而提升了性能，尽管差异微小。&lt;/p&gt;
&lt;h4 id=&#34;map_fixed_noreplace&#34;&gt;MAP_FIXED_NOREPLACE
&lt;/h4&gt;&lt;p&gt;为防御Stack Clash等攻击，Michal Hocko创建了MAP_FIXED_NOREPLACE。常规MAP_FIXED存在一个易被忽视的危险行为：它会替换任何重叠的现有映射。这意味着内核可能悄无声息地将栈重叠到mmap或代码区域。而MAP_FIXED_NOREPLACE在保留MAP_FIXED功能的同时移除了替换行为：当新请求的映射与现有映射重叠时会失败。ELF加载器已改用此新标志，用户空间也可用于类似场景。&lt;/p&gt;
&lt;h4 id=&#34;exec期间固定栈限制&#34;&gt;exec期间固定栈限制
&lt;/h4&gt;&lt;p&gt;我通过锁定exec期间的RLIMIT_STACK值来彻底解决问题。由于存在多种修改限制的方法（至少包括setrlimit()和prlimit()），以及多个决策点会使用该限制值，最稳妥的方案是在exec生命周期内固定这些值。这应该是exec期间栈限制与内存布局不良交互的最后修复（均为防御Stack Clash类漏洞的举措）。&lt;/p&gt;
&lt;h4 id=&#34;开始移除可变长数组vla&#34;&gt;开始移除可变长数组(VLA)
&lt;/h4&gt;&lt;p&gt;经过对Alexander Popov移植stackleak GCC插件的讨论，Linus Torvalds决定彻底消除内核中的可变长数组。此举能防御多种栈耗尽攻击，包括通过巨型栈分配跨越保护页的奇特攻击。但内核中有数百处VLA使用实例，清理工作艰巨。幸有多位开发者参与贡献，v4.17已解决约1/3的VLA实例，预计v4.19前完全清除。&lt;/p&gt;
&lt;h4 id=&#34;x86系统调用寄存器清零补充说明&#34;&gt;x86系统调用寄存器清零（补充说明）
&lt;/h4&gt;&lt;p&gt;为防范推测执行漏洞，攻击者可能通过&amp;quot;未使用&amp;quot;的寄存器内容向内核泄露信息。由于多数系统调用只需少量参数，Dominik Brodowski将Linus的概念验证扩展为完整的x86系统调用寄存器清零封装。事实证明寄存器清零操作速度极快。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;结语&lt;/strong&gt;&lt;br&gt;
以上为v4.17主要安全更新。如有遗漏欢迎指正。敬请期待v4.18，合并窗口现已开启！&lt;br&gt;
© 2018, Kees Cook. 本文采用CC BY-SA 4.0许可。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Linux内核v4.15安全技术深度解析</title>
        <link>http://localhost:1313/p/linux%E5%86%85%E6%A0%B8v4.15%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</link>
        <pubDate>Sun, 03 Aug 2025 10:07:35 +0800</pubDate>
        
        <guid>http://localhost:1313/p/linux%E5%86%85%E6%A0%B8v4.15%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</guid>
        <description>&lt;h1 id=&#34;linux内核v415安全技术解析&#34;&gt;Linux内核v4.15安全技术解析
&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;发布日期&lt;/strong&gt;：2018年2月5日&lt;br&gt;
&lt;strong&gt;分类&lt;/strong&gt;：Chrome OS, Debian, 内核, 安全, Ubuntu, Ubuntu-Server&lt;/p&gt;
&lt;p&gt;[前情提要：v4.14版本]&lt;/p&gt;
&lt;p&gt;上周发布的Linux内核v4.15包含多项重要安全改进：&lt;/p&gt;
&lt;h2 id=&#34;内核页表隔离pti&#34;&gt;内核页表隔离(PTI)
&lt;/h2&gt;&lt;p&gt;虽然PTI已获广泛报道，但简而言之，它主要用于防御CPU缓存时序侧信道攻击（CVE-2017-5754，即推测执行的&amp;quot;恶意数据缓存加载&amp;quot;或&amp;quot;Meltdown&amp;quot;漏洞）。x86_64架构（通过CONFIG_PAGE_TABLE_ISOLATION配置）的PTI实现涉及大量工作，数十人参与开发数月。PowerPC也已加入缓解措施，arm64（通过CONFIG_UNMAP_KERNEL_AT_EL0配置）将在v4.16支持PTI（仅Cortex-A75受影响）。x86_32架构的支持正在开发中。&lt;/p&gt;
&lt;p&gt;x86_64 PTI的额外优势是：由于现在存在两份页表副本，内核模式的用户空间映射可完全标记为不可执行，这意味着前SMEP硬件现在获得SMEP模拟功能。试图跳转到用户空间内存继续执行恶意代码的内核攻击将失效（即使攻击者先关闭了SMEP）。通过进一步工作，还可引入SMAP模拟（阻止读取恶意用户空间内存），从而关闭这些常见攻击向量。值得注意的是，arm64自v4.10起就具备等效功能（PAN模拟）。&lt;/p&gt;
&lt;h2 id=&#34;retpoline防御机制&#34;&gt;Retpoline防御机制
&lt;/h2&gt;&lt;p&gt;除PTI外，针对CVE-2017-5715（&amp;ldquo;分支目标注入&amp;quot;或&amp;quot;Spectre变种2&amp;rdquo;）的retpoline内核缓解措施开始落地。（注意：要获得完整retpoline支持，需要打补丁的编译器，如gcc 7.3/8+版本，目前clang也已排队等待发布。）&lt;/p&gt;
&lt;p&gt;这项工作仍在演进，清理工作将持续到v4.16。v4.16还将包含针对其他推测执行变种（CVE-2017-5753，&amp;ldquo;边界检查绕过&amp;quot;或&amp;quot;Spectre变种1&amp;rdquo;）的缓解措施。&lt;/p&gt;
&lt;h2 id=&#34;x86快速refcount_t溢出保护&#34;&gt;x86快速refcount_t溢出保护
&lt;/h2&gt;&lt;p&gt;v4.13引入了CONFIG_REFCOUNT_FULL代码来阻止多种引用计数缺陷（伴随微小性能损失）。v4.14为x86快速溢出专用refcount_t保护（基于grsecurity的PAX_REFCOUNT）奠定了基础，但因bug推迟到v4.15修复。由于改动很小，快速refcount_t保护已反向移植并在长期维护内核v4.14.5中启用。从atomic_t到refcount_t的转换持续进行，目前已超过168处，仅剩少量待转换。&lt;/p&gt;
&lt;h2 id=&#34;p地址哈希化&#34;&gt;%p地址哈希化
&lt;/h2&gt;&lt;p&gt;内核信息泄露的众多来源之一是%p格式说明符。这些字符串最终出现在各种位置（dmesg、/sys文件、/proc文件等），且使用分散在整个内核中，使其成为难以修复的泄露源。早期像kptr_restrict的%pK这样的方案效果有限，因为它是选择加入的。虽然最近有人尝试（如William C Roberts、Greg KH等）提供让%p像%pK一样工作的开关，但Linus最终介入并声明%p应该极少使用以至于根本不该使用。Tobin Harding承担了寻找正确路径的任务，最终实现用每启动随机密钥对%p输出进行哈希处理。结果是简单调试仍可工作（相同哈希值的两个报告可以确认相同地址而不泄露实际地址），但阻碍了攻击者利用此类信息泄露作为漏洞利用构建块的能力。&lt;/p&gt;
&lt;p&gt;对于需要未哈希%p的开发者，引入了%px，但如Linus警告：要么你的%p在哈希后仍有用，要么你的%p原本就无用应该删除，要么你需要用合理权限充分证明使用%px的正当性。&lt;/p&gt;
&lt;h2 id=&#34;timer_list结构重构&#34;&gt;timer_list结构重构
&lt;/h2&gt;&lt;p&gt;内核定时器（struct timer_list）基础设施用于创建在特定时间后执行的回调。作为内核更基础的部分之一，它已存在很长时间，有超过1000个调用点。虽然API随时间改进，但旧方式仍然存在。现代内核回调接收指向与回调关联结构的参数，以便回调知道哪个实例被触发。定时器回调没有这样做，而是接收unsigned long参数，该参数被强制转换回代码设置定时器时想要关联回调的任何上下文，并且该变量与回调函数指针一起存储在struct timer_list中。这为试图利用内存破坏漏洞（如堆溢出）的攻击者创造了机会，他们不仅能覆盖函数指针，还能覆盖内存中存储的参数。这将攻击提升为弱ROP，并已被用作现代漏洞利用中禁用SMEP的基础（参见retire_blk_timer）。为消除内核设计中的这一弱点，我重构了定时器回调API及其所有调用者，改动规模达：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1128 files changed, 4834 insertions(+), 5926 deletions(-)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;重构的另一好处是：一旦内核开始由支持控制流完整性(CFI)的编译器构建，定时器回调将不会与所有其他接收单个unsigned long参数的函数混为一谈。（换句话说，某些CFI实现不会捕获上述攻击，因为攻击者的目标函数仍匹配其原始原型。）&lt;/p&gt;
&lt;p&gt;目前就这些；如有遗漏请告知。v4.16合并窗口现已开启！&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;评论精选&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Nick提问&lt;/strong&gt;：关于KPTI，是否建议为AMD CPU启用？特别是考虑到KPTI本应更好地保护KASLR，而且用户空间和内核空间的分离本质上更好，尽管有性能损失。&lt;br&gt;
&lt;strong&gt;kees回复&lt;/strong&gt;：对于没有SMEP的CPU，我建议无条件保持KPTI开启。对于SMEP机器，我仍会启用它，因为它为各种缓存时序攻击（包括许多常见的KASLR泄漏）提供了良好的隔离。最终取决于你的工作负载。如果能承受微小性能变化，就启用它。&lt;br&gt;
&lt;strong&gt;Nick补充&lt;/strong&gt;：这也是我的第一想法，在安全方面不做半吊子措施。即使AMD CPU默认排除在KPTI之外。可以预期未来会有进一步优化来减少KPTI性能损失。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;许可声明&lt;/strong&gt;：本文采用知识共享署名-相同方式共享4.0国际许可协议授权。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
