<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>区块链安全 on 办公AI智能小助手</title>
        <link>http://localhost:1313/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8/</link>
        <description>Recent content in 区块链安全 on 办公AI智能小助手</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>qife</copyright>
        <lastBuildDate>Sun, 03 Aug 2025 04:42:16 +0800</lastBuildDate><atom:link href="http://localhost:1313/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Trail of Bits 2020冬季实习项目亮点：从反编译器到智能合约安全</title>
        <link>http://localhost:1313/p/trail-of-bits-2020%E5%86%AC%E5%AD%A3%E5%AE%9E%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%BA%AE%E7%82%B9%E4%BB%8E%E5%8F%8D%E7%BC%96%E8%AF%91%E5%99%A8%E5%88%B0%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8/</link>
        <pubDate>Sun, 03 Aug 2025 04:42:16 +0800</pubDate>
        
        <guid>http://localhost:1313/p/trail-of-bits-2020%E5%86%AC%E5%AD%A3%E5%AE%9E%E4%B9%A0%E9%A1%B9%E7%9B%AE%E4%BA%AE%E7%82%B9%E4%BB%8E%E5%8F%8D%E7%BC%96%E8%AF%91%E5%99%A8%E5%88%B0%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8/</guid>
        <description>&lt;h3 id=&#34;aaron-yoo--anvill反编译器&#34;&gt;Aaron Yoo — Anvill反编译器
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;加州大学洛杉矶分校&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我在Anvill反编译器中添加了一个生成LLVM位码函数&amp;quot;JSON规范&amp;quot;的工具。这些规范告知Anvill函数参数和返回值等重要值的物理位置（寄存器或内存）。典型规范示例如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;arch&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;amd64&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;functions&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;demangled_name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;test(long, long)&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;_Z4testll&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;parameters&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                    &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;param1&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                    &lt;span class=&#34;nt&#34;&gt;&amp;#34;register&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;RDI&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                    &lt;span class=&#34;nt&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;l&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;通过该项目，我深入了解了ABI规范，并解决了高级参数分散在多个机器寄存器中的技术难题。&lt;/p&gt;
&lt;h3 id=&#34;paweł-płatek--deepstate与python&#34;&gt;Paweł Płatek — DeepState与Python
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;AGH科技大学&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我主要修复了DeepState Python部分的构建问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CMake&lt;/strong&gt;：修正构建选项，增加仅构建示例的选项&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Docker&lt;/strong&gt;：采用多阶段构建，支持Honggfuzz和Angora&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;模糊测试执行器&lt;/strong&gt;：统一参数处理，重新实现日志系统和运行时统计&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;测试体系&lt;/strong&gt;：创建基础测试用例验证执行器功能&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;文档&lt;/strong&gt;：拆分文档结构，新增模糊测试使用指南&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;philip-zhengyuan-wang--manticore&#34;&gt;Philip Zhengyuan Wang — Manticore
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;马里兰大学&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我开发了&amp;quot;mcorepv&amp;quot;工具实现Manticore的云化部署：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过Ansible自动配置DigitalOcean云主机&lt;/li&gt;
&lt;li&gt;使用Protobuf协议实时传输分析状态&lt;/li&gt;
&lt;li&gt;开发终端用户界面(TUI)监控运行状态&lt;/li&gt;
&lt;li&gt;实现工作目录自动同步和日志回传&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当前待解决问题包括SSH端口转发优化和TUI信息展示改进。&lt;/p&gt;
&lt;h3 id=&#34;samuel-caccavale--go代码分析&#34;&gt;Samuel Caccavale — Go代码分析
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;东北大学&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;开发基于AST和SSA的Go代码扫描器，可检测以下模式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 危险的类型断言使用&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;相比GoSec等工具，能更精确识别类型断言值的上下文使用安全。&lt;/p&gt;
&lt;h3 id=&#34;taylor-pothast--mishegos&#34;&gt;Taylor Pothast — Mishegos
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;范德堡大学&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将x86_64解码器模糊测试工具Mishegos的输出格式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从JSON改为紧凑二进制格式&lt;/li&gt;
&lt;li&gt;开发mish2jsonl转换工具保持向后兼容&lt;/li&gt;
&lt;li&gt;更新分析工具处理新增的符号字段&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;thomas-quig--crytic与slither&#34;&gt;Thomas Quig — Crytic与Slither
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;伊利诺伊大学香槟分校&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将Slither的智能合约升级检查集成到Crytic CI服务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现合约版本选择界面&lt;/li&gt;
&lt;li&gt;检查代理合约模式的风险点（如存储变量对齐）&lt;/li&gt;
&lt;li&gt;输出标准化JSON格式的检测结果&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;william-wang--openssl与anselm&#34;&gt;William Wang — OpenSSL与Anselm
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;加州大学洛杉矶分校&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;开发OpenSSL API误用检测工具Anselm：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编写LLVM Pass构建API调用图&lt;/li&gt;
&lt;li&gt;实现基础启发式规则（如密码上下文初始化检查）&lt;/li&gt;
&lt;li&gt;支持跨语言OpenSSL绑定分析&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;未来计划增强参数/返回值分析能力，完善开发者接口。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>揭秘Aave可升级合约漏洞 - 代理模式下的致命缺陷</title>
        <link>http://localhost:1313/p/%E6%8F%AD%E7%A7%98aave%E5%8F%AF%E5%8D%87%E7%BA%A7%E5%90%88%E7%BA%A6%E6%BC%8F%E6%B4%9E-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E8%87%B4%E5%91%BD%E7%BC%BA%E9%99%B7/</link>
        <pubDate>Sat, 02 Aug 2025 21:04:25 +0800</pubDate>
        
        <guid>http://localhost:1313/p/%E6%8F%AD%E7%A7%98aave%E5%8F%AF%E5%8D%87%E7%BA%A7%E5%90%88%E7%BA%A6%E6%BC%8F%E6%B4%9E-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E8%87%B4%E5%91%BD%E7%BC%BA%E9%99%B7/</guid>
        <description>&lt;h1 id=&#34;breaking-aave-upgradeability&#34;&gt;Breaking Aave Upgradeability
&lt;/h1&gt;&lt;p&gt;2020年12月3日，Aave部署了其代码库的V2版本。虽然我们未被雇佣进行代码审计，但在次日我们对其进行了简要检查。我们迅速发现了一个同时影响V1和V2线上合约的漏洞并立即报告。Aave团队在收到分析报告后一小时内就修复了该漏洞。若被利用，该漏洞将摧毁Aave系统并影响外部DeFi合约中的资金。&lt;/p&gt;
&lt;p&gt;尽管有五家安全公司（包括使用形式化验证的机构）审计过Aave代码库，但此漏洞仍被遗漏。本文将详述该漏洞原理、为何未被发现以及经验教训。同时我们开源了新的Slither检测器以提升以太坊生态安全性。&lt;/p&gt;
&lt;h2 id=&#34;漏洞原理&#34;&gt;漏洞原理
&lt;/h2&gt;&lt;p&gt;Aave使用了我们此前多次讨论的delegatecall代理模式。该模式将组件分为：1)包含实现逻辑的逻辑合约；2)包含数据并通过delegatecall与逻辑合约交互的代理合约。用户与代理合约交互，而代码在逻辑合约执行。以下是简化示意图：&lt;/p&gt;
&lt;p&gt;在Aave中，LendingPool(LendingPool.sol)是采用delegatecall代理的可升级组件。该漏洞依赖两个关键特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;逻辑合约的函数（包括初始化函数）可直接调用&lt;/li&gt;
&lt;li&gt;借贷池自身具有delegatecall能力&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;可升级合约初始化&#34;&gt;可升级合约初始化
&lt;/h2&gt;&lt;p&gt;这种升级模式的限制在于代理合约无法依赖逻辑合约的构造函数进行初始化。因此状态变量和初始设置必须在公开的初始化函数中完成，这些函数无法享受构造函数的保护机制。&lt;/p&gt;
&lt;p&gt;在LendingPool中，initialize函数设置provider地址(_addressesProvider)：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;initialize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ILendingPoolAddressesProvider&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;provider&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;initializer&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;_addressesProvider&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;provider&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;initializer修饰符防止多次调用initialize，要求满足以下条件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;require&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;initializing&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;isConstructor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;revision&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lastInitializedRevision&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;s&#34;&gt;&amp;#39;Contract instance has already been initialized&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;initializing允许同一交易内多次调用&lt;/li&gt;
&lt;li&gt;isConstructor()供代理合约执行代码所需&lt;/li&gt;
&lt;li&gt;revision &amp;gt; lastInitializedRevision允许合约升级时再次调用初始化函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过代理调用时工作正常，但第三条也允许任何人直接调用逻辑合约的initialize函数。当逻辑合约部署后：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;revision为0x2&lt;/li&gt;
&lt;li&gt;lastInitializedRevision为0x0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;漏洞本质&lt;/strong&gt;：任何人都能设置LendingPool逻辑合约的_addressesProvider。&lt;/p&gt;
&lt;h2 id=&#34;任意delegatecall&#34;&gt;任意delegatecall
&lt;/h2&gt;&lt;p&gt;LendingPool.liquidationCall直接delegatecall到_addressProvider返回的地址：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;address&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;collateralManager&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_addressesProvider&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getLendingPoolCollateralManager&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;success&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bytes&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;memory&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;collateralManager&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;delegatecall&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nb&#34;&gt;abi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;encodeWithSignature&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s&#34;&gt;&amp;#39;liquidationCall(address,address,address,uint256,bool)&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;collateralAsset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;debtAsset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;user&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;debtToCover&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;receiveAToken&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这使得攻击者可：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化LendingPool逻辑合约&lt;/li&gt;
&lt;li&gt;设置受控的addresses provider&lt;/li&gt;
&lt;li&gt;执行任意代码（包括selfdestruct）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;攻击场景&lt;/strong&gt;：任何人都能销毁借贷池逻辑合约。简化示意图如下：&lt;/p&gt;
&lt;h2 id=&#34;存在性检查缺失&#34;&gt;存在性检查缺失
&lt;/h2&gt;&lt;p&gt;该漏洞本身已足够严重（可类比Parity事件）。但OpenZeppelin代理合约的使用放大了危害。我们2018年的博文曾指出：对空合约的delegatecall会返回success但不会执行任何代码。尽管有此警告，OpenZeppelin仍未修复其代理合约的回退函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;_delegate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;address&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;implementation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;internal&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;assembly&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;calldatacopy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;calldatasize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;ow&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;delegatecall&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;gas&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;implementation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;calldatasize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;若代理合约delegatecall到已被销毁的逻辑合约，代理将返回success但实际未执行任何代码。虽然Aave可通过更新代理指向新逻辑合约来修复，但在漏洞存在期间，任何第三方合约调用借贷池时都会误认为代码已执行。&lt;/p&gt;
&lt;h2 id=&#34;受影响合约&#34;&gt;受影响合约
&lt;/h2&gt;&lt;p&gt;所有AToken：用户燃烧AToken但无法取回底层资产
WETHGateway：存款会存储在网关中导致资产被盗
基于Aave Credit Delegation v2的所有代码库
其他受影响的外部合约包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DefiSaver v1/v2&lt;/li&gt;
&lt;li&gt;PieDao等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这凸显了DeFi可组合性的潜在风险。&lt;/p&gt;
&lt;h2 id=&#34;修复建议&#34;&gt;修复建议
&lt;/h2&gt;&lt;p&gt;幸运的是漏洞在被利用前就被修复。Aave调用了两个版本借贷池的initialize函数进行加固：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;V1修复时间：2020-12-04 19:34:26 UTC&lt;/li&gt;
&lt;li&gt;V2修复时间：2020-12-04 19:53:00 UTC&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;长期建议：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在所有逻辑合约中添加构造函数禁用initialize函数&lt;/li&gt;
&lt;li&gt;在代理合约的回退函数中添加合约存在性检查&lt;/li&gt;
&lt;li&gt;仔细审查delegatecall陷阱并使用slither-check-upgradeability&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;形式化验证非万能&#34;&gt;形式化验证非万能
&lt;/h2&gt;&lt;p&gt;Aave代码库经过&amp;quot;形式化验证&amp;quot;，但该漏洞证明安全属性并非绝对。验证报告中的属性（如操作成功时返回true不回滚）在逻辑合约被销毁时就会失效。可能原因包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;验证未考虑可升级性&lt;/li&gt;
&lt;li&gt;验证工具不支持复杂合约交互&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;形式化技术虽好，但需注意其覆盖范围有限。相比之下，自动化工具（如Slither）和人工审计能以较少资源实现更高安全保证。&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论
&lt;/h2&gt;&lt;p&gt;Aave反应迅速值得肯定，但其他项目就没这么幸运。我们建议开发者在部署前：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;参考我们的安全清单和培训材料&lt;/li&gt;
&lt;li&gt;将Slither加入CI流程并检查所有报告&lt;/li&gt;
&lt;li&gt;给予安全团队充足的审计时间&lt;/li&gt;
&lt;li&gt;谨慎处理可升级性，至少阅读相关反模式文档&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们通过公开此漏洞和Slither检测器希望预防类似错误。安全是持续过程，建议项目启动前联系我们进行安全审计。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>超越私钥风险：智能合约安全成熟度进阶指南</title>
        <link>http://localhost:1313/p/%E8%B6%85%E8%B6%8A%E7%A7%81%E9%92%A5%E9%A3%8E%E9%99%A9%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8%E6%88%90%E7%86%9F%E5%BA%A6%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/</link>
        <pubDate>Sat, 02 Aug 2025 20:14:41 +0800</pubDate>
        
        <guid>http://localhost:1313/p/%E8%B6%85%E8%B6%8A%E7%A7%81%E9%92%A5%E9%A3%8E%E9%99%A9%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8%E6%88%90%E7%86%9F%E5%BA%A6%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/</guid>
        <description>&lt;h1 id=&#34;超越私钥风险智能合约安全成熟度进阶&#34;&gt;超越私钥风险：智能合约安全成熟度进阶
&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&amp;ldquo;找出所有漏洞！&amp;rdquo;&lt;/strong&gt;&lt;br&gt;
这是大多数协议在部署智能合约前的安全口号。团队投入巨资进行审计、竞赛、模糊测试和形式化验证，试图发现每个潜在漏洞。但去年加密货币被盗的最大原因并非智能合约漏洞——而是私钥泄露！&lt;/p&gt;
&lt;h2 id=&#34;私钥攻击已成头号威胁&#34;&gt;私钥攻击已成头号威胁
&lt;/h2&gt;&lt;p&gt;根据Chainalysis 2024年报告，43.8%的被盗资金源于私钥泄露，是其他攻击类型的五倍之多。私钥泄露已成为每个工程师设计新智能合约时必须考虑的新兴威胁。&lt;/p&gt;
&lt;p&gt;传统区块链安全审计往往忽视架构层面的访问控制风险。与其他行业不同，区块链安全评估很少将权限升级和访问控制设计作为核心关注点。Trail of Bits通过代码库成熟度评估标记架构问题，但多数协议直到开发生命周期末期才寻求外部审查。&lt;/p&gt;
&lt;h2 id=&#34;案例研究超额抵押借贷平台&#34;&gt;案例研究：超额抵押借贷平台
&lt;/h2&gt;&lt;p&gt;我们以理论上的超额抵押借贷平台为例，展示不同成熟度的访问控制设计：&lt;/p&gt;
&lt;h3 id=&#34;等级1高风险暴露---单一eoa控制器&#34;&gt;等级1：高风险暴露 - 单一EOA控制器
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;单个外部账户(EOA)控制所有管理功能&lt;/li&gt;
&lt;li&gt;私钥可能存储在联网的软件钱包中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;成熟度等级1&lt;/strong&gt;：单点故障，一旦私钥泄露即导致协议完全沦陷&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;等级2基础缓解---中心化多签&#34;&gt;等级2：基础缓解 - 中心化多签
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;管理权转移至多签钱包（如M-of-N Safe Wallet）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;成熟度等级2&lt;/strong&gt;：需要多个签名，但仍存在单一控制点&lt;/li&gt;
&lt;li&gt;改进：单个签名者密钥泄露不足以致命&lt;/li&gt;
&lt;li&gt;风险：足够多签名者被攻陷仍可立即执行恶意操作&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;等级3增强控制---时间锁与角色分离&#34;&gt;等级3：增强控制 - 时间锁与角色分离
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;实施时间锁合约（执行延迟）和最小权限原则(PoLP)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;成熟度等级3&lt;/strong&gt;：深度防御体系&lt;/li&gt;
&lt;li&gt;典型协议：Aave、Compound Finance、Lido&lt;/li&gt;
&lt;li&gt;关键角色：
&lt;ul&gt;
&lt;li&gt;核心系统角色（合约升级）：高门槛多签+长时间锁&lt;/li&gt;
&lt;li&gt;运营角色（日常配置）：中等时间锁和签名门槛&lt;/li&gt;
&lt;li&gt;暂停监护角色（紧急暂停）：无时间锁+低门槛&lt;/li&gt;
&lt;li&gt;取消监护角色（中止交易）：安全团队控制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;等级4终极形态---彻底不可变与用户主权&#34;&gt;等级4：终极形态 - 彻底不可变与用户主权
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;完全消除管理操作需求&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;成熟度等级4&lt;/strong&gt;：近乎无控制点的不可变系统&lt;/li&gt;
&lt;li&gt;典型协议：Uniswap、Liquity&lt;/li&gt;
&lt;li&gt;设计挑战：
&lt;ul&gt;
&lt;li&gt;合约完全不可升级（需部署新系统）&lt;/li&gt;
&lt;li&gt;资产上架需独立部署新市场&lt;/li&gt;
&lt;li&gt;风险参数永久固定或算法决定&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;优势：彻底消除访问控制风险&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;设计韧性而非被动应对&#34;&gt;设计韧性而非被动应对
&lt;/h2&gt;&lt;p&gt;2024年43.8%的被盗资金证明，忽视架构级访问控制已不可接受。建议立即行动：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对照成熟度框架评估当前协议&lt;/li&gt;
&lt;li&gt;为高风险功能实施时间锁并确保监控&lt;/li&gt;
&lt;li&gt;按最小权限原则划分特权功能&lt;/li&gt;
&lt;li&gt;考虑部分组件采用等级4不可变模式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在Trail of Bits，我们提倡这种安全整体观。通过设计审查和早期咨询等服务，帮助团队主动解决这些基础问题。构建安全的去中心化系统不仅需要漏洞狩猎，更需从第一天就开始设计运营韧性。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>宣布AES-GEM（带伽罗瓦扩展模式的AES）——增强AES-GCM安全性的新加密模式</title>
        <link>http://localhost:1313/p/%E5%AE%A3%E5%B8%83aes-gem%E5%B8%A6%E4%BC%BD%E7%BD%97%E7%93%A6%E6%89%A9%E5%B1%95%E6%A8%A1%E5%BC%8F%E7%9A%84aes%E5%A2%9E%E5%BC%BAaes-gcm%E5%AE%89%E5%85%A8%E6%80%A7%E7%9A%84%E6%96%B0%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F/</link>
        <pubDate>Sat, 02 Aug 2025 07:29:18 +0800</pubDate>
        
        <guid>http://localhost:1313/p/%E5%AE%A3%E5%B8%83aes-gem%E5%B8%A6%E4%BC%BD%E7%BD%97%E7%93%A6%E6%89%A9%E5%B1%95%E6%A8%A1%E5%BC%8F%E7%9A%84aes%E5%A2%9E%E5%BC%BAaes-gcm%E5%AE%89%E5%85%A8%E6%80%A7%E7%9A%84%E6%96%B0%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F/</guid>
        <description>&lt;h1 id=&#34;宣布aes-gem带伽罗瓦扩展模式的aes&#34;&gt;宣布AES-GEM（带伽罗瓦扩展模式的AES）
&lt;/h1&gt;&lt;p&gt;今天，AES-GCM是TLS 1.3使用的两种加密模式之一（另一种是ChaCha20-Poly1305），也是FIPS验证模块中加密数据的首选方法。但尽管取得了巨大成功，AES-GCM也曾导致一些灾难性故障：例如Hanno Böck和Sean Devlin利用nonce重用漏洞将他们的Black Hat USA幻灯片注入MI5网站。&lt;/p&gt;
&lt;p&gt;多年来，安全研究人员一直在警告AES-GCM的弱点。19年前，Niels Ferguson向NIST提交论文指出AES-GCM存在的认证弱点（尽管NIST最终将其标准化）。今年早些时候，亚马逊发布论文详细说明了AES-GCM的实际挑战，并认为AES的128位块大小已不再足够，更倾向于使用256位块密码（即Rijndael-256）。&lt;/p&gt;
&lt;p&gt;为解决这些问题，我提出了一种名为Galois Extended Mode（简称GEM）的新块密码模式，上个月已在NIST关于手风琴模式密码需求的研讨会上展示。AES-GEM以最小的性能开销在各个方面提升了GCM的安全性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重要提示&lt;/strong&gt;：当前AES-GEM设计尚未准备好投入生产使用，因为某些细节可能会在未来发生变化。要理解当前设计，让我们先了解AES-GCM的不足，然后讨论如何用GEM做得更好。&lt;/p&gt;
&lt;h2 id=&#34;aes工作原理&#34;&gt;AES工作原理
&lt;/h2&gt;&lt;p&gt;在深入之前，有必要为部分读者解释本文中使用的一些术语和概念。&lt;/p&gt;
&lt;p&gt;AES（高级加密标准）是一种广泛用于加密信息的块密码。它支持多种密钥大小（128位、192位和256位密钥），但始终操作128位块。AES是Rijndael块密码家族的标准化形式。Rijndael支持其他块大小，但NIST仅标准化了128位块。现代处理器提供专用硬件指令加速AES操作，但AES密钥调度仍可能对性能产生负面影响。&lt;/p&gt;
&lt;p&gt;ECB（电子密码本）模式是没有块密码操作模式的情况。它涉及直接在数据块上计算块密码。正如许多密码学家所证明的，ECB模式不是语义安全的。为提高安全性，像AES这样的块密码通常与操作模式一起使用。（如果没有，几乎肯定应该这样做。如果您认为正在使用ECB加密敏感数据，请联系我们的密码学团队。）&lt;/p&gt;
&lt;p&gt;CTR（计数器模式）是一种块密码操作模式，其中递增的值序列通过块密码加密以产生伪随机密钥流。要加密数据，只需计算每个明文字节与相应密钥流字节的XOR。&lt;/p&gt;
&lt;p&gt;GCM（伽罗瓦/计数器模式）是一种提供认证加密的块密码操作模式。密码学家称之为AEAD模式：带附加数据的认证加密。GCM可以为敏感数据提供机密性，为敏感和公共数据提供完整性。&lt;/p&gt;
&lt;p&gt;AEAD模式对于设计密码系统非常重要，这些系统能够抵抗试图改变加密数据以研究系统行为从而希望获得密码分析有用信息的攻击者。&lt;/p&gt;
&lt;p&gt;GCM是用于加密明文的计数器模式（CTR）和用于认证密文（以及如果提供，附加关联数据）的伽罗瓦域消息认证码（GMAC）的组合。GMAC使用称为GHASH的函数定义，该函数是在认证数据上评估的多项式。GHASH的输出与加密计数器块的XOR产生最终认证标签。认证密钥H通过加密128位零块计算得出。&lt;/p&gt;
&lt;p&gt;POLYVAL是GHASH的替代方案，用于AES-GCM-SIV。POLYVAL使用的不可约多项式是GHASH不可约多项式的反转。&lt;/p&gt;
&lt;p&gt;许多密码模式（包括GCM和CTR）要求每个消息使用一个仅使用一次的数字。这个永远不应重复的公共数字称为nonce。&lt;/p&gt;
&lt;p&gt;最后，生日边界是概率论中的一个概念，表示一组随机值中冲突的可能性。在密码学中，它意味着如果随机选择nonce，随着使用更多nonce，两个nonce冲突的概率显著增加。对于具有96位nonce的AES-GCM，大约232条消息后，有1/232的nonce冲突概率，这可能导致诸如伪造消息等安全漏洞。&lt;/p&gt;
&lt;h2 id=&#34;aes-gcm当前的实际挑战&#34;&gt;AES-GCM当前的实际挑战
&lt;/h2&gt;&lt;p&gt;正如其他人指出的那样，AES-GCM的最大挑战是AES只有128位块大小。这有两个主要后果：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;公共nonce和内部计数器的大小被限制为总共128位。实际上，nonce大小通常为96位，计数器为32位。如果选择更大的nonce，它会被哈希压缩到适当大小，这对安全性几乎没有改善。如果重用nonce，则会泄漏认证子密钥，因此可以无限期伪造消息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在相同密钥下加密超过一定数量的块后，攻击者可以以显著概率区分密文和随机字节。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当您理解我们处理的是2的幂时，96位nonce空间可能听起来很多，但如果随机选择nonce，只能加密232条消息，然后有2-32的冲突概率。使用具有更大块大小的密码可以缓解这一点，但这不是唯一的解决方法。&lt;/p&gt;
&lt;p&gt;AES块大小不是AES-GCM实践中唯一的问题。正如Niels Ferguson在2005年指出的那样，针对短标签的成功伪造会揭示认证子密钥。&lt;/p&gt;
&lt;p&gt;此外，我们还了解到AES-GCM具有一个意外属性，即多个密钥可以解密相同的密文+认证标签。其发现者将这个问题称为&amp;quot;隐形蝾螈&amp;quot;，因为它允许他们在一款加密消息应用程序的滥用报告工具中隐藏蝾螈图片。在使用AES-GCM的协议中防止隐形蝾螈需要对使用的密钥进行某种单向承诺。&lt;/p&gt;
&lt;p&gt;最后，AES-GCM中单个消息的最大明文长度相对较小：略低于64 GiB。为应对此最大长度，软件通常将较大消息分解为适合此长度限制的较短帧。这导致生日边界前的有限nonce空间比如果容忍较长消息时更快耗尽。&lt;/p&gt;
&lt;h2 id=&#34;介绍aes-gem&#34;&gt;介绍AES-GEM
&lt;/h2&gt;&lt;p&gt;我们的提案Galois Extended Mode是对GCM（伽罗瓦/计数器模式）的修改，目前解决了大多数这些弱点。然而，关于我们想要采用哪种策略来缓解最后一点，仍然存在一个开放性问题，我将在稍后解释。&lt;/p&gt;
&lt;p&gt;在高层次上，我们提出了两种变体：AES-128-GEM和AES-256-GEM。我们还使用标准AEAD接口指定了两种AEAD构造。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AES-128-GEM&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;密钥长度：128位&lt;/li&gt;
&lt;li&gt;子密钥长度：128位&lt;/li&gt;
&lt;li&gt;Nonce长度：192位&lt;/li&gt;
&lt;li&gt;最大明文长度：261 – 1字节&lt;/li&gt;
&lt;li&gt;最大AAD长度：261 – 1字节&lt;/li&gt;
&lt;li&gt;标签长度：48字节（AEAD）或16字节（无承诺）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;AES-256-GEM&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;密钥长度：256位&lt;/li&gt;
&lt;li&gt;子密钥长度：256位&lt;/li&gt;
&lt;li&gt;Nonce长度：256位&lt;/li&gt;
&lt;li&gt;最大明文长度：261 – 1字节&lt;/li&gt;
&lt;li&gt;最大AAD长度：261 – 1字节&lt;/li&gt;
&lt;li&gt;标签长度：48字节（AEAD）或16字节（无承诺）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;从gcm到gem的道路&#34;&gt;从GCM到GEM的道路
&lt;/h2&gt;&lt;p&gt;如果您从AES-GCM的现有设计开始并进行以下更改，您将得到GEM的当前草案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Nonce扩展&lt;/strong&gt;
首先，我们需要一个更长的nonce，我们将在下一步中用于子密钥派生。&lt;/p&gt;
&lt;p&gt;对于256位密钥，256位nonce是一个很好的整数。对于128位密钥，我们最终需要192位。&lt;/p&gt;
&lt;p&gt;无论哪种情况，最右边的64位将保留用于实际底层加密。剩余的位（AES-256为192位，AES-128为128位）将用于子密钥派生。&lt;/p&gt;
&lt;p&gt;这使我们能够分摊密钥派生的成本，并在多个消息上设置AES密钥调度，前提是nonce和密钥的前（n – 64）位相同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;子密钥派生&lt;/strong&gt;
使用AES进行密钥派生有多种策略。在Real World Cryptography 2024上，Shay Gueron展示了DNDK-GCM，它使用了一种有趣的结构来实现子密钥派生。&lt;/p&gt;
&lt;p&gt;我们希望保持简单和易于理解。因此，我们基于CBC-MAC构建了密钥派生策略，因为CMAC已经是FIPS批准的MAC（即用于AES-CCM）。&lt;/p&gt;
&lt;p&gt;在AES-256的情况下，我们使用两个CBC-MAC输出来派生256位子密钥。然而，这种方法有一个微妙恼人的特性：两半永远不会产生相同的输出，因此严格来说，可能的输出少于2256个。&lt;/p&gt;
&lt;p&gt;在GEM的两种变体中，我们借用了Salsa20设计中的一个技巧：将输出与输入密钥进行XOR，以确保子密钥对于任何不知道输入密钥的攻击者来说与均匀随机无法区分。如果您不知道此密钥，则输出与适当长度的随机密钥无法区分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;支持更长的消息&lt;/strong&gt;
我们需要64位剩余nonce而不是GCM典型的96位的原因是我们的内部计数器大小不是32位长。相反，它是64位长。&lt;/p&gt;
&lt;p&gt;否则，如当前所写，GEM的行为与您对GCM的期望相同：它使用计数器模式进行批量数据加密。让我们暂时搁置这一点，稍后再讨论。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;改进的认证安全性&lt;/strong&gt;
我们的现有设计AES-GCM按以下方式构建：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过用密钥加密全清零块派生认证子密钥H。&lt;/li&gt;
&lt;li&gt;计算密文、关联数据和包含两者长度（以位为单位）的块的GHASH()。&lt;/li&gt;
&lt;li&gt;将步骤2的输出与计数器块的AES-CTR加密进行XOR。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们的设计大致相同，但有一个重要的调整：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过用子密钥加密全置位块派生认证子密钥H。&lt;/li&gt;
&lt;li&gt;计算密文、关联数据和包含两者长度（以位为单位）的块的GHASH()。&lt;/li&gt;
&lt;li&gt;使用输入密钥通过AES-ECB加密步骤2的输出。&lt;/li&gt;
&lt;li&gt;将步骤3的输出与计数器块的AES-CTR加密进行XOR。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;步骤3直接解决了Niels Ferguson在2005年指出的AES-GCM弱点。其他更改是实现细节。&lt;/p&gt;
&lt;p&gt;此调整为短标签提供了更好的安全性，因为原始GHASH输出位的AES加密是一种非线性变换，没有密钥无法反转。我们使用输入密钥而不是子密钥，因为唯一其他使用输入密钥加密数据的地方（即子密钥派生）永远不会直接暴露。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;密钥承诺&lt;/strong&gt;
在我们解决GEM对隐形蝾螈式攻击的保护之前，我们需要分析设计中的其他一些微妙之处。&lt;/p&gt;
&lt;p&gt;GCM和GEM的最终块中的组件长度都以位而非字节表示，并且每个都限制为264。这意味着，尽管由于内部计数器，GEM理论上可以允许每条消息最多264块（或268字节）的明文，但我们必须调整最终的GHASH步骤以适应这种额外开销。&lt;/p&gt;
&lt;p&gt;相反，内部计数器的不可达值保留用于密码的内部使用。具体来说，内部计数器值以0x02000000 00000000到0xFFFFFFFF FFFFFFFF结尾的无法在尊重明文261 – 1字节限制的同时达到。&lt;/p&gt;
&lt;p&gt;全置位块（0xFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF）已在GEM中用于认证子密钥，而64位尾部nonce + 0xFFFFFFFF 0xFFFFFFFE用于计数器块，用于最终认证标签计算。&lt;/p&gt;
&lt;p&gt;为提供密钥承诺，接下来的两个块，nonce + 0xFFFFFFFF 0xFFFFFFFC和0xFFFFFFFF 0xFFFFFFFD将用作密钥和nonce的承诺值。&lt;/p&gt;
&lt;p&gt;我们指定两个块是因为在此处使用一个AES块是不够的。考虑AES-256的情况，它具有256位密钥和128位块：根据鸽巢原理，我们预计有2128个不同的密钥将给定的固定明文值映射到固定密文值。因此，单个块不足以进行承诺。然而，假设块密码是安全的，对于两个连续块，不需要这种鸽巢考虑。&lt;/p&gt;
&lt;p&gt;通过这种方式，我们可以快速生成给定密钥和nonce的承诺值。&lt;/p&gt;
&lt;p&gt;在AEAD接口中，承诺附加到认证标签。解密消息时，必须以恒定时间将两者与其重新计算的值进行比较。&lt;/p&gt;
&lt;h2 id=&#34;aes-gem的性能特征&#34;&gt;AES-GEM的性能特征
&lt;/h2&gt;&lt;p&gt;尽管我们已经解决了GCM的大部分痛点，但GEM的实际性能影响很小。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AES-256-GEM：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;密钥派生：四个额外的AES加密块，一些XOR，一个额外的密钥调度&lt;/li&gt;
&lt;li&gt;认证：一个额外的AES加密块&lt;/li&gt;
&lt;li&gt;密钥承诺：两个额外的AES加密块&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;AES-128-GEM：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;密钥派生：两个额外的AES加密块，一些XOR，一个额外的密钥调度&lt;/li&gt;
&lt;li&gt;认证：一个额外的AES加密块&lt;/li&gt;
&lt;li&gt;密钥承诺：两个额外的AES加密块&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于如今AES由于硬件加速非常快，这种性能影响在除最性能敏感的应用外的所有应用中应该几乎不明显。在这些情况下，如果派生子密钥被缓存，密钥派生性能成本可以在多达232条不同消息中分摊。&lt;/p&gt;
&lt;h2 id=&#34;完善aes-gem&#34;&gt;完善AES-GEM
&lt;/h2&gt;&lt;p&gt;当前GEM草案未充分解决的一个最终问题，但我们希望在NIST研讨会上讨论此问题，并肯定会在最终设计中解决。&lt;/p&gt;
&lt;p&gt;尽管我们的GEM草案构造允许比GCM更长的消息，但AES块大小使其按原样使用存在风险。主要担忧是加密非常长的消息会给攻击者带来显著优势，以区分AES-GEM密文与随机字节序列。（这是亚马逊2024年论文中提出的一个担忧。）&lt;/p&gt;
&lt;p&gt;我们可以通过几种方式完善GEM以解决此弱点，这些方式具有不同的性能特征和权衡。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;宽块PRP&lt;/strong&gt;
多年来，许多密码设计使用宽块PRP（如XTS模式中的AES）安全加密超过AES块大小通常允许的范围。由于XTS广泛用于磁盘加密，这种方法可能会证明是安全的。&lt;/p&gt;
&lt;p&gt;然而，XTS模式目前尚未标准化用于磁盘加密以外的用例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分层密钥派生&lt;/strong&gt;
如果不直接使用子密钥，而是使用内部计数器的高32位从保留的nonce空间中选择不同的值，加密该值，并每236字节派生一个新的子密钥呢？然后，我们仅使用此子密钥加密计数器的剩余32位，这与AES-GCM几十年来所做的类似。&lt;/p&gt;
&lt;p&gt;此子子密钥派生可以类似于密钥承诺构建：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于AES-256-GEM，加密来自保留nonce空间的32字节，并将其用作实际CTR密钥。&lt;/li&gt;
&lt;li&gt;对于AES-128-GEM，加密来自保留nonce空间的16字节（但与AES-256-GEM选择的不同nonce空间），并将其用作实际底层CTR密钥。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是一个有吸引力的选择，原因有很多。最重要的是，这种策略将以非常直接的方式规避PRP区分器问题。它也不依赖于任何非标准设计（如XTS模式）。您可以使用FIPS批准的组件构建整个东西，就像我们对AES-GEM的其余草案设计所做的那样。&lt;/p&gt;
&lt;p&gt;缺点？这种方法确实会在每236字节明文时产生另一个密钥调度。这可能仍然很好地分摊，但值得记住。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;带分层密钥派生的AES-GEM的总性能成本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AES-256-GEM：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;密钥派生：四个额外的AES加密块，一些XOR，一个额外的密钥调度&lt;/li&gt;
&lt;li&gt;每236字节明文的额外密钥派生：两个额外的AES加密块，一个额外的密钥调度&lt;/li&gt;
&lt;li&gt;认证：一个额外的AES加密块&lt;/li&gt;
&lt;li&gt;密钥承诺：两个额外的AES加密块&lt;/li&gt;
&lt;li&gt;1 GB明文的额外总开销：七个AES-256块，两个额外的AES-256密钥调度&lt;/li&gt;
&lt;li&gt;1 TB明文的额外总开销：37个AES-256块，17个额外的AES-256密钥调度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;AES-128-GEM：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;密钥派生：两个额外的AES加密块，一些XOR，一个额外的密钥调度&lt;/li&gt;
&lt;li&gt;每236字节明文的额外密钥派生：一个额外的AES加密块，一个额外的密钥调度&lt;/li&gt;
&lt;li&gt;认证：一个额外的AES加密块&lt;/li&gt;
&lt;li&gt;密钥承诺：两个额外的AES加密块&lt;/li&gt;
&lt;li&gt;1 GB明文的额外总开销：五个AES-128块，两个额外的AES-128密钥调度&lt;/li&gt;
&lt;li&gt;1 TB明文的额外总开销：21个AES-128块，17个额外的AES-128密钥调度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;其他想法&lt;/strong&gt;
可能还有我们尚未想象的另一种选择。找到最佳权衡，特别是在考虑硬件设计时，是我们在NIST研讨会上展示GEM的原因之一。&lt;/p&gt;
&lt;h2 id=&#34;切割gem&#34;&gt;切割GEM
&lt;/h2&gt;&lt;p&gt;IETF的CFRG目前正在讨论一种修改后的AES-GCM变体的RFC草案，称为GCM-SST，它对短标签是安全的。他们的设计出于性能原因使用POLYVAL而不是GHASH，并使用带有第二个POLYVAL的第二个认证密钥（Q），所有这些都进行XOR。&lt;/p&gt;
&lt;p&gt;不出所料，这种额外的XOR并不能显著保护AES-GCM中短标签的弱点（尽管它确实使通常的攻击更昂贵）。&lt;/p&gt;
&lt;p&gt;我们对GEM的初始设计使用AES块密码置换GHASH输出，而不是简单地在多项式输出中引入额外的线性操作（XOR）。&lt;/p&gt;
&lt;p&gt;我们有兴趣与其他行业领导者合作，提供一种强调短标签用例（即WebRTC）的GEM变体。这种假设的变体（暂定名为CUT-GEM）可以使用POLYVAL代替GHASH，并使用基于时期的子密钥派生计划来减少每个数据包的性能影响。&lt;/p&gt;
&lt;h2 id=&#34;在哪里可以了解更多关于aes-gem的信息&#34;&gt;在哪里可以了解更多关于AES-GEM的信息？
&lt;/h2&gt;&lt;p&gt;有关AES-GEM的更多信息可在我们的GitHub上找到！&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
