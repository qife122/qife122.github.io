<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>系统安全 on 办公AI智能小助手</title>
        <link>http://localhost:1313/tags/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/</link>
        <description>Recent content in 系统安全 on 办公AI智能小助手</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>qife</copyright>
        <lastBuildDate>Thu, 07 Aug 2025 02:24:56 +0800</lastBuildDate><atom:link href="http://localhost:1313/tags/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>隐藏Bash历史记录的实用技巧</title>
        <link>http://localhost:1313/p/%E9%9A%90%E8%97%8Fbash%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95%E7%9A%84%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/</link>
        <pubDate>Thu, 07 Aug 2025 02:24:56 +0800</pubDate>
        
        <guid>http://localhost:1313/p/%E9%9A%90%E8%97%8Fbash%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95%E7%9A%84%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/</guid>
        <description>&lt;h1 id=&#34;隐藏bash历史记录&#34;&gt;隐藏Bash历史记录
&lt;/h1&gt;&lt;p&gt;你是否曾登录Linux服务器后，突然意识到Bash会记录所有执行过的命令？这种情况我偶尔会遇到，因此专门研究了隐藏这些&amp;quot;失误&amp;quot;的方法。以下是我的发现，如果你有其他建议欢迎联系我。&lt;/p&gt;
&lt;h2 id=&#34;常用方法对比&#34;&gt;常用方法对比
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;正常退出&lt;/strong&gt; - 历史记录会正常写入&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;kill &amp;lt;bash进程ID&amp;gt;&lt;/strong&gt;（服务端执行）- 不会写入历史记录。经测试不需要使用-9参数，普通kill命令就足以中断进程阻止写入&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;kill &amp;lt;ssh进程ID&amp;gt;&lt;/strong&gt;（客户端执行）- 即使使用-9参数也会写入历史记录&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;set +o history&lt;/strong&gt; - 不记录当前会话的任何命令。可在会话任意时刻执行，隐藏全部命令&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;set -o history&lt;/strong&gt; - 重新开启记录，但会记录set命令本身&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;unset HISTFILE&lt;/strong&gt; - 清除历史文件存储路径变量，阻止记录&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;history -c&lt;/strong&gt; - 完全清除历史记录（非常明显）&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;em&gt;export HISTIGNORE=&amp;ldquo;ls&lt;/em&gt;:cat&lt;/em&gt;**&amp;rdquo; - 设置不记录的命令列表（支持shell通配符）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;export HISTFILESIZE=10&lt;/strong&gt; - 限制历史文件只记录10条命令&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;编辑.bash_history文件&lt;/strong&gt; - 会话期间编辑会使得修改出现在当前会话命令之前&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用多个会话&lt;/strong&gt; - Bash按会话终止顺序写入历史文件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;命令前加空格&lt;/strong&gt; - 根据配置可能不记录该命令（不同发行版效果不同）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;history -r&lt;/strong&gt; - 重新读取历史文件，可配合编辑后使用&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;最佳实践&#34;&gt;最佳实践
&lt;/h2&gt;&lt;p&gt;综合来看，&amp;ldquo;set +o history&amp;quot;可能是最佳通用方案，它能隐藏当前会话所有命令同时保留之前历史。但不同场景下其他方法可能更适用。&lt;/p&gt;
&lt;p&gt;重要提示：依赖这些方法前请先测试。如果发现需要隐藏命令时不必惊慌，历史记录通常只在会话结束时写入（除非特殊配置为每条命令都记录）。&lt;/p&gt;
&lt;p&gt;最后提醒：虽然其他shell可能不受这些方法影响，但生产环境服务器大多仍使用Bash。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://digi.ninja/support.php&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;支持本站&lt;/a&gt; - 本站所有内容均为Robin Wood原创制作&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Palo Alto Networks 关键安全更新：CVE-2024-5910 和 CVE-2024-3596 漏洞分析</title>
        <link>http://localhost:1313/p/palo-alto-networks-%E5%85%B3%E9%94%AE%E5%AE%89%E5%85%A8%E6%9B%B4%E6%96%B0cve-2024-5910-%E5%92%8C-cve-2024-3596-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</link>
        <pubDate>Mon, 04 Aug 2025 14:40:46 +0800</pubDate>
        
        <guid>http://localhost:1313/p/palo-alto-networks-%E5%85%B3%E9%94%AE%E5%AE%89%E5%85%A8%E6%9B%B4%E6%96%B0cve-2024-5910-%E5%92%8C-cve-2024-3596-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</guid>
        <description>&lt;h3 id=&#34;摘要&#34;&gt;摘要
&lt;/h3&gt;&lt;p&gt;Palo Alto Networks发布关键安全更新，修复了包括Expedition迁移工具高危漏洞（CVE-2024-5910，CVSS评分9.3）在内的多个安全问题。该工具用于配置迁移与优化，但漏洞会导致导入的配置密钥、凭证等敏感数据暴露，攻击者可借此劫持管理员账户。&lt;br&gt;
另一漏洞（CVE-2024-3596）存在于RADIUS协议中，通过中间人攻击可实现权限提升至&amp;quot;超级用户&amp;quot;，影响PAN-OS防火墙与RADIUS服务器的认证过程（当使用CHAP或PAP时）。&lt;/p&gt;
&lt;h3 id=&#34;受影响系统&#34;&gt;受影响系统
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;CVE-2024-5910&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Expedition（1.2.92之前版本）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;CVE-2024-3596&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PAN-OS（版本&amp;lt;11.1.3、11.0.4-h4、10.2.10、10.1.14、9.1.19）&lt;/li&gt;
&lt;li&gt;Prisma Access（预计7月30日前修复）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;紧急措施&#34;&gt;紧急措施
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;升级软件&lt;/strong&gt;：Expedition升级至1.2.92+，PAN-OS升级至指定版本。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;访问限制&lt;/strong&gt;：严格控制Expedition工具的网络访问权限。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RADIUS配置&lt;/strong&gt;：避免在未加密通道中使用CHAP/PAP协议。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;长期建议&#34;&gt;长期建议
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;及时应用所有安全补丁&lt;/li&gt;
&lt;li&gt;定期审查认证协议与网络访问策略&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;官方公告详见：&lt;a class=&#34;link&#34; href=&#34;https://security.paloaltonetworks.com/CVE-2024-5910&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Palo Alto Networks安全通告&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>用零知识证明重塑漏洞披露机制 - 突破性技术解析</title>
        <link>http://localhost:1313/p/%E7%94%A8%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E%E9%87%8D%E5%A1%91%E6%BC%8F%E6%B4%9E%E6%8A%AB%E9%9C%B2%E6%9C%BA%E5%88%B6-%E7%AA%81%E7%A0%B4%E6%80%A7%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/</link>
        <pubDate>Fri, 01 Aug 2025 23:16:03 +0800</pubDate>
        
        <guid>http://localhost:1313/p/%E7%94%A8%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E%E9%87%8D%E5%A1%91%E6%BC%8F%E6%B4%9E%E6%8A%AB%E9%9C%B2%E6%9C%BA%E5%88%B6-%E7%AA%81%E7%A0%B4%E6%80%A7%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/</guid>
        <description>&lt;h1 id=&#34;用零知识证明重塑漏洞披露机制&#34;&gt;用零知识证明重塑漏洞披露机制
&lt;/h1&gt;&lt;p&gt;我们与约翰霍普金斯大学的合作伙伴Matthew Green正在利用零知识证明（ZK）技术建立一个可信环境，使科技公司与漏洞研究者能够安全沟通而不必担心破坏或纠纷。这项为期四年的研究将推动ZK证明从理论走向实践，为研究者提供能生成漏洞可利用性ZK证明的软件工具。该研究隶属于DARPA&amp;quot;加密验证与评估信息保护&amp;quot;（SIEVE）计划。&lt;/p&gt;
&lt;h2 id=&#34;为什么需要漏洞可利用性的zk证明&#34;&gt;为什么需要漏洞可利用性的ZK证明？
&lt;/h2&gt;&lt;p&gt;软件厂商与漏洞研究者之间常因漏洞报告产生矛盾。研究者过度披露漏洞细节可能丧失奖励，而过早披露则可能损害企业声誉。更严重的是，当企业忽视安全团队警告时，研究者面临两难选择：保持沉默让用户处于风险，或公开漏洞迫使企业行动——后者可能反而帮助攻击者。&lt;/p&gt;
&lt;p&gt;ZK证明将彻底改变这种局面，允许企业明确定义漏洞赏金范围，研究者则能无可辩驳地证明其拥有有效漏洞利用方案，同时避免公开披露风险。&lt;/p&gt;
&lt;h2 id=&#34;zk证明的设计原理&#34;&gt;ZK证明的设计原理
&lt;/h2&gt;&lt;p&gt;在ZK证明中，证明者无需透露具体信息即可验证陈述真实性。例如证明知道SHA256原像而不泄露原像本身。目前最著名的工业应用是Zcash等隐私区块链，用户通过ZK证明交易合法性而不暴露任何敏感信息。&lt;/p&gt;
&lt;p&gt;开发高效ZK系统需权衡三个指标：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;证明生成时间&lt;/li&gt;
&lt;li&gt;验证时间&lt;/li&gt;
&lt;li&gt;通信带宽（证明数据量）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;核心挑战在于将待证明陈述转换为无循环的布尔/算术电路。这对缺乏明确数学表述的问题尤为困难，例如包含数据依赖循环的程序必须展开处理。&lt;/p&gt;
&lt;h2 id=&#34;漏洞可利用性证明技术实现&#34;&gt;漏洞可利用性证明技术实现
&lt;/h2&gt;&lt;p&gt;由于ZK证明接受布尔电路表述，我们需要构建仅在漏洞利用成功时返回&amp;quot;真&amp;quot;的电路。关键挑战包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理器建模&lt;/strong&gt;：需精确模拟目标程序的编译架构。初始方案是对处理器单步运行建模，但会导致电路规模爆炸（50MB内存的100条指令轨迹将产生5GB电路）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;内存验证优化&lt;/strong&gt;：采用SNARKs for C的方案，将证明分为核心逻辑与内存正确性两部分。逻辑验证通过检查指令序列状态转移实现，内存验证则通过内存排序轨迹的线性扫描完成，避免直接处理整个RAM。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;防伪造机制&lt;/strong&gt;：通过&amp;quot;置换检查器&amp;quot;电路确保内存排序轨迹的真实性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;x86架构的特殊挑战&#34;&gt;x86架构的特殊挑战
&lt;/h2&gt;&lt;p&gt;从简易的MSP430 RISC架构转向复杂x86架构面临巨大挑战：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RISC处理器每周期约1-10k逻辑门&lt;/li&gt;
&lt;li&gt;基础x86模型处理10,000条指令可能产生48GB证明数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们的解决方案是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;动态子集生成&lt;/strong&gt;：通过程序分析确定二进制文件实际使用的x86指令子集（通常仅数百条）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;静态二进制转换&lt;/strong&gt;：对repz等运行时依赖指令，转换为可验证的子集指令&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;组合电路优化&lt;/strong&gt;：避免硬编码复杂指令处理逻辑&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;漏洞披露新范式&#34;&gt;漏洞披露新范式
&lt;/h2&gt;&lt;p&gt;这项技术将实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;企业精确定义漏洞赏金范围&lt;/li&gt;
&lt;li&gt;研究者安全提交漏洞证明&lt;/li&gt;
&lt;li&gt;消费者保护机制：研究者可警示风险而不公开漏洞细节&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们正推动ZK证明从学术走向工业应用。如果您有特殊应用场景，欢迎联系我们——我们在ZK证明方案和电路编译器领域拥有丰富经验。&lt;/p&gt;
&lt;p&gt;（原文包含技术架构图表示例和论文引用，此处保留技术要点翻译）&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
