<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Arm64 on 办公AI智能小助手</title>
        <link>http://localhost:1313/tags/arm64/</link>
        <description>Recent content in Arm64 on 办公AI智能小助手</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>qife</copyright>
        <lastBuildDate>Fri, 08 Aug 2025 00:33:58 +0800</lastBuildDate><atom:link href="http://localhost:1313/tags/arm64/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>简化代码迁移：Ampere Porting Advisor助力x86到Arm64的高效转换</title>
        <link>http://localhost:1313/p/%E7%AE%80%E5%8C%96%E4%BB%A3%E7%A0%81%E8%BF%81%E7%A7%BBampere-porting-advisor%E5%8A%A9%E5%8A%9Bx86%E5%88%B0arm64%E7%9A%84%E9%AB%98%E6%95%88%E8%BD%AC%E6%8D%A2/</link>
        <pubDate>Fri, 08 Aug 2025 00:33:58 +0800</pubDate>
        
        <guid>http://localhost:1313/p/%E7%AE%80%E5%8C%96%E4%BB%A3%E7%A0%81%E8%BF%81%E7%A7%BBampere-porting-advisor%E5%8A%A9%E5%8A%9Bx86%E5%88%B0arm64%E7%9A%84%E9%AB%98%E6%95%88%E8%BD%AC%E6%8D%A2/</guid>
        <description>&lt;h1 id=&#34;简化代码迁移ampere-porting-advisor的优势&#34;&gt;简化代码迁移：Ampere Porting Advisor的优势
&lt;/h1&gt;&lt;p&gt;随着从传统x86向Arm64（尤其是Ampere处理器）的转型加速，开发者急需高效迁移现有代码库的方案。Ampere Porting Advisor正是为此设计的工具，可通过&lt;a class=&#34;link&#34; href=&#34;https://github.com/AmpereComputing/ampere-porting-advisor&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GitHub页面&lt;/a&gt;获取。&lt;/p&gt;
&lt;h2 id=&#34;工具核心价值&#34;&gt;工具核心价值
&lt;/h2&gt;&lt;p&gt;该工具通过自动化手动步骤显著提升迁移效率：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分析源代码并生成详细修改建议&lt;/li&gt;
&lt;li&gt;标记潜在兼容性问题&lt;/li&gt;
&lt;li&gt;支持多种编程语言和依赖检查&lt;/li&gt;
&lt;li&gt;提供终端、HTML和CSV三种输出格式&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;主要功能特性&#34;&gt;主要功能特性
&lt;/h2&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;功能类别&lt;/th&gt;
          &lt;th&gt;具体能力&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;语言支持&lt;/td&gt;
          &lt;td&gt;Python 3+、Java 8+、Go 1.11+、C/C++、Fortran&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;架构检测&lt;/td&gt;
          &lt;td&gt;缺失AAarch64汇编代码、架构特定指令、Makefile中的架构标记&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;依赖检查&lt;/td&gt;
          &lt;td&gt;版本验证、JAR扫描、依赖文件分析&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;运行方式&lt;/td&gt;
          &lt;td&gt;Python脚本、独立二进制或容器化运行&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;三种运行模式详解&#34;&gt;三种运行模式详解
&lt;/h2&gt;&lt;h3 id=&#34;1-容器化运行推荐&#34;&gt;1. 容器化运行（推荐）
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 构建镜像&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker build -t porting-advisor .
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 生成HTML报告&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker run --rm -v /repo/path:/repo -v /output:/output &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  porting-advisor /repo --output /output/report.html
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;2-python脚本运行&#34;&gt;2. Python脚本运行
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 创建虚拟环境&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;python3&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;venv&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;venv&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;source&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;venv&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;bin&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;activate&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 执行分析&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;python3&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;src&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;porting&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;advisor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;py&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;~/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;project&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;output&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;report&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;html&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;3-二进制执行&#34;&gt;3. 二进制执行
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 生成二进制&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./build.sh
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 执行分析&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./porting-advisor-linux-x86_64 ~/project --output dependencies.xlsx
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;典型迁移案例megahit项目&#34;&gt;典型迁移案例：MEGAHIT项目
&lt;/h2&gt;&lt;p&gt;该NGS汇编工具在迁移过程中遇到多个问题，通过Porting Advisor发现并解决了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;架构特定编译选项&lt;/strong&gt;：修正CMakeList中的条件编译&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SIMD指令集&lt;/strong&gt;：添加Arm64的NEON实现&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内联汇编&lt;/strong&gt;：增加&lt;code&gt;#if defined(__x86_64__)&lt;/code&gt;条件判断&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;迁移后测试结果显示，项目在Ampere处理器上编译通过且测试套件全部验证成功。&lt;/p&gt;
&lt;h2 id=&#34;技术优势总结&#34;&gt;技术优势总结
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;自动化识别90%以上的兼容性问题&lt;/li&gt;
&lt;li&gt;支持多语言混合代码库分析&lt;/li&gt;
&lt;li&gt;无需Arm64环境即可执行扫描&lt;/li&gt;
&lt;li&gt;显著降低后期调试成本&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：尽管工具能发现大多数已知问题，仍建议在生产环境前进行完整的处理器测试验证。&lt;/p&gt;&lt;/blockquote&gt;
</description>
        </item>
        <item>
        <title>Arm64架构内存页大小配置指南：提升性能的关键技巧</title>
        <link>http://localhost:1313/p/arm64%E6%9E%B6%E6%9E%84%E5%86%85%E5%AD%98%E9%A1%B5%E5%A4%A7%E5%B0%8F%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD%E7%9A%84%E5%85%B3%E9%94%AE%E6%8A%80%E5%B7%A7/</link>
        <pubDate>Wed, 06 Aug 2025 22:20:09 +0800</pubDate>
        
        <guid>http://localhost:1313/p/arm64%E6%9E%B6%E6%9E%84%E5%86%85%E5%AD%98%E9%A1%B5%E5%A4%A7%E5%B0%8F%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD%E7%9A%84%E5%85%B3%E9%94%AE%E6%8A%80%E5%B7%A7/</guid>
        <description>&lt;h1 id=&#34;理解arm64架构的内存页大小&#34;&gt;理解Arm64架构的内存页大小
&lt;/h1&gt;&lt;p&gt;Arm64架构与x86的主要区别之一，是可以在CPU的内存管理单元(MMU)中配置4K、16K或64K的内存页大小。本文总结了内存页大小的概念、在Linux系统上的配置方法，以及何时应该为应用程序使用不同的页大小。&lt;/p&gt;
&lt;h2 id=&#34;内存页大小介绍&#34;&gt;内存页大小介绍
&lt;/h2&gt;&lt;p&gt;正如我们在&lt;a class=&#34;link&#34; href=&#34;%e5%8e%9f%e9%93%be%e6%8e%a5&#34; &gt;诊断和修复Arm64原子操作的页错误性能问题&lt;/a&gt;中讨论过的，操作系统为应用程序提供虚拟内存地址空间，并通过页表将物理内存页映射到虚拟内存地址。CPU随后提供名为转译后备缓冲器(TLB)的机制，确保最近访问的内存页可以通过L1或L2 CPU缓存更快地被识别和读取。&lt;/p&gt;
&lt;p&gt;x86架构的物理内存页(称为granules)大小固定为4KB。而在Ampere Altra®或AmpereOne®等ARM64系统上，开发者可以配置物理内存页大小为4KB、16KB或64KB。&lt;/p&gt;
&lt;h2 id=&#34;何时使用更大的页大小&#34;&gt;何时使用更大的页大小？
&lt;/h2&gt;&lt;p&gt;由于改变页大小会影响系统的内存效率和性能，理解何时使用更大的页大小以及涉及的权衡非常重要。更大的页大小可能导致内存使用效率降低，因为页面可能未被完全利用。&lt;/p&gt;
&lt;p&gt;例如，如果我们在内存中存储7KB数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在4KB页系统中会使用两个4KB页面(共8KB)，效率为87.5%&lt;/li&gt;
&lt;li&gt;在64KB页系统中会使用一个64KB页面，效率仅为11%&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但MMU和操作系统内核足够智能，会利用之前分配但未满的连续内存块进行后续分配。如果同一进程后续分配32KB内存：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;64KB页系统仍只使用一个页面(共39KB占用)&lt;/li&gt;
&lt;li&gt;4KB页系统则需要管理10个4KB页面&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第二个权衡是页表查找缓存未命中导致的性能问题。每级缓存(L1、L2、系统级缓存)的TLB中只存储相对少量的页表项。更大的页大小意味着这些TLB项能覆盖更大的物理内存范围。&lt;/p&gt;
&lt;p&gt;以Ampere Altra和Altra Max处理器为例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;L1数据TLB有48个条目&lt;/li&gt;
&lt;li&gt;L2 TLB有1280个条目&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这意味着：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;4KB粒度时：L1 TLB可缓存192KB物理内存地址，L2 TLB可覆盖5MB&lt;/li&gt;
&lt;li&gt;64KB页大小时：L1数据TLB增至3MB，L2 TLB增至80MB&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每次TLB缓存未命中都会增加页遍历时间，导致CPU流水线停顿。更大的页大小意味着更少的缓存未命中，从而提升内存密集型工作负载的性能。同时，更大的连续内存区域也能改善I/O性能。&lt;/p&gt;
&lt;p&gt;适合使用大内存页的应用包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;数据库系统&lt;/strong&gt;：大量内存缓存和磁盘I/O&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;虚拟化基础设施&lt;/strong&gt;：虚拟机镜像通常占用数百MB到数百GB内存&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;持续集成构建服务器&lt;/strong&gt;：如Linux内核编译等高吞吐量工作负载&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络/I/O密集型应用&lt;/strong&gt;：对象缓存、负载均衡器、防火墙等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AI推理&lt;/strong&gt;：执行训练模型时的内存和CPU密集型工作负载&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;建议通过&amp;quot;perf&amp;quot;工具测量TLB停顿(stall_backend_tlb和stall_frontend_tlb)来评估大页面的潜在收益。计算公式：(stall_frontend_tlb + stall_backend_tlb)/cycles可作为可能节省时间的上限估计。&lt;/p&gt;
&lt;h2 id=&#34;在ampere-cpu上配置大页大小&#34;&gt;在Ampere CPU上配置大页大小
&lt;/h2&gt;&lt;p&gt;更改内存页大小需要运行支持所需大小的内核。主流云操作系统(如RHEL、Oracle Linux、SUSE、Ubuntu)都提供预编译的4KB和64KB页大小内核。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RHEL 9配置步骤&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装64K内核包：&lt;code&gt;dnf –y install kernel-64k&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;设置为默认启动内核：
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; /boot/vmlinuz*64k&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;grubby --set-default&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$k&lt;/span&gt; --update-kernel&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$k&lt;/span&gt; --args&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;crashkernel=2G-:640M&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Ubuntu 22.04配置&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装arm64+largemem ISO或&lt;code&gt;sudo apt install linux-generic-64K&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;设置64K内核为默认：
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;GRUB_FLAVOUR_ORDER=generic-64k&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; sudo tee /etc/default/grub.d/local-order.cfg
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Oracle Linux配置&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装内核包：&lt;code&gt;sudo dnf install -y kernel-uek64k&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;设置为默认：&lt;code&gt;sudo grubby --set-default=$(echo /boot/vmlinuz*64k)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;自定义编译内核时，可通过&lt;code&gt;make menuconfig&lt;/code&gt;在&amp;quot;Processor type and features&amp;quot;子菜单中修改ARM64 CPU特性寄存器配置，或直接修改.config文件中的&lt;code&gt;CONFIG_ARM_PAGE_SHIFT&lt;/code&gt;值(12对应4K，14对应16K，16对应64K)。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;getconf PAGESIZE&lt;/code&gt;命令可验证当前内核的页大小设置，64K系统将显示65536。&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论
&lt;/h2&gt;&lt;p&gt;调整云系统的内核内存页大小可显著提升许多常见云工作负载的应用性能。对于包含大量磁盘、内存或网络I/O的应用程序，在ARM主机上使用16K或64K页内核可能带来显著改进。&lt;/p&gt;
&lt;p&gt;但这不是万能方案，实际效果可能因应用而异。建议同时使用合成基准测试和真实场景测试来验证页大小改变的影响。多数支持Arm64的Linux发行版已在其仓库中包含多种内核，安装这些内核包并启动测试的成本相对较低。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
