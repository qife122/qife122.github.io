<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>不可变集合 on 办公AI智能小助手</title>
        <link>http://localhost:1313/tags/%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%9B%86%E5%90%88/</link>
        <description>Recent content in 不可变集合 on 办公AI智能小助手</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>qife</copyright>
        <lastBuildDate>Tue, 05 Aug 2025 22:12:27 +0800</lastBuildDate><atom:link href="http://localhost:1313/tags/%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%9B%86%E5%90%88/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>C#记录类型与集合的深度探讨：从自动生成代码到自定义相等性比较</title>
        <link>http://localhost:1313/p/c%23%E8%AE%B0%E5%BD%95%E7%B1%BB%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%9A%84%E6%B7%B1%E5%BA%A6%E6%8E%A2%E8%AE%A8%E4%BB%8E%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E5%88%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%B8%E7%AD%89%E6%80%A7%E6%AF%94%E8%BE%83/</link>
        <pubDate>Tue, 05 Aug 2025 22:12:27 +0800</pubDate>
        
        <guid>http://localhost:1313/p/c%23%E8%AE%B0%E5%BD%95%E7%B1%BB%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%9A%84%E6%B7%B1%E5%BA%A6%E6%8E%A2%E8%AE%A8%E4%BB%8E%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E5%88%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%B8%E7%AD%89%E6%80%A7%E6%AF%94%E8%BE%83/</guid>
        <description>&lt;h1 id=&#34;记录类型与集合&#34;&gt;记录类型与集合
&lt;/h1&gt;&lt;p&gt;本文某种程度上记录了我在选举站点中使用记录类型和集合时遇到的各种摩擦点。&lt;/p&gt;
&lt;h2 id=&#34;记录类型回顾&#34;&gt;记录类型回顾
&lt;/h2&gt;&lt;p&gt;这可能是本系列中最具普适性的博客文章。尽管记录类型自C# 10就已存在，但我个人使用不多（虽然我期待这个功能已有十多年，不过那是另一回事）。&lt;/p&gt;
&lt;p&gt;决定将所有数据模型设为不可变后，在C#中使用记录类型（我始终使用密封记录）来实现这些模型几乎是理所当然的选择。只需用主构造函数的语法指定所需属性，编译器就会自动生成大量样板代码。&lt;/p&gt;
&lt;p&gt;简单示例如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;sealed&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;record&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Candidate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int?&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MySocietyId&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int?&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ParliamentId&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这生成的代码大致等效于：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;sealed&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Candidate&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;IEquatable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Candidate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 属性声明、构造函数、Equals、GetHashCode等完整实现&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 包含解构方法和with表达式支持&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;（为简洁起见省略了完整代码，实际还包含EqualityContract等细节）&lt;/p&gt;
&lt;h2 id=&#34;记录类型的相等性比较&#34;&gt;记录类型的相等性比较
&lt;/h2&gt;&lt;p&gt;默认情况下，记录类型为每个属性使用&lt;code&gt;EqualityComparer&amp;lt;T&amp;gt;.Default&lt;/code&gt;。当属性类型的默认相等比较器符合需求时这很完美——但并非总是如此。在我们的选举数据模型中，大多数类型没问题，但&lt;code&gt;ImmutableList&amp;lt;T&amp;gt;&lt;/code&gt;不适用，而我们大量使用了这种类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ImmutableList&amp;lt;T&amp;gt;&lt;/code&gt;本身没有重写&lt;code&gt;Equals&lt;/code&gt;和&lt;code&gt;GetHashCode&lt;/code&gt;——因此具有引用相等语义。我真正需要的是使用元素类型的相等比较器，判断两个不可变列表是否具有相同数量的元素，且元素按顺序成对相等。&lt;/p&gt;
&lt;p&gt;遗憾的是，C#记录类型目前无法为单个属性指定自定义相等比较器。如果手动实现&lt;code&gt;Equals&lt;/code&gt;和&lt;code&gt;GetHashCode&lt;/code&gt;方法，就需要为所有属性实现比较逻辑——这意味着添加新属性时必须记得更新这些方法（我就至少忘记过一次）。&lt;/p&gt;
&lt;p&gt;我期望的解决方案是能够通过特性指示编译器使用指定的相等比较器提供程序。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;sealed&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;record&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Ballot&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;Constituency&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Constituency&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;    [IEqualityComparerProvider(typeof(CollectionEqualityProvider))]&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;ImmutableList&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Candidacy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Candidacies&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;引用相等性&#34;&gt;引用相等性
&lt;/h2&gt;&lt;p&gt;在我的数据模型文章中提过，在单个&lt;code&gt;ElectionContext&lt;/code&gt;中，我们只需要引用相等性。创建&lt;code&gt;ImmutableDictionary&amp;lt;Constituency, Result&amp;gt;&lt;/code&gt;时，我希望提供仅执行引用比较的&lt;code&gt;IEqualityComparer&amp;lt;Constituency&amp;gt;&lt;/code&gt;。虽然这看似简单，但发现它显著影响了上下文重载时构建视图模型的时间。&lt;/p&gt;
&lt;p&gt;.NET 5+实际上已经提供了&lt;code&gt;System.Collections.Generic.ReferenceEqualityComparer&lt;/code&gt;，但我最初错误地忽略了它——因为它实现了非泛型的&lt;code&gt;IEqualityComparer&amp;lt;object&amp;gt;&lt;/code&gt;。后来才意识到&lt;code&gt;IEqualityComparer&amp;lt;T&amp;gt;&lt;/code&gt;是逆变的，完全可以安全使用。&lt;/p&gt;
&lt;h2 id=&#34;字符串序数比较&#34;&gt;字符串序数比较
&lt;/h2&gt;&lt;p&gt;字符串比较总是让我紧张。虽然默认字符串比较对于&lt;code&gt;Equals&lt;/code&gt;和&lt;code&gt;GetHashCode&lt;/code&gt;是序数的，但对于&lt;code&gt;CompareTo&lt;/code&gt;是文化敏感的。由于我几乎总是想要序数比较，因此创建了一系列扩展方法使意图更明确，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;OrderByOrdinal&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OrderByOrdinalDescending&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ToImmutableOrdinalDictionary&lt;/code&gt;（4个重载）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ToOrdinalLookup&lt;/code&gt;（2个重载）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;visual-studio工具链问题&#34;&gt;Visual Studio工具链问题
&lt;/h2&gt;&lt;p&gt;在VS中使用&amp;quot;调用层次结构&amp;quot;(Ctrl+K, Ctrl+T)时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主构造函数和记录参数的&amp;quot;调用层次结构&amp;quot;不工作（尽管&amp;quot;查找引用&amp;quot;可以）&lt;/li&gt;
&lt;li&gt;无法查看&amp;quot;调用构造函数&amp;quot;的层次结构&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;功能需求总结&#34;&gt;功能需求总结
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;支持按属性控制生成的相等比较逻辑&lt;/li&gt;
&lt;li&gt;为不可变集合提供内置相等比较器&lt;/li&gt;
&lt;li&gt;提供泛型引用相等比较器实现&lt;/li&gt;
&lt;li&gt;增强VS对记录类型的工具支持&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论
&lt;/h2&gt;&lt;p&gt;尽管存在这些摩擦点，记录类型在站点中表现良好，不可变集合的天然支持也很棒——只是在比较操作方面还需要更多支持。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
