<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>程序分析 on 办公AI智能小助手</title>
        <link>http://localhost:1313/tags/%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/</link>
        <description>Recent content in 程序分析 on 办公AI智能小助手</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>qife</copyright>
        <lastBuildDate>Sat, 09 Aug 2025 16:56:48 +0800</lastBuildDate><atom:link href="http://localhost:1313/tags/%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>驯服文件解析风险的两款新工具：PolyFile与PolyTracker</title>
        <link>http://localhost:1313/p/%E9%A9%AF%E6%9C%8D%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E9%A3%8E%E9%99%A9%E7%9A%84%E4%B8%A4%E6%AC%BE%E6%96%B0%E5%B7%A5%E5%85%B7polyfile%E4%B8%8Epolytracker/</link>
        <pubDate>Sat, 09 Aug 2025 16:56:48 +0800</pubDate>
        
        <guid>http://localhost:1313/p/%E9%A9%AF%E6%9C%8D%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E9%A3%8E%E9%99%A9%E7%9A%84%E4%B8%A4%E6%AC%BE%E6%96%B0%E5%B7%A5%E5%85%B7polyfile%E4%B8%8Epolytracker/</guid>
        <description>&lt;h3 id=&#34;驯服文件解析风险的两款新工具&#34;&gt;驯服文件解析风险的两款新工具
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Evan Sultanik | 2019年11月1日&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解析文件格式是困难的——即使规范明确定义时也是如此。当规范存在歧义时，会导致解析器和解释器出现意外行为，进而引发安全漏洞。在DARPA SafeDocs项目支持下，我们开发了两款工具来解决这一根本问题：&lt;/p&gt;
&lt;h4 id=&#34;解析为何困难&#34;&gt;解析为何困难？
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;多语言文件（Polyglots）&lt;/strong&gt;：单个文件可被不同解释器有效解析（如既是PDF又是ZIP）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;精神分裂文件（Schizophrenic）&lt;/strong&gt;：不同解析器对同一文件产生不同解释（如Adobe与Foxit解析同一PDF显示不同内容）&lt;/li&gt;
&lt;li&gt;复杂设计决策（如嵌入式图灵完备语言、流解码器任意链接等）加剧了攻击面&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;工具创新&#34;&gt;工具创新
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;PolyFile&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持10,000+文件格式的层次化语义标注&lt;/li&gt;
&lt;li&gt;生成交互式HTML分析报告（示例：简历文件同时是PDF/NES游戏/ZIP/git仓库）&lt;/li&gt;
&lt;li&gt;开源地址：https://github.com/trailofbits/polyfile&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;PolyTracker&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于LLVM的高效污点跟踪框架&lt;/li&gt;
&lt;li&gt;改进数据结构使内存需求从指数级降至线性级&lt;/li&gt;
&lt;li&gt;支持闭源代码分析（通过McSema等二进制提升技术）&lt;/li&gt;
&lt;li&gt;开源地址：https://github.com/trailofbits/polytracker&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;技术突破&#34;&gt;技术突破
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数据流消毒器（DFSan）优化&lt;/strong&gt;：突破原16位污点标签限制，实现稀疏联合数据结构&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态分析&lt;/strong&gt;：通过构建解析器函数与输入字节偏移的映射关系，逆向推导解析逻辑&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;容器化部署&lt;/strong&gt;：提供预构建Docker镜像简化使用流程&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;应用场景&#34;&gt;应用场景
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;识别规范与实现间的&amp;quot;不安全&amp;quot;差异&lt;/li&gt;
&lt;li&gt;检测解析器中的隐蔽通道&lt;/li&gt;
&lt;li&gt;辅助模糊测试与差分测试&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>检测不良OpenSSL使用模式 - Anselm工具深度解析</title>
        <link>http://localhost:1313/p/%E6%A3%80%E6%B5%8B%E4%B8%8D%E8%89%AFopenssl%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%BC%8F-anselm%E5%B7%A5%E5%85%B7%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</link>
        <pubDate>Wed, 06 Aug 2025 10:56:03 +0800</pubDate>
        
        <guid>http://localhost:1313/p/%E6%A3%80%E6%B5%8B%E4%B8%8D%E8%89%AFopenssl%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%BC%8F-anselm%E5%B7%A5%E5%85%B7%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</guid>
        <description>&lt;h1 id=&#34;检测不良openssl使用模式&#34;&gt;检测不良OpenSSL使用模式
&lt;/h1&gt;&lt;p&gt;OpenSSL是最流行的密码学库之一，即便您不使用C/C++，您所用编程语言的核心库很可能也包含OpenSSL绑定。由于其底层API的设计特点，这个库极易被误用。幸运的是，许多错误都遵循可识别的模式，这为自动化检测提供了可能。&lt;/p&gt;
&lt;p&gt;在冬季和春季的实习期间，我开发了名为Anselm的工具原型。这是一个LLVM编译中间层分析工具，能够识别开发者定义的不良行为模式。与静态分析相比，Anselm的优势在于它能处理任何可编译为LLVM字节码的语言，或任何可逆向为机器码的闭源代码。&lt;/p&gt;
&lt;h2 id=&#34;openssl的挑战&#34;&gt;OpenSSL的挑战
&lt;/h2&gt;&lt;p&gt;OpenSSL的设计对初学者极不友好：其库中存在不一致的命名规范，为每个加密原语提供过多选项和模式。例如同时存在高级(EVP)和低级方法来完成相同任务（如DSA签名或EC签名操作）。更糟的是，其文档也常常不一致且难以理解。&lt;/p&gt;
&lt;p&gt;该API的危险性还体现在：不一致地返回错误码、指针（含所有权和不含所有权）以及其他意外行为。若不严格检查错误码或防范空指针，就会导致程序异常终止。&lt;/p&gt;
&lt;h2 id=&#34;函数调用分析&#34;&gt;函数调用分析
&lt;/h2&gt;&lt;p&gt;Anselm的核心方法是遍历函数中所有可能的执行路径，寻找不良的API调用序列。以对称加密函数为例，&lt;code&gt;EVP_EncryptUpdate&lt;/code&gt;（加密数据块）和&lt;code&gt;EVP_EncryptFinal_ex&lt;/code&gt;（最终加密前填充明文）不应乱序调用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;EVP_EncryptFinal_ex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ciphertext&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;EVP_EncryptUpdate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ciphertext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;plaintext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;plaintext_len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;工具使用LLVM BasicBlocks（代表一组总是顺序执行的指令）构建函数调用图，通过带限制的深度优先搜索(DFS)来发现所有可能的执行路径。为提升性能，会先剪除不含相关API调用的BasicBlock，这能显著降低图复杂度。&lt;/p&gt;
&lt;h2 id=&#34;值匹配技术&#34;&gt;值匹配技术
&lt;/h2&gt;&lt;p&gt;仅检查函数调用还不够。考虑OpenSSL上下文的使用场景：通过&lt;code&gt;EVP_CIPHER_CTX_new&lt;/code&gt;创建后，必须用算法、密钥等初始化才能使用。Anselm通过匹配LLVM Value对象来实现精确检测：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;EVP_CIPHER_CTX_new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ctx1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;EVP_CIPHER_CTX_new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ctx2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;EVP_EncryptInit_ex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ctx1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;EVP_aes_256_cbc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;iv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// ctx2未被初始化
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;该技术同样可检测重复初始化向量(IV)的使用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;EVP_EncryptInit_ex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ctx1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;EVP_aes_256_cbc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;iv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;EVP_EncryptInit_ex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ctx2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;EVP_aes_256_cbc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;iv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 重复使用iv
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;模式定义语法&#34;&gt;模式定义语法
&lt;/h2&gt;&lt;p&gt;我开发了专门的模式定义语言，开发者可通过正则表达式风格的语法指定不良行为模式。例如禁止重复IV的规则：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;EVP_EncryptInit_ex _ _ _ _ _ iv
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;EVP_EncryptInit_ex _ _ _ _ _ iv
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;还支持否定前瞻语法，例如要求上下文必须初始化后才能使用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;EVP_CIPHER_CTX_new ctx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;! EVP_EncryptInit_ex _ ctx _ _ _ _
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;EVP_EncryptUpdate _ ctx _ _ _ _
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;总结&#34;&gt;总结
&lt;/h2&gt;&lt;p&gt;Anselm当前已能解析广泛的函数调用模式并在LLVM字节码中搜索它们。虽然仍是原型，但核心思路已经验证可行。感谢Trail of Bits支持这类实习项目——整个过程充满乐趣！&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Siderophile：暴露Rust代码库中的不安全操作</title>
        <link>http://localhost:1313/p/siderophile%E6%9A%B4%E9%9C%B2rust%E4%BB%A3%E7%A0%81%E5%BA%93%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%AE%89%E5%85%A8%E6%93%8D%E4%BD%9C/</link>
        <pubDate>Wed, 06 Aug 2025 08:22:18 +0800</pubDate>
        
        <guid>http://localhost:1313/p/siderophile%E6%9A%B4%E9%9C%B2rust%E4%BB%A3%E7%A0%81%E5%BA%93%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%AE%89%E5%85%A8%E6%93%8D%E4%BD%9C/</guid>
        <description>&lt;p&gt;今天我们发布了一款名为siderophile的工具，它能帮助Rust开发者在代码库中寻找模糊测试目标。该工具会扫描crate的所有依赖项，定位每个不安全函数、表达式、特质方法等，然后沿调用图追溯至使用这些不安全元素的源头函数，并按危险程度（badness）进行排序——函数使用的不安全元素越多，其危险等级就越高。&lt;/p&gt;
&lt;p&gt;Siderophile（[ˈsidərəˌfīl]）——对金属铁有亲和力&lt;/p&gt;
&lt;p&gt;我们在一次紧急代码审计任务中开发了这个工具。当时需要短时间内审查一个庞大的Rust代码库，通过siderophile自动化定位高风险函数，显著加速了漏洞发现过程。现在我们将这个工具开源。&lt;/p&gt;
&lt;h3 id=&#34;示例输出&#34;&gt;示例输出
&lt;/h3&gt;&lt;p&gt;在MLS加密协议实现库molasses上运行的示例结果：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;危险度&lt;/th&gt;
          &lt;th&gt;函数&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;012&lt;/td&gt;
          &lt;td&gt;molasses::crypto::hash::HashFunction::hash_serializable&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;005&lt;/td&gt;
          &lt;td&gt;molasses::crypto::hash::HashContext::feed_serializable&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;003&lt;/td&gt;
          &lt;td&gt;molasses::utils::derive_node_values&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&amp;hellip;&lt;/td&gt;
          &lt;td&gt;&amp;hellip;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;可见主要风险集中在序列化和加密相关例程中，这些将是1.0版本前的重点模糊测试对象。&lt;/p&gt;
&lt;h3 id=&#34;局限性&#34;&gt;局限性
&lt;/h3&gt;&lt;p&gt;当前版本无法检测宏和动态分发方法中的不安全操作，且在某些crate上存在误报。我们正在积极维护项目，欢迎贡献者参与改进。&lt;/p&gt;
&lt;h3 id=&#34;立即试用&#34;&gt;立即试用
&lt;/h3&gt;&lt;p&gt;Siderophile已发布在GitHub，包含详细使用说明。建议对您的Rust crate运行该工具，并针对发现的高风险函数设置模糊测试。&lt;/p&gt;
&lt;p&gt;最后感谢cargo-geiger和rust-praezi项目的先驱工作。本工具很大程度上基于他们的成果。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Magnifier：交互式反编译的实验性工具</title>
        <link>http://localhost:1313/p/magnifier%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%8F%8D%E7%BC%96%E8%AF%91%E7%9A%84%E5%AE%9E%E9%AA%8C%E6%80%A7%E5%B7%A5%E5%85%B7/</link>
        <pubDate>Sat, 02 Aug 2025 17:43:34 +0800</pubDate>
        
        <guid>http://localhost:1313/p/magnifier%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%8F%8D%E7%BC%96%E8%AF%91%E7%9A%84%E5%AE%9E%E9%AA%8C%E6%80%A7%E5%B7%A5%E5%85%B7/</guid>
        <description>&lt;h3 id=&#34;trail-of-bits的反编译技术栈&#34;&gt;Trail of Bits的反编译技术栈
&lt;/h3&gt;&lt;p&gt;Trail of Bits正在开发多个与程序反编译相关的开源项目：Remill、Anvill、Rellic以及新推出的Magnifier。其技术策略是通过多级中间表示（IR）逐步提升编译程序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Remill&lt;/strong&gt;：将机器指令转换为LLVM IR&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Anvill&lt;/strong&gt;：把机器码函数转化为LLVM函数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Rellic&lt;/strong&gt;：通过Clang AST将LLVM IR转换为C代码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Magnifier创新性地实现了在任意管道阶段进行交互式转换，研究人员可以实时操作Anvill的LLVM IR并查看Rellic生成的C代码。&lt;/p&gt;
&lt;h3 id=&#34;从repl起步的原型&#34;&gt;从REPL起步的原型
&lt;/h3&gt;&lt;p&gt;Magnifier最初作为命令行REPL（读取-求值-输出循环）开发，支持以下核心转换操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用LLVM优化函数&lt;/li&gt;
&lt;li&gt;函数内联&lt;/li&gt;
&lt;li&gt;带/不带常量折叠的值替换&lt;/li&gt;
&lt;li&gt;函数指针去虚拟化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关键技术实现包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;唯一标识系统&lt;/strong&gt;：为所有函数、参数、基本块和IR指令分配不透明ID&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;指令溯源机制&lt;/strong&gt;：通过&amp;quot;当前ID|源ID&amp;quot;的双重标识追踪转换过程&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通用替换接口&lt;/strong&gt;：允许用户监控、允许或拒绝每个替换步骤&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;可视化界面magnifierui&#34;&gt;可视化界面MagnifierUI
&lt;/h3&gt;&lt;p&gt;基于Vue.js前端和C++后端的MagnifierUI具有以下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多会话WebSocket通信架构&lt;/li&gt;
&lt;li&gt;并列显示LLVM IR与Rellic生成的C代码&lt;/li&gt;
&lt;li&gt;支持指令级高亮关联&lt;/li&gt;
&lt;li&gt;集成优化按钮调用LLVM全套优化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;典型工作流示例：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;上传二进制文件&lt;/li&gt;
&lt;li&gt;在终端视图执行参数值替换&lt;/li&gt;
&lt;li&gt;实时观察IR和C代码同步更新&lt;/li&gt;
&lt;li&gt;通过内联按钮优化函数调用&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;llvm优化的实战演示&#34;&gt;LLVM优化的实战演示
&lt;/h3&gt;&lt;p&gt;通过&amp;quot;fibIter(100)&amp;ldquo;案例展示Magnifier的威力：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;内联fibIter函数调用&lt;/li&gt;
&lt;li&gt;执行LLVM优化&lt;/li&gt;
&lt;li&gt;直接获得结果值3314859971（第100个斐波那契数）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;该过程避免了动态调试的复杂性，展示了如何将含循环/条件语句的复杂函数简化为常量。&lt;/p&gt;
&lt;h3 id=&#34;未来发展方向&#34;&gt;未来发展方向
&lt;/h3&gt;&lt;p&gt;项目规划包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;扩展转换类型支持（最终实现完整补丁集）&lt;/li&gt;
&lt;li&gt;集成Anvill直接解析二进制文件&lt;/li&gt;
&lt;li&gt;增强可视化界面的交互功能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Magnifier通过创新的交互式反编译方法，正在重新定义逆向工程的研究范式。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Maat：让符号执行变得简单 - 跨架构多功能符号执行框架</title>
        <link>http://localhost:1313/p/maat%E8%AE%A9%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E5%8F%98%E5%BE%97%E7%AE%80%E5%8D%95-%E8%B7%A8%E6%9E%B6%E6%9E%84%E5%A4%9A%E5%8A%9F%E8%83%BD%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E6%A1%86%E6%9E%B6/</link>
        <pubDate>Sat, 02 Aug 2025 11:26:19 +0800</pubDate>
        
        <guid>http://localhost:1313/p/maat%E8%AE%A9%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E5%8F%98%E5%BE%97%E7%AE%80%E5%8D%95-%E8%B7%A8%E6%9E%B6%E6%9E%84%E5%A4%9A%E5%8A%9F%E8%83%BD%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E6%A1%86%E6%9E%B6/</guid>
        <description>&lt;h1 id=&#34;maat让符号执行变得简单&#34;&gt;Maat：让符号执行变得简单
&lt;/h1&gt;&lt;p&gt;我们发布了Maat——一个跨架构、多用途且用户友好的符号执行框架。它提供动态符号执行（DSE）、污点分析、二进制插桩、环境模拟和约束求解等核心功能。基于Ghidra的中间表示语言p-code，Maat兼具C++高性能API和Python便捷接口，既适合安全专家也方便初学者入门。&lt;/p&gt;
&lt;h2 id=&#34;用户友好的灵活api&#34;&gt;用户友好的灵活API
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;提供C++底层API和Python绑定&lt;/li&gt;
&lt;li&gt;调试器式交互：支持启动/暂停/回滚执行过程&lt;/li&gt;
&lt;li&gt;支持通过回调函数插桩目标代码（寄存器/内存访问等事件触发）&lt;/li&gt;
&lt;li&gt;可定制符号数据处理策略（符号指针处理、状态约束保存等）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;丰富的架构支持&#34;&gt;丰富的架构支持
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;基于Ghidra的sleigh库实现跨架构支持&lt;/li&gt;
&lt;li&gt;当前已验证X86/X64架构&lt;/li&gt;
&lt;li&gt;未来计划支持Java/Dalvik/Ethereum等虚拟机字节码&lt;/li&gt;
&lt;li&gt;无需安装Ghidra即可使用独立版sleigh&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;性能优化设计&#34;&gt;性能优化设计
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;纯C++核心实现&lt;/li&gt;
&lt;li&gt;实测性能：主流笔记本每秒执行10-30万条指令（2.3GHz i7/32GB RAM）&lt;/li&gt;
&lt;li&gt;未来将添加运行时瓶颈诊断功能&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;快速开始&#34;&gt;快速开始
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;安装：&lt;code&gt;python3 -m pip install pymaat&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查看&lt;a class=&#34;link&#34; href=&#34;https://maat.re/docs/tutorials&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;教程系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;访问&lt;a class=&#34;link&#34; href=&#34;https://github.com/trailofbits/maat&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GitHub仓库&lt;/a&gt;获取源码和API文档&lt;/li&gt;
&lt;li&gt;通过GitHub讨论区提交反馈&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        
    </channel>
</rss>
