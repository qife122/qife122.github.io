<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>C# on 办公AI智能小助手</title>
        <link>http://localhost:1313/tags/c%23/</link>
        <description>Recent content in C# on 办公AI智能小助手</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>qife</copyright>
        <lastBuildDate>Tue, 05 Aug 2025 22:12:27 +0800</lastBuildDate><atom:link href="http://localhost:1313/tags/c%23/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>C#记录类型与集合的深度探讨：从自动生成代码到自定义相等性比较</title>
        <link>http://localhost:1313/p/c%23%E8%AE%B0%E5%BD%95%E7%B1%BB%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%9A%84%E6%B7%B1%E5%BA%A6%E6%8E%A2%E8%AE%A8%E4%BB%8E%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E5%88%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%B8%E7%AD%89%E6%80%A7%E6%AF%94%E8%BE%83/</link>
        <pubDate>Tue, 05 Aug 2025 22:12:27 +0800</pubDate>
        
        <guid>http://localhost:1313/p/c%23%E8%AE%B0%E5%BD%95%E7%B1%BB%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%9A%84%E6%B7%B1%E5%BA%A6%E6%8E%A2%E8%AE%A8%E4%BB%8E%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E5%88%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%B8%E7%AD%89%E6%80%A7%E6%AF%94%E8%BE%83/</guid>
        <description>&lt;h1 id=&#34;记录类型与集合&#34;&gt;记录类型与集合
&lt;/h1&gt;&lt;p&gt;本文某种程度上记录了我在选举站点中使用记录类型和集合时遇到的各种摩擦点。&lt;/p&gt;
&lt;h2 id=&#34;记录类型回顾&#34;&gt;记录类型回顾
&lt;/h2&gt;&lt;p&gt;这可能是本系列中最具普适性的博客文章。尽管记录类型自C# 10就已存在，但我个人使用不多（虽然我期待这个功能已有十多年，不过那是另一回事）。&lt;/p&gt;
&lt;p&gt;决定将所有数据模型设为不可变后，在C#中使用记录类型（我始终使用密封记录）来实现这些模型几乎是理所当然的选择。只需用主构造函数的语法指定所需属性，编译器就会自动生成大量样板代码。&lt;/p&gt;
&lt;p&gt;简单示例如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;sealed&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;record&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Candidate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int?&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MySocietyId&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int?&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ParliamentId&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这生成的代码大致等效于：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;sealed&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Candidate&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;IEquatable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Candidate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 属性声明、构造函数、Equals、GetHashCode等完整实现&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 包含解构方法和with表达式支持&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;（为简洁起见省略了完整代码，实际还包含EqualityContract等细节）&lt;/p&gt;
&lt;h2 id=&#34;记录类型的相等性比较&#34;&gt;记录类型的相等性比较
&lt;/h2&gt;&lt;p&gt;默认情况下，记录类型为每个属性使用&lt;code&gt;EqualityComparer&amp;lt;T&amp;gt;.Default&lt;/code&gt;。当属性类型的默认相等比较器符合需求时这很完美——但并非总是如此。在我们的选举数据模型中，大多数类型没问题，但&lt;code&gt;ImmutableList&amp;lt;T&amp;gt;&lt;/code&gt;不适用，而我们大量使用了这种类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ImmutableList&amp;lt;T&amp;gt;&lt;/code&gt;本身没有重写&lt;code&gt;Equals&lt;/code&gt;和&lt;code&gt;GetHashCode&lt;/code&gt;——因此具有引用相等语义。我真正需要的是使用元素类型的相等比较器，判断两个不可变列表是否具有相同数量的元素，且元素按顺序成对相等。&lt;/p&gt;
&lt;p&gt;遗憾的是，C#记录类型目前无法为单个属性指定自定义相等比较器。如果手动实现&lt;code&gt;Equals&lt;/code&gt;和&lt;code&gt;GetHashCode&lt;/code&gt;方法，就需要为所有属性实现比较逻辑——这意味着添加新属性时必须记得更新这些方法（我就至少忘记过一次）。&lt;/p&gt;
&lt;p&gt;我期望的解决方案是能够通过特性指示编译器使用指定的相等比较器提供程序。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;sealed&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;record&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Ballot&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;Constituency&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Constituency&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;    [IEqualityComparerProvider(typeof(CollectionEqualityProvider))]&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;ImmutableList&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Candidacy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Candidacies&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;引用相等性&#34;&gt;引用相等性
&lt;/h2&gt;&lt;p&gt;在我的数据模型文章中提过，在单个&lt;code&gt;ElectionContext&lt;/code&gt;中，我们只需要引用相等性。创建&lt;code&gt;ImmutableDictionary&amp;lt;Constituency, Result&amp;gt;&lt;/code&gt;时，我希望提供仅执行引用比较的&lt;code&gt;IEqualityComparer&amp;lt;Constituency&amp;gt;&lt;/code&gt;。虽然这看似简单，但发现它显著影响了上下文重载时构建视图模型的时间。&lt;/p&gt;
&lt;p&gt;.NET 5+实际上已经提供了&lt;code&gt;System.Collections.Generic.ReferenceEqualityComparer&lt;/code&gt;，但我最初错误地忽略了它——因为它实现了非泛型的&lt;code&gt;IEqualityComparer&amp;lt;object&amp;gt;&lt;/code&gt;。后来才意识到&lt;code&gt;IEqualityComparer&amp;lt;T&amp;gt;&lt;/code&gt;是逆变的，完全可以安全使用。&lt;/p&gt;
&lt;h2 id=&#34;字符串序数比较&#34;&gt;字符串序数比较
&lt;/h2&gt;&lt;p&gt;字符串比较总是让我紧张。虽然默认字符串比较对于&lt;code&gt;Equals&lt;/code&gt;和&lt;code&gt;GetHashCode&lt;/code&gt;是序数的，但对于&lt;code&gt;CompareTo&lt;/code&gt;是文化敏感的。由于我几乎总是想要序数比较，因此创建了一系列扩展方法使意图更明确，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;OrderByOrdinal&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OrderByOrdinalDescending&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ToImmutableOrdinalDictionary&lt;/code&gt;（4个重载）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ToOrdinalLookup&lt;/code&gt;（2个重载）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;visual-studio工具链问题&#34;&gt;Visual Studio工具链问题
&lt;/h2&gt;&lt;p&gt;在VS中使用&amp;quot;调用层次结构&amp;quot;(Ctrl+K, Ctrl+T)时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主构造函数和记录参数的&amp;quot;调用层次结构&amp;quot;不工作（尽管&amp;quot;查找引用&amp;quot;可以）&lt;/li&gt;
&lt;li&gt;无法查看&amp;quot;调用构造函数&amp;quot;的层次结构&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;功能需求总结&#34;&gt;功能需求总结
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;支持按属性控制生成的相等比较逻辑&lt;/li&gt;
&lt;li&gt;为不可变集合提供内置相等比较器&lt;/li&gt;
&lt;li&gt;提供泛型引用相等比较器实现&lt;/li&gt;
&lt;li&gt;增强VS对记录类型的工具支持&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论
&lt;/h2&gt;&lt;p&gt;尽管存在这些摩擦点，记录类型在站点中表现良好，不可变集合的天然支持也很棒——只是在比较操作方面还需要更多支持。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>使用C#构建MCP服务器并在VS Code中运行AI代理</title>
        <link>http://localhost:1313/p/%E4%BD%BF%E7%94%A8c%23%E6%9E%84%E5%BB%BAmcp%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B9%B6%E5%9C%A8vs-code%E4%B8%AD%E8%BF%90%E8%A1%8Cai%E4%BB%A3%E7%90%86/</link>
        <pubDate>Mon, 04 Aug 2025 00:53:25 +0800</pubDate>
        
        <guid>http://localhost:1313/p/%E4%BD%BF%E7%94%A8c%23%E6%9E%84%E5%BB%BAmcp%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B9%B6%E5%9C%A8vs-code%E4%B8%AD%E8%BF%90%E8%A1%8Cai%E4%BB%A3%E7%90%86/</guid>
        <description>&lt;img src="https://i.imgs.ovh/2025/08/04/JhGjb.jpeg" alt="Featured image of post 使用C#构建MCP服务器并在VS Code中运行AI代理" /&gt;&lt;h1 id=&#34;构建基于mcp协议的ai代理&#34;&gt;构建基于MCP协议的AI代理
&lt;/h1&gt;&lt;p&gt;大型语言模型（如GPT-4o、Claude或Gemini）在处理通用问题时表现优异，但往往难以应对特定领域查询（例如&amp;quot;仅显示戴尔设备信息&amp;quot;）。这是因为它们缺乏访问专有/内部数据的渠道。Model Context Protocol（MCP）通过提供上下文数据解决了这一痛点。&lt;/p&gt;
&lt;h2 id=&#34;核心组件&#34;&gt;核心组件
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;MCP Host&lt;/strong&gt;：支持MCP的IDE（如VS Code）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MCP Server&lt;/strong&gt;：托管工具并通过MCP协议暴露上下文数据&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MCP Client&lt;/strong&gt;：连接Host与Server的桥梁&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;实现步骤&#34;&gt;实现步骤
&lt;/h2&gt;&lt;h3 id=&#34;1-创建mcp服务器项目&#34;&gt;1. 创建MCP服务器项目
&lt;/h3&gt;&lt;p&gt;使用C# SDK构建自定义服务器，关键代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;builder&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;WebApplication&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CreateBuilder&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;try&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;builder&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Services&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;AddMcpServer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;WithStdioServerTransport&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;WithToolsFromAssembly&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;catch&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;Console&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;WriteLine&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;$&amp;#34;Error: {ex.Message}&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;AddMcpServer()&lt;/code&gt;方法将项目转换为MCP服务器，&lt;code&gt;WithToolsFromAssembly()&lt;/code&gt;自动扫描并注册工具。&lt;/p&gt;
&lt;h3 id=&#34;2-开发mcp工具&#34;&gt;2. 开发MCP工具
&lt;/h3&gt;&lt;p&gt;工具元数据（标题和描述）帮助LLM进行语义匹配。示例工具代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;[McpServerToolType]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;BYODTool&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;    [McpServerTool(Description = &amp;#34;获取外设信息&amp;#34;)]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;GetPeripherals&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;message&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// 实现API调用逻辑&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;JsonConvert&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SerializeObject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;responseData&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;3-配置vs-code工作区&#34;&gt;3. 配置VS Code工作区
&lt;/h3&gt;&lt;p&gt;在.vscode目录创建mcp.json配置文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;servers&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;my-mcp-server&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;stdio&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;command&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;dotnet&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;args&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;run&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;--project&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;/path/to/project.csproj&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;4-运行流程&#34;&gt;4. 运行流程
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;MCP客户端通过VS Code连接服务器&lt;/li&gt;
&lt;li&gt;用户在Copilot聊天窗口输入提示（如&amp;quot;仅显示戴尔设备&amp;quot;）&lt;/li&gt;
&lt;li&gt;LLM根据工具描述选择执行&lt;code&gt;GetPeripherals&lt;/code&gt;工具&lt;/li&gt;
&lt;li&gt;工具从安全API获取数据后，LLM生成最终响应&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;架构优势&#34;&gt;架构优势
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;模块化设计&lt;/strong&gt;：工具可独立开发和部署&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;上下文感知&lt;/strong&gt;：动态获取实时数据&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;安全通信&lt;/strong&gt;：支持Bearer Token认证&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;跨平台支持&lt;/strong&gt;：基于标准stdio通信&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;该方案显著提升了AI代理处理领域特定任务的能力，同时保持了系统的可扩展性和可维护性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;图示说明：MCP架构实现了从用户提示→工具选择→数据获取→响应生成的全自动闭环流程。&lt;/p&gt;&lt;/blockquote&gt;
</description>
        </item>
        
    </channel>
</rss>
