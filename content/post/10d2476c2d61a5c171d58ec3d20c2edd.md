---
date: 2025-08-06T16:10:02+08:00
title: 使用CodeQL检测C++迭代器失效问题
tags: [CodeQL, C++, 静态分析]
authors: qife
description: 本文介绍了如何使用CodeQL静态分析工具检测C++中的迭代器失效问题，包括Itergator工具的开发原理、实际案例分析和在大型代码库中的应用效果。
---

# 使用CodeQL检测迭代器失效

迭代器失效是C++中常见且隐蔽的一类错误，经常导致可利用的漏洞。在Trail of Bits实习期间，我开发了Itergator——一组用于分析和发现迭代器失效的CodeQL类和查询。

## 迭代器定义

迭代器是C++中遍历容器内容的标准方式。迭代器对象至少支持两种操作：解引用（获取容器中的底层对象）和递增（获取下一个元素的迭代器）。

```cpp
std::vector<int> vec{1, 2, 3, 4, 5};

for (std::vector<int>::iterator it = vec.begin(), end = vec.end(); it != end; ++it) {
    std::cout << *it << " ";
}
```

## 迭代器失效

当容器发生某些修改（如添加或删除元素）后，迭代器会失效。根据标准，使用失效迭代器属于未定义行为。

```cpp
void zone_manager::deserialize( JsonIn &jsin )
{
    jsin.read( zones );
    for( auto it = zones.begin(); it != zones.end(); ++it ) {
        const zone_type_id zone_type = it->get_type();
        if( !has_type( zone_type ) ) {
            zones.erase( it );
            debugmsg( "Invalid zone type: %s", zone_type.c_str() );
        }
    }
}
```

## CodeQL简介

CodeQL是GitHub开发的静态分析框架，允许使用类似SQL的语法查询代码库。它具有面向对象的类系统，其中谓词定义逻辑属性和关系。

## 检测迭代器失效

使用静态分析检测迭代器失效面临多个挑战。Itergator通过以下方式解决：

1. 构建可能使迭代器失效的函数调用图
2. 定义核心类：
   - Iterator：存储迭代器的变量
   - Iterated：被迭代的集合
   - Invalidator：可能导致迭代器失效的函数调用
   - Invalidation：直接使迭代器失效的函数调用

```codeql
class PotentialInvalidationDestructor extends PotentialInvalidation {
    PotentialInvalidationDestructor() {
        this instanceof MemberFunction
        and this.getName().matches("~%")
    }

    override predicate invalidates(Iterated i) {
        i.getType().refersTo(this.getParentScope())
    }
}
```

## 复杂案例

在Google的正则表达式库中发现的一个复杂bug展示了该项目的挑战性。这个失效发生在循环的三次迭代中：第一次初始化迭代器，然后失效，最后使用失效的迭代器。

## 结论

Itergator是检测各种规模代码库中复杂迭代器失效的强大工具。尽管存在一些引擎bug，但与CodeQL的声明式查询语言合作非常愉快。

特别感谢我的导师Josh和Trail of Bits的所有人，这是我工作过的最好的地方！如果有任何问题，欢迎在Twitter @themalwareman上联系我。