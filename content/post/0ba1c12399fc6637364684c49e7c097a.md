---
date: 2025-08-03T08:12:00+08:00
title: 深入解析V8引擎TurboFan的漏洞利用技术
tags: [V8, TurboFan, JIT, 漏洞利用]
authors: qife
description: 本文详细分析了V8引擎中TurboFan优化编译器的一个漏洞，通过精度丢失问题实现越界读写，最终构建出完整的利用链实现任意代码执行。文章从TurboFan的基本原理讲起，逐步深入漏洞细节和利用技术。
---

# 引言

很久以前我写过一篇关于内核池的博客文章，今年我们要在节点的海洋中畅游！当前趋势是攻击JavaScript引擎，特别是优化JIT编译器，如V8的TurboFan、SpiderMonkey的IonMonkey、JavaScriptCore的DFG & FTL或Chakra的SimpleJIT & FullJIT。

本文将重点讨论TurboFan及其使用的"节点海洋"结构。然后，我们将研究Google CTF 2018中由@_tsuro编写的一个易受攻击的优化通道，并为其编写漏洞利用代码。我们将在x64 Linux机器上进行操作，但在Windows平台上的利用过程完全相同（只需使用不同的shellcode！）。

# 环境搭建

## 构建V8

构建V8非常简单。您可以使用depot工具获取源代码，然后使用以下命令构建：

```bash
fetch v8
gclient sync
./build/install-build-deps.sh
tools/dev/gm.py x64.release
```

请注意，每当您更新源代码或检出特定提交时，请运行`gclient sync`，否则可能无法正确构建。

## d8 shell

引擎提供了一个非常方便的shell称为d8。为了加快构建速度，可以将编译限制在此shell：

```bash
~/v8$ ./tools/dev/gm.py x64.release d8
```

尝试运行：
```bash
~/v8$ ./out/x64.release/d8 
V8 version 7.3.0 (candidate)
d8> print("hello doare")
hello doare
```

# TurboFan编译管道

让我们看以下代码：

```javascript
let f = (o) => {
  var obj = [1,2,3];
  var x = Math.ceil(Math.random());
  return obj[o+x];
}

for (let i = 0; i < 0x10000; ++i) {
 f(i); 
}
```

我们可以使用`--trace-opt`跟踪优化，并观察到函数f最终会被TurboFan优化。

# 节点海洋

简单介绍一下节点海洋。TurboFan使用称为"节点海洋"的程序表示。节点可以表示算术运算、加载、存储、调用、常量等。有三种类型的边：

1. 控制边：与控制流图中的边相同，用于分支和循环
2. 值边：数据流图中的边，显示值依赖关系
3. 效果边：对读取或写入状态等操作进行排序

# 实验优化阶段

在本文中，我们想重点了解V8如何使用TurboFan生成优化代码。如前所述，TurboFan使用节点海洋，我们想了解这个图如何通过所有优化而演变。

## 处理NumberAdd

考虑以下函数：

```javascript
function opt_me() {
  let x = Math.random();
  let y = x + 2;
  return y + 3;
}
```

我们可以查看第一个生成的图，选择"bytecode graph builder"选项。JSCall节点对应于Math.random调用，NumberConstant和SpeculativeNumberAdd节点由x+2和y+3语句生成。

## 类型阶段

在图形创建之后是优化阶段，顾名思义，它运行各种优化过程。优化过程可以在多个阶段调用。其中一个早期优化阶段称为TyperPhase，由OptimizeGraph运行。

当Typer运行时，它会访问图中的每个节点并尝试减少它们。例如，对于JSCall节点，它会调用JSCallTyper。如果被调用的函数是内置函数，它将为其关联一个类型。

## 类型降低

在OptimizeGraph中，类型降低紧随类型分析之后。这个阶段会经过更多的reducer。例如，TypedOptimization::Reduce会在访问节点时调用ReduceSpeculativeNumberAdd。

# 边界检查节点

我们的最终实验涉及CheckBounds节点。基本上，带有CheckBounds操作码的节点在加载和存储之前添加边界检查。

考虑以下代码：

```javascript
function opt_me(b) {
  let values = [42,1337];       // HeapConstant <FixedArray[2]>
  let x = 10;                   // NumberConstant[10] | Range(10,10)
  if (b == "foo")
    x = 5;                      // NumberConstant[5] | Range(5,5)
                                // Phi | Range(5,10)
  let y = x + 2;                // SpeculativeSafeIntegerAdd | Range(7,12)
  y = y + 1000;                 // SpeculativeSafeIntegerAdd | Range(1007,1012)
  y = y * 2;                    // SpeculativeNumberMultiply | Range(2014,2024)
  y = y & 10;                   // SpeculativeNumberBitwiseAnd | Range(0,10)
  y = y / 3;                    // SpeculativeNumberDivide | PlainNumber[r][s][t]
  y = y & 1;                    // SpeculativeNumberBitwiseAnd | Range(0,1)
  return values[y];             // CheckBounds | Range(0,1)
}
```

为了防止values[y]使用越界索引，会生成一个CheckBounds节点。

# DuplicateAdditionReducer挑战

Stephen Röttger为Google CTF 2018编写的DuplicateAdditionReducer是一个很好的TurboFan挑战，它添加了一个新的reducer来优化类似x + 1 + 1的情况。

## 理解漏洞

V8使用IEEE-754双精度浮点数表示数字。这意味着它可以使用52位编码整数。因此最大值是pow(2,53)-1，即9007199254740991。大于此值的数字不能全部表示。因此，在计算大于该值的值时会出现精度损失。

## 漏洞利用

现在我们已经理解了漏洞，我们可能想要改进我们的原语。例如，获得读取和写入更多内存的能力会很有趣。

完整的利用链包括以下步骤：

1. 破坏FixedDoubleArray
2. 破坏JSArray并泄漏ArrayBuffer的后备存储
3. 获取伪造对象
4. 构建任意读/写原语
5. 覆盖WASM RWX内存

最终，我们可以将shellcode写入RWX内存并执行它。

# 结论

本文详细分析了V8引擎中TurboFan优化编译器的一个漏洞，通过精度丢失问题实现越界读写，最终构建出完整的利用链实现任意代码执行。希望您喜欢这篇文章！