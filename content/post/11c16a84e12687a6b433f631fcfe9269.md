---
date: 2025-08-07T05:24:38+08:00
title: Windows内核对象初始化器实验：绕过对象回调实现进程监控与反调试
tags: [Windows内核, 逆向工程, 反调试, 进程监控]
authors: qife
description: 本文探讨了一种通过修改Windows内核对象初始化器中的函数指针来实现进程监控和系统级反调试的技术。该方法避免了传统对象回调的限制，通过直接挂钩PsProcessType和DbgkDebugObjectType的关键函数，实现了无需签名的驱动模块即可监控进程创建和阻止调试器附加的能力。
---

# 实验Windows对象初始化器 - 参见PG合规免责声明* - 逆向工程

## 概述
在本文中，我想介绍一种有趣的方法，通过实验性替代手段实现类似于Windows对象回调功能的效果。众所周知，Windows系统上的反恶意软件、反作弊和通用监控工具经常使用这些回调。然而，它们的使用仅限于拥有签名模块的实体，而且这些回调存在被篡改的风险。

## 构建块
Windows内核中的对象是操作系统运行和记录的基础。我们将以一个熟悉的对象为例：进程(Process)。

### 进程创建与通知
Windows中的进程通知回调是系统监控和安全的基石。这些回调主要由反恶意软件和反作弊系统使用，提供关于进程创建和终止事件的实时通知。

## 函数指针重绑定
我们通过修改对象类型初始化器中的函数指针来实现进程通知回调，完全避开传统的对象回调列表。以下是关键实现步骤：

1. 定位ObTypeIndexTable表
2. 枚举所有对象类型，找到PsProcessType
3. 替换原始OpenProcedure指针为我们的处理函数

```c
NTSTATUS process_open_procedure(
    e_ob_open_reason open_reason,
    uint8_t access_mode,
    PEPROCESS process,
    PEPROCESS object_body,
    unsigned int* granted_access,
    unsigned long handle_count)
{
    // 处理进程创建事件
    if(open_reason == ob_open_handle) {
        // 记录进程创建信息
    }
    // 调用原始函数
    return g_ob_type_hook_pair.o_open_procedure(...);
}
```

## 利用SecurityProcedure实现反调试
通过挂钩DebugObject类型的安全过程，我们可以实现系统级反调试：

```c
NTSTATUS generic_security_procedure(
    void* object,
    SECURITY_OPERATION_CODE operation_code,
    ...)
{
    if(ob_type == *DbgkDebugObjectType) {
        // 阻止调试器附加
        return STATUS_DEBUG_ATTACH_FAILED;
    }
    // 调用原始函数
    return g_ob_type_tracking_data[...]->o_security_procedure(...);
}
```

## 实现结果
- 成功监控所有新创建的进程
- 有效阻止x64dbg和WinDbg等调试器附加
- 无需签名驱动模块即可实现

## 注意事项
- 该方法在Windows 11 23H2上测试通过
- 修改受PatchGuard保护的结构可能导致系统崩溃
- 建议仅在PG禁用或短时间内使用此技术

## 完整对象类型和过程转储
文章最后提供了完整的Windows内核对象类型及其相关过程的转储信息，包括：
- 类型名称
- 打开/关闭/删除过程
- 安全过程
- 解析过程等

这项技术展示了Windows内核对象系统的灵活性，为系统监控和安全研究提供了新的思路。